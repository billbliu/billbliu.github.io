<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第10章 模块化编程, Golang Rus Bill 数据结构和算法 网络 设计模式">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="良好的秩序是一切美好事物的基础。 
时至今日，软件开发早已从单打独斗迈入了相互协作的时代。在日常开发中，几乎每一个系统都在依赖别人编写的类库或框架。自开源运动兴起，到现在 GitHub 网站蓬勃发展，软件开发越来越高效和便利。如果想要解决什">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第10章 模块化编程 | bill的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/medias/logo.png" class="circle logo-img" alt="LOGO">
                        
                            <span class="logo-span">
                                bill的博客
                            </span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">bill的博客</div>
        <div class="logo-desc">
            
            华东交通大学 | 区块链工程师 | golang rust
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/billbliu/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/billbliu/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
                
    </nav>

</header>
    



    <div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
        <div class="container">
            <div class="row">
                <div class="col s12 m12 l12">
                    <div class="brand">
                        <div class="description center-align post-title">
                            第10章 模块化编程
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Rust编程之道/" target="_blank">
                                    <span class="chip bg-color">
                                        Rust编程之道
                                    </span>
                                </a>
                                
                        </div>
                        
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                                
                        </div>
                        
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>
                    发布日期:&nbsp;&nbsp;
                        2021-03-19
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>
                    作者:&nbsp;&nbsp;
                        
                                    bill
                                        
                </div>

                
                    
                        <div class="info-break-policy">
                            <i class="fa fa-file-word-o fa-fw"></i>
                            文章字数:&nbsp;&nbsp;
                                22.4k
                        </div>
                        

                            
                                <div class="info-break-policy">
                                    <i class="fa fa-clock-o fa-fw"></i>
                                    阅读时长:&nbsp;&nbsp;
                                        89
                                            分
                                </div>
                                
                                    

                                        
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>良好的秩序是一切美好事物的基础。 </p>
<p>时至今日，软件开发早已从单打独斗迈入了相互协作的时代。<em>在日常开发中，几乎每一个系统都在依赖别人编写的类库或框架。自开源运动兴起，到现在 GitHub 网站蓬勃发展，软件开发越来越高效和便利。如果想要解决什么问题，只需要到 GitHub 之类的开源平台直接寻找现成的解决方案即可</em>。而这些现成的解决方案大多是由不同国家的不同开发者提供的，而且针对同一个问题也有多种不同的解决方案。<strong>这些不同的解决方案之所以能够被有效、方便地复用，完全是因为模块化编程</strong>。 </p>
<p><strong>模块化编程，是指可以把整个代码分成小块的、分散的、独立的代码块，这些独立的代码块就被称为模块</strong>。<em>把一个复杂的软件系统按一定的信息分割为彼此独立的模块，有利于控制和克服系统的复杂性。模块化开发除支持多人协作之外，还支持各部分独立开发、测试和系统集成，甚至可以限制程序错误的影响范围</em>。总的来说，模块化编程拥有如下三点好处： </p>
<ul>
<li><strong>增强维护性。一个设计良好的模块，独立性更高，对外界的依赖更少，更方便维护。</strong> </li>
<li><strong>隔离性。拥有各自的命名空间，避免命名冲突，限制错误范围等。</strong></li>
<li><strong>代码复用。通过引入现成的模块来避免代码复制。</strong> </li>
</ul>
<p>基于模块化的诸多好处，很多编程语言都支持模块化，只是模块化的方式和程度均有不同。比如C或C++，使用头文件的方式来进行模块化编程。而Ruby在语法层面直接支持模块（Module），Python的一个文件就是一个模块。本来在语言层面不支持模块化的JavaScript语言，因为大前端时代的来临，也不得不在ES 6中加入模块化支持。Java语言之前也不支持模块化，社区长期使用JAR文件来进行模块化开发，但是Java9也在语法层面支持了模块化系统。由此可见模块化的重要性。 </p>
<p><strong>但是只有模块还不足以高效编写结构化的软件系统。那么如何方便地集成第三方开发的功能模块？一个简单的解决办法就是按照约定的目录结构来组织模块，并把此目录结构进一步打包成一个独立的模块，以方便外部集成。这种按约定的目录结构打包的模块，就被称为包。</strong>在编写一个包的时候，也难免会依赖第三方包，而这些被依赖的包也随时可能被更新、修改、升级，所以一般使用版本化管理。<strong>包与包之间的版本依赖关系，手工处理起来比较麻烦，所以需要使用包管理工具来解决依赖、打包、编译、安装等功能。常见的包管理工具有Linux上面的rpm、yum和apt等，语言级别的有Ruby的RubyGems、Python的pip，以及JavaScript的npm。</strong> </p>
<p><strong>Rust作为现代化编程语言，强有力地支持模块化编程。Rust中的包管理工具叫作Cargo，第三方包叫作crate。Rust拥抱开源，所有的第三方包都可以在GitHub上面找到，并且可以通过Cargo直接发布到包仓库平台crates.io上面。</strong></p>
<h2 id="10-1-包管理"><a href="#10-1-包管理" class="headerlink" title="10.1 包管理"></a>10.1 包管理</h2><p>与其他大多数语言不同的是，使用<strong>Rust编写代码的最基本单位是包（crate）。Rust语言内置了包管理器Cargo，通过使用Cargo可以方便地创建包</strong>。<strong>Cargo</strong>一共做了四件事情： </p>
<ol>
<li><strong>使用两个元数据（metadata）文件来记录各种项目信息。</strong> </li>
<li><strong>获取并构建项目的依赖关系。</strong> </li>
<li><strong>使用正确的参数调用rustc或其他构建工具来构建项目。</strong> </li>
<li><strong>为Rust生态系统开发建立了统一标准的工作流。</strong> </li>
</ol>
<p>通过Cargo提供的命令可以很方便地管理包。 </p>
<h3 id="10-1-1-使用Cargo创建包"><a href="#10-1-1-使用Cargo创建包" class="headerlink" title="10.1.1 使用Cargo创建包"></a>10.1.1 使用Cargo创建包</h3><p>使用cargo new命令创建包csv-read： </p>
<pre><code>$ cargo new csv-read --lib
Created library `csv-read` project</code></pre><p>在终端使用tree命令查看包目录结构： </p>
<pre><code>$ tree csv-read
  csv-read
├─ Cargo.toml
└─ src
    └─ lib.rs</code></pre><p>该包中包含的文件有Cargo.toml和src/lib.rs。其中<strong>Cargo.toml是包的配置文件，是使用TOML语言编写的。TOML语言的特色是：规范简单、语义明显、阅读性高。TOML专门被设计为可以无歧义地映射为哈希表，从而可以更容易地解析为各种语言中的数据结构。</strong>而Cargo.toml正是元数据文件之一。打开Cargo.toml，可以看到如代码清单10-1所示的代码。</p>
<p>代码清单<strong>10-1</strong>：<strong>Cargo.toml</strong>文件内容</p>
<pre><code>[package]
name = &quot;csv-read&quot;
version = &quot;0.1.0&quot;
authors = [&quot;billliu &lt;1321531943@qq.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]</code></pre><p>代码清单10-1展示了Cargo.toml文件的内容（manifest文件），它里面记录了用于编译整个包所用到的元数据。代码第1～5行定义的是包信息，记录了包的名字为“csv-read”。 </p>
<p>从Rust 1.30版本开始，默认创建的crate都会带有<strong>edition</strong>选项，其默认设置为“<strong>2018</strong>”。这代表默认crate使用<strong>Rust 2018</strong>版本。如果有需要，也可以将其修改为“2015”，以便支持<strong>Rust 2015</strong> 版本。 </p>
<p>再打开src/lib.rs文件，其初始内容如代码清单10-2所示。 </p>
<p>代码清单<strong>10-2</strong>：<strong>src/lib.rs</strong>初始内容 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> tests <span class="token punctuation">{</span>
    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function">it_works</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在src/lib.rs中，初始内容只有tests模块。<strong>在Rust中使用关键字mod来定义模块。＃[cfg（test）]属性为条件编译，告诉编译器只在运行测试（cargo test命令）时才编译执行</strong>。在tests模块中，生成了一个示例方法it_works。只要进入该包的根目录下，然后执行cargo test命令，即可看到测试正常运行，如下所示。</p>
<p><img src="/2021/03/19/the-tao-of-rust-programming-10/image-20210516121021340.png" alt="image-20210516121021340"></p>
<p>可以看出，tests：：it_works测试方法被成功执行，显示“ok.1 passed”。但是我们看到下面又有Doc-tests，这其实是指文档测试，因为<strong>Rust支持在文档注释里写测试</strong>。而这里并没有写任何文档测试。 </p>
<p>此时再使用tree命令来查看目录结构，如下所示。 </p>
<pre><code>.
├─ Cargo.lock
├─ Cargo.toml
├─ src
│    └─ lib.rs
└─ target
    └─ ...</code></pre><p>可以看出，多了一个<strong>Cargo.lock</strong>文件和target文件夹。<strong>Cargo.lock是另外一个元数据文件，它和Cargo.toml的不同点如下</strong>： </p>
<ul>
<li><em>Cargo.toml 是由开发者编写的，从广义上来描述项目所需要的各种信息，包括第三方包的依赖。</em> </li>
<li><em>Cargo.lock只记录依赖包的详细信息，不需要开发者维护，而是由Cargo自动维护的。</em> </li>
</ul>
<p><strong>target文件夹是专门用于存储编译后的目标文件的。编译默认为Debug模式，在该模式下编译器不会对代码进行任何优化，所以编译时间较短，代码运行速度较慢。也可以使用–release参数来使用发布模式，在该模式下，编译器会对代码进行优化，使得编译时间变慢，但是代码运行速度会变快。</strong> </p>
<p><strong>使用cargo new命令默认创建的是库文件（生成静态或动态链接库），它并非可执行文件，而是专门用于被其他应用程序共享的功能模块。如果想创建可执行文件，那么需要使用–bin参数</strong>。</p>
<pre><code>$ cargo new --bin csv-read
  Created binary (application) `csv-read` project</code></pre><p><strong>加–bin参数或者什么都不加，所创建的包就可被编译为可执行文件</strong>。使用tree命令来查看其目录结构，如下所示。</p>
<pre><code>$ tree csv-read
  csv-read
├─ Cargo.toml
├─ src
     └─ main.rs</code></pre><p>这里唯一的变化是在src下面的是main.rs文件。代码清单10-3展示了main.rs文件的初始内容。 </p>
<p>代码清单<strong>10-3</strong>：<strong>src/main.rs</strong>初始内容 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在main.rs文件中默认定义了main函数，这理所当然，因为可执行文件必须要有程序入口。可以通过执行cargo build命令来编译该包，但要注意，必须在包的根目录下执行该命令。也可以直接使用cargo run命令来编译并运行该包，如下所示。 </p>
<p><img src="/2021/03/19/the-tao-of-rust-programming-10/image-20210516122128214.png" alt="image-20210516122128214"></p>
<h3 id="10-1-2-使用第三方包"><a href="#10-1-2-使用第三方包" class="headerlink" title="10.1.2 使用第三方包"></a>10.1.2 使用第三方包</h3><p>在日常开发中，经常会使用到第三方包。<strong>在 Rust 中使用第三方包非常简单，只需要在Cargo.toml中的[dependencies]下面添加想依赖的包即可</strong>。</p>
<p>假如想在上面创建好的csv-read中添加linked-list包，如代码清单10-4所示。</p>
<p>代码清单<strong>10-4</strong>：在<strong>Cargo.toml</strong>文件中添加<strong>linked-list</strong>依赖 </p>
<pre><code>[dependencies]
linked-list = &quot;0.0.3&quot;</code></pre><p>然后在src/main.rs或src/lib.rs文件中，<strong>使用extern crate命令声明引入该包即可使用</strong>，如代码清单10-5所示。 </p>
<p>代码清单<strong>10-5</strong>：在<strong>src/main.rs</strong>文件中使用<strong>extern crate</strong>命令声明引入第三方包</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> linked_list<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-5中，代码第1行使用<strong>extern crate</strong>声明引入第三方包。这是Rust 2015版本的写法。在<strong>Rust 2018</strong> 版本中，可以省略掉extern crate这种写法，因为在Cargo.toml中已经添加了依赖。 </p>
<p>另外，值得注意的是，使用<strong>extern crate</strong>声明包的名称是linked_list，用的是下画线“<strong>_</strong>”，而在Cargo.toml中用的是连字符“-”。这是怎么回事呢？其实Cargo默认会把连字符转换成下画线。这是为了统一包名称，因为linked-list和linked_list到底是不是同一个包，容易造成歧义。</p>
<p>Rust也不建议以“-rs”或“_rs”为后缀来命名包名，并且会强制性地将此后缀去掉，所以在命名时要注意。接下来，通过介绍在日常编程中两个比较实用的第三方包，来看看如何集成第三方包完成功能。 </p>
<p>使用正则表达式<strong>regex</strong>包 </p>
<p>在Rust标准库中并没有内置正则表达式的支持，它是作为第三方包而存在的，名为regex。现在使用cargo new–bin use_regex命令创建一个新的包，然后在Cargo.toml文件中添加regex依赖，如代码清单10-6所示。</p>
<p>代码清单<strong>10-6</strong>：在<strong>Cargo.toml</strong>文件中添加<strong>regex</strong>依赖 </p>
<pre><code>[dependencies]
regex = &quot;1.0.5&quot;</code></pre><p>当前regex最新的版本是1.0.5。然后，在src/main.rs中同样使用extern crate来声明引入regex包，如代码清单10-7所示。 </p>
<p>代码清单<strong>10-7</strong>：在<strong>src/main.rs</strong>中声明引入<strong>regex</strong>包 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> regex<span class="token punctuation">;</span>
<span class="token keyword">use</span> regex<span class="token punctuation">:</span><span class="token punctuation">:</span>Regex<span class="token punctuation">;</span>
<span class="token keyword">const</span> TO_SEARCH<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str <span class="token operator">=</span> "
On <span class="token number">2017</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">,</span> happy<span class="token punctuation">.</span> On <span class="token number">2018</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span><span class="token punctuation">,</span> New Year<span class="token punctuation">.</span>
"<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> re <span class="token operator">=</span> Regex<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">r"(\d{4})-(\d{2})-(\d{2})"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> caps <span class="token keyword">in</span> re<span class="token punctuation">.</span><span class="token function">captures_iter</span><span class="token punctuation">(</span>TO_SEARCH<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Year: {}, month: {}, day: {}"</span><span class="token punctuation">,</span>
            caps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            caps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            caps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用cargo run命令编译并执行该包，会得到如下执行结果： </p>
<pre><code>year: 2017, month: 12, day: 31
year: 2018, month: 01, day: 01</code></pre><p>在代码清单 10-7 中，<strong>先使用 extern crate regex 声明引入 regex 包，然后使用 use regex：：Regex声明，是为了简化代码，这样就可以直接在use_regex包里使用Regex了</strong>，如代码第7行所示。 </p>
<p><strong>如果不使用 use 声明，那么也可以直接使用 regex：：Regex：：new，但是在可读性上就差了许多</strong>。 </p>
<p>代码第7行，给定了正则表达式字符串，由此生成正则实例re。然后在代码第8行，通过<strong>captures_iter</strong>方法，对给定的常量字符串TO_SEARCH进行匹配和迭代，并依次将捕获匹配到的字符串打印出来，因为给定的正则表达式是带有捕获组的表达式。 </p>
<p>regex 包支持大部分正则匹配功能，但不支持环视（<strong>look-around</strong>）和反向引用（<strong>backreference</strong>）。这是因为 regex 注重性能和安全，而环视和反向引用更容易被黑客利用制造<strong>ReDos</strong>攻击。如果一定要使用环视和反向引用，则可以使用<strong>fancy-regex</strong>包。 </p>
<p>regex包也支持命名捕获，如代码清单10-8所示。 </p>
<p>代码清单<strong>10-8</strong>：使用命名捕获的示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> re <span class="token operator">=</span> Regex<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>r"<span class="token punctuation">(</span>?x<span class="token punctuation">)</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>year<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span> # the year
        <span class="token operator">-</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>month<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> # the month
        <span class="token operator">-</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>day<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> # the day
    "<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> caps <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">captures</span><span class="token punctuation">(</span><span class="token string">"2018-01-01"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"2018"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"year"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"01"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"month"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"01"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"day"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> after <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">replace_all</span><span class="token punctuation">(</span><span class="token string">"2018-01-01"</span><span class="token punctuation">,</span> <span class="token string">"$month/$day/$year"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>"afte<span class="token string">r", "</span><span class="token number">01</span><span class="token operator">/</span><span class="token number">01</span><span class="token operator">/</span><span class="token number">2018</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-8中，代码第2～8行，<strong>传给Regex：：new方法的正则表达式以（？x）为前缀，这是指定了正则表达式标记x。regex包支持多种正则表达式标记，意义如下</strong>： </p>
<ul>
<li><strong>i，匹配时不区分大小写。</strong> </li>
<li><strong>m，多行模式，“^”和“$”对应行首和行尾。</strong> </li>
<li><strong>s，允许通配符“.”匹配“\n”。</strong> </li>
<li><strong>U，大写U，交换“x*”和“x*？”的意义。</strong> </li>
<li><strong>u，小写u，允许支持Unicode（默认启用）</strong>。</li>
<li><strong>x，忽略空格并允许行注释（以“＃”开头）。</strong> </li>
</ul>
<p>所以，在代码清单10-8中，从代码第2～8行可以看到，为正则表达式加上了空格和注释也不影响最终的匹配结果。也要注意在该正则表达式中使用了（？P＜name＞exp）这种格式来定义命名捕获组。 </p>
<p>代码第9行，<strong>使用captures方法就可以获取匹配的捕获变量，并保存到一个HashMap中，以命名变量作为HashMap的键，匹配的字符串作为值</strong>。代码第10～12行，就可以直接从caps中按指定的键取相应的值。 </p>
<p>代码第13行和第14行，使用replace_all方法按指定的格式来替换匹配的字符串。注意指定的格式是以“$”符号和命名捕获变量组合而成的。</p>
<p>regex还有很多其他功能和用法，可以翻阅其文档来获取更多内容。</p>
<p>惰性静态初始化<strong>lazy_static</strong>包 </p>
<p><strong>在编程中，经常会有对全局常量或变量的需求。Rust 支持两种全局类型：普通常量（Constant）和静态变量（Static）</strong>。它们的异同之处在于以下几点： </p>
<ul>
<li><strong>都是在编译期求值的，所以不能用于存储需要动态分配内存的类型，比如HashMap、Vector等</strong>。 </li>
<li><strong>普通常量是可以被内联的，它没有确定的内存地址，不可变</strong>。 </li>
<li><strong>静态变量不能被内联，它有精确的内存地址，拥有静态生命周期</strong>。</li>
<li><strong>静态变量可以通过内部包含UnsafeCell等的容器实现内部可变性</strong>。 </li>
<li><strong>静态变量还有其他限制，比如不包含任何析构函数、包含的值类型必须实现了 Sync以保证线程安全、不能引用其他静态变量。</strong> </li>
<li><strong>普通常量也不能引用静态变量。</strong> </li>
</ul>
<p><strong>在存储的数据比较大、需要引用地址或具有可变性的情况下使用静态变量；否则，应该优先使用普通常量。但也有一些情况是这两种全局类型无法满足的，比如想使用全局的HashMap或Vector，或者在使用正则表达式时只让其编译一次来提升性能。在这种情况下，推荐使用lazy_static包。</strong>利用<strong>lazy_static包可以把定义全局静态变量延迟到运行时，而非编译时，所以冠之以“惰性（lazy）”</strong>。在Cargo.toml中添加lazy_static依赖 。</p>
<p>如代码清单10-9所示。 </p>
<p>代码清单<strong>10-9</strong>：在<strong>Cargo.toml</strong>中添加<strong>lazy_static</strong>依赖 </p>
<pre><code>[dependencies]
regex = &quot;1.0.5&quot;
lazy_static = &quot;1.1.0&quot;</code></pre><p>继续在use_regex包中添加lazy_static依赖。然后在src/main.rs中通过extern crate引入lazy_static包，如代码清单10-10所示。 </p>
<p>代码清单<strong>10-10</strong>：修改<strong>src/main.rs</strong>文件，通过<strong>extern crate</strong>引入 <strong>lazy_static</strong>包</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[macro_use]</span> <span class="token keyword">extern</span> <span class="token keyword">crate</span> lazy_static<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> regex<span class="token punctuation">;</span>
<span class="token keyword">use</span> regex<span class="token punctuation">:</span><span class="token punctuation">:</span>Regex<span class="token punctuation">;</span>
<span class="token macro-rules function">lazy_static!</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">ref</span> RE<span class="token punctuation">:</span> Regex <span class="token operator">=</span> Regex<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>r"<span class="token punctuation">(</span>?x<span class="token punctuation">)</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>year<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">-</span> # the <span class="token function">year</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>month<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">-</span> # the <span class="token function">month</span>
        <span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>day<span class="token operator">></span>\d<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> # the day
    "<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">ref</span> EMAIL_RE<span class="token punctuation">:</span> Regex <span class="token operator">=</span> Regex<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>r"<span class="token punctuation">(</span>?x<span class="token punctuation">)</span>
        <span class="token operator">^</span>\w<span class="token operator">+</span><span class="token operator">@</span><span class="token punctuation">(</span>?<span class="token punctuation">:</span>gmail<span class="token operator">|</span><span class="token number">163</span><span class="token operator">|</span>qq<span class="token punctuation">)</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>?<span class="token punctuation">:</span>com<span class="token operator">|</span>cn<span class="token operator">|</span>com\<span class="token punctuation">.</span>cn<span class="token operator">|</span>net<span class="token punctuation">)</span>$
    "<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">regex_date</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> regex<span class="token punctuation">:</span><span class="token punctuation">:</span>Captures <span class="token punctuation">{</span>
    RE<span class="token punctuation">.</span><span class="token function">captures</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">regex_email</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>
    EMAIL_RE<span class="token punctuation">.</span><span class="token function">is_match</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> caps <span class="token operator">=</span> <span class="token function">regex_date</span><span class="token punctuation">(</span><span class="token string">"2018-01-01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"2018"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"year"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"01"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"month"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"01"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caps<span class="token punctuation">[</span><span class="token string">"day"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> after <span class="token operator">=</span> RE<span class="token punctuation">.</span><span class="token function">replace_all</span><span class="token punctuation">(</span><span class="token string">"2018-01-01"</span><span class="token punctuation">,</span> <span class="token string">"$month/$day/$year"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>after<span class="token punctuation">,</span> <span class="token string">"01/01/2018"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">regex_email</span><span class="token punctuation">(</span><span class="token string">"alex@gmail.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">regex_email</span><span class="token punctuation">(</span><span class="token string">"alex@gmail.cn.com"</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-10是Rust2015的写法。代码第1行，使用了<strong>＃[macro_use] extern crate lazy_static</strong>，是因为需要使用lazy_static包中定义的lazy_static！宏。＃[macro_use]可以和extern crate lazy_static写成两行，未来＃[macro_use]或可省略，该属性的意思是导出包中定义的宏。当然，<strong>在Rust 2018中，extern crate语法可以省略，那么相应的＃[macro_use]也可以省略，也就是说，代码第1代和第2行皆可省略。</strong> </p>
<p>代码第4～13行，使用lazy_static！宏定义了两个全局静态变量RE和EMAIL_RE，它们是不同的正则表达式。这样一来，就只需要编译一次，而不会重复编译。之所以把正则表达式定义为全局静态变量，是出于编译性能的考虑，如果该正则表达式被用于循环匹配中，那么会降低编译的性能，并且不利于正则表达式引擎内部的优化。 </p>
<p>代码第14～19行，分别定义了regex_date和regex_email方法，用来匹配传入的字符串。在main函数中，则可以方便地使用它们。 </p>
<p>当需要全局的容器时，比如HashMap，也可以使用lazy_static包。 </p>
<p>首先使用<strong>cargo new–bin static_hashmap</strong>命令创建新的包，然后在<strong>Cargo.toml</strong>中添加lazy_static依赖，再修改src/main.rs代码，如代码清单10-11所示。 </p>
<p>代码清单<strong>10-11</strong>：修改新创建的<strong>static_hashmap</strong>包中的<strong>src/main.rs</strong>代码</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[macro_use]</span><span class="token keyword">extern</span> <span class="token keyword">crate</span> lazy_static<span class="token punctuation">;</span>
<span class="token keyword">mod</span> static_kv <span class="token punctuation">{</span>
    <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>collections<span class="token punctuation">:</span><span class="token punctuation">:</span>HashMap<span class="token punctuation">;</span>
    <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>sync<span class="token punctuation">:</span><span class="token punctuation">:</span>RwLock<span class="token punctuation">;</span>
    <span class="token keyword">pub</span> <span class="token keyword">const</span> NF<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str <span class="token operator">=</span> <span class="token string">"not found"</span><span class="token punctuation">;</span>
    <span class="token macro-rules function">lazy_static!</span> <span class="token punctuation">{</span>
        <span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> MAP<span class="token punctuation">:</span> HashMap<span class="token operator">&lt;</span>u32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> HashMap<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>
            m
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> MAP_MUT<span class="token punctuation">:</span> RwLock<span class="token operator">&lt;</span>HashMap<span class="token operator">&lt;</span>u32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token operator">>></span> <span class="token operator">=</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> HashMap<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            RwLock<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">ref</span> m <span class="token operator">=</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP<span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">,</span>
    <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
            <span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>?<span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
            <span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>?<span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
                <span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">asssert_eq!</span><span class="token punctuation">(</span><span class="token string">"baz"</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Error {}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-11中，代码第1行，同样是通过＃[macro_use] extern crate lazy_static引入包和lazy_static！宏的。 </p>
<p>代码第2～19行，<strong>使用mod关键字定义了static_kv模块。模块是Rust模块化编程的基础，其作用域是独立的、封闭的，在static_kv中定义的常量或方法默认是私有的。所以，想要在模块外调用模块中的常量或方法，就必须通过pub关键字将可见性改为公开的。</strong> </p>
<p>所以，代码第3行和第4行，使用use引入了std：：collections和std：：sync模块，使用其中定义的HashMap和RwLock，只对模块static_kv有效。 </p>
<p>代码第5行，使用pub const定义了公开的普通常量NF，它是一个字符串字面量类型。如果想在模块外使用它，就必须带上命名空间，也就是模块的名字：static_hash：：NF。 </p>
<p>代码第6～18行，使用lazy_static！宏定义了两个全局静态变量MAP和MAP_MUT，分别代表只读的HashMap和可变的HashMap。 </p>
<p>lazy_static！宏的语法格式如代码清单10-12所示。 </p>
<p>代码清单<strong>10-12</strong>：<strong>lazy_static</strong>！宏的语法格式 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token macro-rules function">lazy_static!</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">pub</span><span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> NAME_1<span class="token punctuation">:</span> TYPE_1 <span class="token operator">=</span> WXPR_1<span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">pub</span><span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> NAME_2<span class="token punctuation">:</span> TYPE_2 <span class="token operator">=</span> WXPR_2<span class="token punctuation">;</span>
    <span class="token punctuation">...</span>
    <span class="token punctuation">[</span><span class="token keyword">pub</span><span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> NAME_N<span class="token punctuation">:</span> TYPE_N <span class="token operator">=</span> WXPR_N<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<strong>使用lazy_static！宏时，必须严格按照此语法格式来书写，否则会引发线程恐慌</strong>。 </p>
<p>回到代码清单10-11中，代码第7～11行，定义了一个不可变（只读）的HashMap类型的全局静态变量MAP，并插入了一个初始化的键值对“{0：＂foo＂}”。 </p>
<p>代码第12～17行，定义了可变（可读可写）的RwLock＜HashMap＜u32，&amp;＇static str＞＞类型的全局静态变量MAP_MUT。注意，<strong>这里使用了RwLock读写锁来包装HashMap，这是因为可能会有多个线程来访问HashMap，而HashMap并没有实现Sync，所以HashMap不是线程安全的类型。因此，必须使用同步锁来保护HashMap，让其线程安全。其实也可以使用Metux互斥锁来保护HashMap</strong>，它们的区别在于： </p>
<ul>
<li>RwLock读写锁，是多读单写锁，也叫共享独占锁。它允许多个线程读，单个线程写。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。读锁和写锁不能被同时获取。 </li>
<li>Metux互斥锁，只允许单个线程读和写。 </li>
</ul>
<p><strong>所以在读数据比较频繁远远大于写数据的情况下，使用RwLock读写锁可以给程序带来更高的并发支持</strong>。在第11章中还会对它们做更详细的介绍。</p>
<p>作为全局静态变量，希望 MAP_MUT 希望用于多读单写的场景中，所以这里使用了RwLock读写锁。</p>
<p>代码第20～25行，定义了read_kv函数。<strong>在该函数内部，使用了static_kv：：MAP来获取static_kv 模块中定义好的全局静态变量 MAP，如果不加命名空间 static_kv，则无法访问到MAP</strong>。 </p>
<p>代码第 21 行，使用了 ref 模式匹配来获取 static_kv：：MAP 的引用 m，也可以直接使用&amp;static_kv：：MAP来获取引用m。代码第22～24行，通过对m解引用，得到其内部的HashMap类型，并使用get方法来获取存储于MAP中的初始键值对。这里使用get方法来获取HashMap指定键的值，是一个很好的工程实践，因为 get 方法会返回 Option＜T＞类型。如果没有获取到，则会返回 None，或者是指定的其他值，比如该行中的&amp;static_kv：：NF，这样更有利于错误处理。也可以直接使用*m[&amp;0]这样的写法，但它返回的是&amp;T 类型，如果没有匹配的值，则线程会发生恐慌。 </p>
<p>代码第26～38行，定义了rw_mut_kv函数，该函数返回一个Result＜（），String＞类型。在该函数中使用的是 static_kv：：MAP_MUT 全局静态变量，它的类型实际上是RwLock＜HashMap＜u32，&amp;＇static str＞＞。RwLock读写锁提供了read和write方法来获取读锁和写锁。 </p>
<p>注意，在函数rw_mut_kv中，<strong>使用了代码块对read和write进行了隔离，如代码第27～31行以及代码第32～36行所示。这是因为读锁和写锁不能被同时获取。只有放到代码块中，才能让读锁和写锁得到释放，因为Rust的RAII机制，在资源（这里是锁）出了作用域之后会得到释放</strong>。 </p>
<p>如果把代码块去掉，则会发生死锁情况。在Rust中，叫作“中毒（<strong>Poison</strong>）”。但是，如果该函数中只存在读的情况，而没有写，则不需要引入代码块隔离，因为RwLock是允许多个线程同时读的。同样，在第11章中会介绍更多的相关内容。 </p>
<p>在main函数中，分别调用了read_kv和rw_mut_kv。因为rw_mut_kv返回的是Result类型，所以需要使用match匹配处理Ok和Err两种情况。如果写入正常，那么也可以正常读取HashMap中写入的值；否则输出错误。</p>
<p>综上所述，就是惰性静态初始化 lazy_static 包的两个使用场景。另外，还有两个值得注意的地方： </p>
<ul>
<li>使用lazy_static！宏定义的全局静态变量如果有析构函数，则是不会被调用的，因为是静态生命周期。 </li>
<li>在 lazy_static！宏中不能定义太多的全局静态变量，否则会引发线程恐慌。这是因为在lazy_static！宏中调用了内部的宏，Rust 对宏的递归调用有调用次数限制。可以通过在当前编写的包中加上＃！[recursion_limit=＂128＂]属性修改上限，默认值为 32，比如可以修改为128。</li>
</ul>
<p>在不久的将来，Rust 的 CTFE（编译时函数执行）功能进一步完善之后，在某些场景中也许就不需要使用lazy_static包了。 </p>
<p>指定第三方包的依赖关系 </p>
<p>Rust包使用的是语义化版本号（<strong>SemVer</strong>）。基本格式为“<strong>X.Y.Z</strong>”，版本号递增规则如下： </p>
<ul>
<li><strong>X</strong>，主版本号（major）。当做了不兼容或颠覆性的更新时，修改此版本号。 </li>
<li><strong>Y</strong>，次版本号（minor）。当做了向下兼容的功能性修改时，修改此版本号。 </li>
<li><strong>Z</strong>，修订版本号（patch）。当做了向下兼容的问题修正时，修改此版本号。 </li>
</ul>
<p>语义化版本号是为了解决所谓“依赖地狱”的问题。随着系统规模的增长，加入的第三方包就会越来越多，包之间的依赖关系也会越来越复杂，容易造成“依赖地狱”。 </p>
<p>比如增加lazy_static依赖时，指定了版本号为“1.0.0”。该版本号等价于“^1.0.0”，这意味着当有新的lazy_static包发布时，允许Cargo在主版本号不变的情况下，更新次版本号或修订版本号。比如发布了“1.1.0”，那么当执行cargo build或cargo run命令时，会自动依赖最新的“1.1.0”包。 </p>
<p>指定版本号范围的标记有以下几种： </p>
<ul>
<li><strong>补注号（^），允许新版本号在不修改[major，minor，patch]中最左边非零数字的情况下才能更新</strong>。 </li>
<li><strong>通配符（*），可以用在[major，minor，patch]的任何一个上面</strong>。 </li>
<li><strong>波浪线（～），允许修改[major，minor，patch]中没有明确指定的版本号</strong>。</li>
<li><strong>手动指定，通过＞、＞=、＜、＜=、=来指定版本号</strong>。 </li>
</ul>
<p>具体的示例如代码清单10-13所示。 </p>
<p>代码清单<strong>10-13</strong>：语义化版本号示例</p>
<pre><code>// := 表示 等价于
// 补注号示例
^1.2.3 := &gt;= 1.2.3 &lt; 2.0.0
^1.2 := &gt;= 1.2.0 &lt; 2.0.0
^1 := &gt;= 1.0.0 &lt; 2.0.0
^0.2.3 := &gt;= 0.2.3 &lt; 0.3.0
^0.0.3 := &gt;= 0.0.3 &lt; 0.0.4
^0.0 := &gt;= 0.0.0 &lt; 0.1.0
^0 := &gt;= 0.0.0 &lt; 1.0.0
// 通配符示例
:= &gt;= 0.0.0
1.* := &gt;= 1.0.0 &lt; 2.0.0
1.2.* := &gt;= 1.2.0 &lt; 1.3.0
// 波浪线示例
~1.2.3 := &gt;= 1.2.3 &lt; 1.3.0
~1.2 := &gt;= 1.2.0 &lt; 1.3.0
~1 := &gt;= 1.0.0 &lt; 2.0.0
// 手动指定
&gt;= 1.2.0
&gt; 1 
&lt; 2
= 1.2.3
// 手动指定多个版本
&gt;= 1.2, &lt; 1.5</code></pre><p><strong>除语义化版本号之外，Cargo 还全面支持 git。可以直接指定 git 仓库地址</strong>，如代码清单10-14所示。 </p>
<p>代码清单<strong>10-14</strong>：可以直接指定<strong>git</strong>仓库地址</p>
<pre><code>[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; }</code></pre><p><strong>当一个包依赖本地的包时，也可以指定其依赖路径。</strong>比如在上面创建的 static_hashmap包中，又创建了一个新的包hello_world，就可以在static_hashmap的Cargo.toml文件中按路径指定依赖关系，如代码清单10-15所示。</p>
<p>代码清单<strong>10-15</strong>：可以使用<strong>path</strong>来指定本地包<strong>hello_world</strong></p>
<pre><code>[dependencies]
hello_world = { path = &quot;hello_world&quot;, version = &quot;0.1.0&quot; }</code></pre><p>注意，在代码清单10-15中，hello_world是在static_hashmap包的根目录下创建的，path默认的根目录就是static_hashmap包的根目录。但是这种通过path指定本地依赖的包，不允许被发布到crates.io仓库平台上面。 </p>
<h3 id="10-1-3-Cargo-toml文件格式"><a href="#10-1-3-Cargo-toml文件格式" class="headerlink" title="10.1.3 Cargo.toml文件格式"></a>10.1.3 Cargo.toml文件格式</h3><p><strong>TOML文件是通用的格式，可以用它表示任何配置格式。Cargo也有一套专用的TOML配置格式。</strong>现在以第三方包regex[3]作为示例来说明。代码清单10-16展示了regex包的目录结构。 </p>
<p>代码清单<strong>10-16</strong>：<strong>regex</strong>包的目录结构 </p>
<pre><code>regex
   ├─ bench/
   ├─ ci/
   ├─ examples/
   ├─ regex-capi/
   ├─ regex-debug/
   ├─ regex-syntax/
   ├─ scripts/
   ├─ src/
   ├─ test/
   └─ Cargo.toml</code></pre><p>在regex包里还包含着另外四个包，分别是bench、regex-capi、regex-debug和regex-syntax。<strong>[package]</strong>表配置现在打开Cargo.toml 文件看看相关配置。代码清单10-17 展示了regex 包中Cargo.toml文件的[package]表配置。 </p>
<p><strong>(1) [package]表配置</strong></p>
<p>代码清单<strong>10-17</strong>：<strong>regex</strong>包中<strong>Cargo.toml</strong>文件的<strong>[package]</strong>表配置</p>
<pre><code>[package]
name = &quot;regex&quot;
version = &quot;1.0.5&quot;  #:version
authors = [&quot;The Rust Project Developers&quot;]
license = &quot;MIT/Apache-2.0&quot;
readme = &quot;README.md&quot;
repository = &quot;https://github.com/rust-lang/regex&quot;
documentation = &quot;https://docs.rs/regex&quot;
description = &quot;&quot;&quot;
An implementation of regular expressions for Rust.
This implementation uses
finite automata and guarantees linear time matching on all inputs.
&quot;&quot;&quot;
categories = [&quot;text-processing&quot;]</code></pre><p><strong>在TOML语言中，[package]这种语法叫作表（Table）。在[package]表里描述的都是和regex包有关的元数据，比如包名（name）、作者（authors）、源码仓库地址（repository）、文档地址（documentation）、包功能的简要介绍（description）、包的分类（categories）等。</strong> </p>
<p>注意<strong>其中的语法，基本都是字符串。如果是数组，则使用中括号；如果是多段的文字，则使用三引号“＂＂＂”。</strong> </p>
<p>[package]表是每个包必不可少的，它相当于代码清单10-18中描述的JSON格式。 </p>
<p>代码清单<strong>10-18</strong>：<strong>[package]</strong>表等价于这样的<strong>JSON</strong>格式</p>
<pre><code>&quot;package&quot;: {
    &quot;name&quot;: &quot;regex&quot;,
    &quot;version&quot;: &quot;1.0.5&quot;,
    // 省略
    &quot;categories&quot;: [&quot;text-processing&quot;]
}</code></pre><p><strong>(2) [badges]表配置</strong> </p>
<p>继续看regex包的Cargo.toml文件，接下来是<strong>[badges]</strong>表配置，如代码清单10-19所示。 </p>
<p>代码清单<strong>10-19</strong>：<strong>[badges]</strong>表配置</p>
<pre><code>[badges]
travis-ci = { repository = &quot;rust-lang/regex&quot; }
appveyor = { repository = &quot;rust-lang-libs/regex&quot; }</code></pre><p>在代码清单10-19中展示了<strong>[badges]表配置，设置了travis-ci和appveyor。这两项表配置表示可以在crates.io网站上显示travis-ci和appveyor的展示徽章</strong>。travis-ci和appveyor都是云端的持续集成服务平台，前者支持Linux和Mac OS系统，后者支持Windows系统。另外，[badges]表还支持 GitLab、codecov 等诸多平台。[badges]表是一个可选表，如果没有持续集成服务，则可以不配置此表。 </p>
<p><strong>(3) [workspace]表配置</strong> </p>
<p>接下来是[workspace]表配置，如代码清单10-20所示。 </p>
<p>代码清单<strong>10-20</strong>：<strong>[workspace]</strong>表配置 </p>
<pre><code>[workspace]
members = [&quot;bench&quot;, &quot;regex-capi&quot;, &quot;regex-debug&quot;, &quot;regex-syntax&quot;]</code></pre><p>在代码清单10-20中，<strong>[workspace]表代表工作空间（Workspace）。工作空间是指在同一个根包（crate）下包含了多个子包（crate）。</strong>在本例中，根包就是regex，而在代码第2行，members键指定了bench、regex-capi、regex-debug、regex-syntax四个子包。 </p>
<p><strong>工作空间中的子包都有自己的Cargo.toml配置，各自独立，互不影响。在根包regex的Cargo.toml 中指定的依赖项，也不会影响到子包。不管是编译根包还是子包，最终的编译结果永远都会输出到根包的target目录下，并且整个工作空间只允许有一个Cargo.lock文件。</strong> </p>
<p><strong>(4) [dependencies]表配置</strong> </p>
<p>继续看根包regex的Cargo.toml文件，接下来就是[dependencies]表配置，如代码清单10-21所示。 </p>
<p>代码清单<strong>10-21</strong>：<strong>[dependencies]</strong>表和<strong>[dev-dependencies]</strong>表配置 </p>
<pre><code>[dependencies]
aho-corasick = &quot;0.6.7&quot;
memchr = &quot;2.0.2&quot;
thread_local = &quot;0.3.6&quot;
regex-syntax = { path = &quot;regex-syntax&quot;, version = &quot;0.6.2&quot;}
utf8-ranges = &quot;1.0.1&quot;
[dev-dependencies]
lazy_static = &quot;1&quot;
quickcheck = { version = &quot;0.7&quot;, default-features =false }
rand = &quot;0.5&quot;</code></pre><p>在代码清单10-21中展示了<strong>[dependencies]</strong>表和<strong>[dev-dependencies]</strong>表配置。[dependencies]表在前面介绍过，它专门用于设置第三方包的依赖，这些依赖会在执行cargo build命令编译时使用。[dev-dependencies]表的作用与之类似，只不过它只用来设置测试（tests）、示例（examples）和基准测试（benchmarks）时使用的依赖，在执行<strong>cargo test</strong>或<strong>cargo bench</strong>命令时使用。 </p>
<p><strong>(5) [features]表配置</strong> </p>
<p>接下来是<strong>[features]</strong>表配置，如代码清单10-22所示。 </p>
<p>代码清单<strong>10-22</strong>：<strong>[features]</strong>表配置 </p>
<pre><code>[features]
default = [&quot;use_std&quot;]
use_std = []
unstable = [&quot;pattern&quot;]
pattern = []</code></pre><p>在代码清单10-22中，<strong>[features]表中的配置项与条件编译功能相关。在Rust中，有一种特殊的属性＃[cfg]，叫作条件编译属性，该属性允许编译器按指定的标记选择性地编译代码</strong>。在此例中，pattern表示允许使用std标准库中定义的Pattern trait，但是该trait目前还处于未稳定状态，所以使用了unstable配置。 </p>
<p>代码清单10-23展示了在regex包中如何使用条件编译属性。 </p>
<p>代码清单<strong>10-23</strong>：在<strong>regex</strong>包中使用＃<strong>[cfg]</strong>属性 </p>
<pre><code>#[cfg(not(feature = &quot;use_std&quot;))]
compile_error!(&quot;`use_std`featrue is currently required to build this crate&quot;);
#[cfg(feature = &quot;pattern&quot;)]
mod pattern;</code></pre><p>在代码清单10-23中，代码第3行使用了<strong>＃[cfg（feature=＂pattern＂）]</strong>，这意味着当执行<strong>cargo build–features ＂pattern＂</strong>命令时，在Cargo 内部调用 Rust 编译器 rustc 时会传<strong>–cfg feature=＂pattern＂</strong>标记，那么在输出中也会包含pattern模块；否则，不会编译pattern模块。 </p>
<p>代码第1行使用了<strong>＃[cfg（not（feature=＂use_std＂））]</strong>，其作用正好和<strong>＃[cfg（feature=＂use_std＂）]</strong>相反，表示在编译时不指定features参数。 </p>
<p><strong>(6) [lib]表配置</strong> </p>
<p>继续看regex根包的Cargo.toml文件，接下来是[lib]表配置，如代码清单10-24所示。 </p>
<p>代码清单<strong>10-24</strong>：<strong>[lib]</strong>表配置 </p>
<pre><code>[lib]
bench = false</code></pre><p>代码清单 10-24 展示的<strong>[lib]表用来表示最终编译目标库的信息</strong>，该表完整的配置项主要包含以下几类： </p>
<ul>
<li><strong>name</strong>。比如<strong>name=＂foo＂，表示将来编译的库名字为“libfoo.a”或“libfoo.so”</strong>等。 </li>
<li><strong>crate-type</strong>。比如<strong>crate-type=[＂dylib＂，＂staticlib＂]，表示可以同时编译生成动态库和静态库</strong>。 </li>
<li><strong>path</strong>。比如path=＂src/lib.rs＂，<strong>表示库文件入口，如果不指定，则默认是src/lib.rs</strong>。</li>
<li><strong>test</strong>。比如<strong>test=true，表示可以使用单元测试</strong>。 </li>
<li><strong>bench</strong>。比如<strong>bench=true，表示可以使用性能基准测试</strong>。</li>
</ul>
<p>还有其他配置项，这里就不一一列举了。在本例中，因为根包中没有提供性能基准测试，所以将bench设置为false。 </p>
<p><strong>(7) [test]表配置</strong> </p>
<p>接下来是<strong>[[test]]</strong>表配置，注意到该表由两个中括号嵌套表示，这在TOML语言中代表表数组，如代码清单10-25所示。 </p>
<p>代码清单<strong>10-25</strong>：<strong>[[test]]</strong>表配置 </p>
<pre><code>[[test]]
path = &quot;tests/test_default.rs&quot;
name = &quot;default&quot;
[[test]]
path = &quot;tests/test_default_bytes.rs&quot;
name = &quot;default-bytes&quot;
[[test]]
path = &quot;tests/test_nfa.rs&quot;
name = &quot;nfa&quot;</code></pre><p>在代码清单10-25中列举了三组[[test]]表配置，这只是regex根包中Cargo.toml配置的一部分。这三组[[test]]表表示一个数组，等价的<strong>JSON</strong>格式如代码清单10-26所示。 </p>
<p>代码清单<strong>10-26</strong>：<strong>[[test]]</strong>表数组等价的<strong>JSON</strong>格式</p>
<pre><code>{
    &quot;test&quot;: [
        { &quot;path&quot;: &quot;...&quot;, &quot;name&quot;: &quot;...&quot;},
        { &quot;path&quot;: &quot;...&quot;, &quot;name&quot;: &quot;...&quot;},
        { &quot;path&quot;: &quot;...&quot;, &quot;name&quot;: &quot;...&quot;},
    ]
}</code></pre><p>可以得出，[[test]]表数组表示的是同一个数组中的三组不同配置。[[test]]表支持的配置项和[lib]表基本相同。 </p>
<p><strong>(8) [profile]表配置</strong></p>
<p>接下来是[profile]表配置，如代码清单10-27所示。 </p>
<p>代码清单<strong>10-27</strong>：<strong>[profile]</strong>表配置 </p>
<pre><code>[profile.release]
debug = true
[profile.bench]
debug = true
[profile.test]
debug = true</code></pre><p><strong>Cargo支持自定义rustc编译配置，使用[profile]表进行配置即可，但只对根包中的profile配置有效</strong>。 </p>
<p>在代码清单 10-27 中，在[profile]表中使用了点<strong>（.）符号来表示嵌套</strong>，分别是[profile.release]、[profile.bench]和[profile.test]，与其等价的JSON格式如代码清单10-28所示。 </p>
<p>代码清单<strong>10-28</strong>：<strong>[profile]</strong>表配置对应的<strong>JSON</strong>格式 </p>
<pre><code>&quot;profile&quot; {
    “release&quot;: {&quot;debug&quot;: &quot;true&quot;},
    “bench&quot;: {&quot;debug&quot;: &quot;true&quot;},
    “test&quot;: {&quot;debug&quot;: &quot;true&quot;},
}</code></pre><p><strong>这三项表配置分别代表 Release、Bench 和 Test 编译模式。除此之外，Cargo 还支持[profile.dev]代表Debug模式</strong>。在本例中，当前的配置代表在Release、Bench和Test模式下，均包含Debug信息。<strong>除debug配置项之外，还支持用于指定优化级别的opt-level、连接时间优化的lto等</strong>。 </p>
<p>快速浏览了一遍根包的Cargo.toml配置文件，大概了解到这些配置表的作用。接下来看看子包bench中的Cargo.toml文件。 </p>
<p>子包bench的目录结构如代码清单10-29所示。 </p>
<p>代码清单<strong>10-29</strong>：子包<strong>bench</strong>的目录结构</p>
<pre><code>bench
   ├─ log/
   ├─ src/
   ├─ Cargo.toml
   ├─ build.rs
   ├─ compile
   └─ run</code></pre><p><strong>Bench 子包用来和其他语言编写的正则表达式引擎比较性能基准测试，在 log 文件夹里保存的是曾经的测试记录。src目录是Rust包结构的原生目录。Cargo.toml是Cargo的配置文件。build.rs叫作构建脚本（Build Script），它是先于cargo build被编译的脚本，因为有时候需要在编译时依赖第三方非Rust代码，比如C库，这时就需要先编译C库，然后Rust代码才能链接到C库。</strong>关于build.rs，在第12章中还会做更详细的介绍。<strong>compile和run是shell脚本，分别包装了cargo build和cargo bench命令，用于更方便地执行基准测试。</strong> </p>
<p>现在查看子包bench的Cargo.toml文件，如代码清单10-30所示。 </p>
<p>代码清单<strong>10-30</strong>：子包<strong>bench</strong>中的<strong>Cargo.toml</strong>文件部分配置 </p>
<pre><code>[package]
...
build = &quot;build.rs&quot;
[[bin]
name = &quot;regex-run-one&quot;
path = &quot;src/main.rs&quot;
bench = false
[[bench]]
name = &quot;bench&quot;
path = &quot;src/bench.rs&quot;
test = false
bench = true</code></pre><p>代码清单10-30只展示了之前没有见到过的Cargo.toml文件的部分配置，因为大部分配置和根包regex中的Cargo.toml文件一致。</p>
<p>代码第1～4行，<strong>[package]</strong>表中有两个键值对配置项build和workspace。其中build用于设置构建脚本，这里直接指定 build.rs，因为默认的根路径就是当前包（bench）的根目录，而build.rs正好位于当前包的根目录下。workspace和根包（regex）中Cargo.toml的[workspace]表配置相呼应，这里设置了<strong>两个点“..”，表示workspace是当前包根目录的上一层目录</strong>。 </p>
<p>代码第5～8行的[[bin]]表和第9～13行的[[bench]]表以及上面提到的[lib]表的配置项是相同的。当想在一个作为库的包里同时包含main.rs（可执行程序的入口main函数）时，就需要配置[[bin]]表。这里配置项 name 表示生成的可执行文件的名字；path 表示当前包含入口main函数的文件路径。如果想把该入口文件直接置于src目录下，则文件名必须是main.rs；如果想用其他文件名，则必须将其放到src/bin目录下。这里配置项bench被设置为false，就是希望在生成可执行文件时不会去执行基准测试。同理，可推出[[bench]]表中配置的含义。 </p>
<p>至此，对子包bench中Cargo.toml文件的配置也有了比较全面的了解。关于更多的细节，可以参考crates.io网站上更详细的文档。</p>
<h3 id="10-1-4-自定义Cargo"><a href="#10-1-4-自定义Cargo" class="headerlink" title="10.1.4 自定义Cargo"></a>10.1.4 自定义Cargo</h3><p><strong>Cargo 允许修改本地配置来自定义一些信息，比如命令别名、源地址等。默认的全局配置位于“$HOME/.cargo/config”文件（基于 Linux/类UNIX 系统，如果是 Windows，则为%USERPROFILE%.cargo\config）中</strong>。具体的配置信息如代码清单10-31所示。 </p>
<p>代码清单<strong>10-31</strong>：<strong>$HOME/.cargo/config</strong>配置信息</p>
<pre><code>[registry]
token = &quot;your_crate_io_token&quot;
[source.crate-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
[alias]
b = &quot;build&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rr = &quot;run --release&quot;
ben = &quot;bench&quot;
space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;\&quot;command list\&quot;&quot;]</code></pre><p>代码清单 10-30 展示了 Cargo 配置文件的部分配置信息，可以看出，配置语言同样是TOML。其中<strong>[registry]表代表crates.io的相关配置；token是在crates.io上注册账号以后由网站颁发的，用于开发者在发布包（crate）时通过平台验证</strong>。 </p>
<p><strong>[source.crates-io]表表示Cargo的源是crates.io。registry配置项指定了crates.io的索引文件地址。GitHub是默认配置，如果无法访问GitHub，则可以通过指定其他的源来解决问题</strong>，具体可参考附录A中的方法。</p>
<p>在<strong>[alias]表中可以指定 Cargo 各种命令的别名，以方便使用。甚至还能定义比较复杂的组合命令，如代码第11行所示，当执行cargospace_example命令时，实际上会执行cargo run–release–command list命令</strong>。</p>
<p><strong>(1) Cargo配置文件的层级关系说明</strong> </p>
<p><strong>Cargo配置文件和git差不多，支持层级的概念。也就是说，可以进行全局配置，也可以针对具体的项目（包）进行配置</strong>，如下所示。 </p>
<ul>
<li><strong>所有用户的全局配置：/.cargo/config</strong> </li>
<li><strong>当前用户的全局配置：$HOME/.cargo/config</strong> </li>
<li><strong>根包regex的配置：/regex/.cargo/config</strong> </li>
<li><strong>子包bench的配置：/regex/bench/.cargo/config</strong> </li>
</ul>
<p><strong>Cargo配置会从上到下层层覆盖，上下层的配置并不会相互影响</strong>。假如在子包bench中定义了cargo build的别名为“cargo bu”，那么在bench根目录下执行cargo build、cargo bu、cargo b命令中的任意一个都是可以的。回到根包regex中执行cargo bu命令则不行，但依然可以执行cargo build和cargo b命令。 </p>
<p><strong>(2) 自定义Cargo子命令</strong> </p>
<p><strong>Cargo 允许自定义命令来满足一些特殊的需求。只要在$PATH（环境变量）中能查到以“cargo-”为前缀的二进制文件，比如cargo-something，就可以通过cargo something来调用该命令。比如，在日常开发中专门用于格式化Rust代码的第三方Cargo扩展rustfmt，就是这样来扩展Cargo命令的</strong>。 </p>
<p><strong>可以通过下列命令来安装rustfmt</strong>。 </p>
<ul>
<li>稳定版（Stable）Rust：rustup component add rustfmt </li>
<li>夜版（Nightly）Rust：rustup component add rustfmt–toolchain nightly</li>
</ul>
<p><strong>通过执行cargo–list命令来查看当前可用的全部命令，就可以发现多了一个fmt命令，然后就可直接调用cargo fmt令来格式化Rust文件</strong>。比如在前面创建的static_hashmap包的根目录下执行cargo fmt命令，则会对 src/main.rs重新格式化，同时还会生成src/main.rs.bk文件作为备份。<strong>一般在团队开发中多使用此Cargo扩展，不管每个团队成员的编码风格是否一致，只需要在提交代码前执行一遍cargo fmt命令，就可以统一整个团队的编码风格。如果有些地方不想被rustfmt处理，那么只需要在该处上方添加＃[rustfmt_skip]属性即可。</strong> </p>
<p>打开rustfmt源码中的Cargo.toml文件，会看到如代码清单10-32所示的配置。</p>
<p>代码清单<strong>10-32</strong>：<strong>rustfmt</strong>源码中<strong>Cargo.toml</strong>文件的部分配置</p>
<pre><code>[[bin]]
name = &quot;rustfmt&quot;
[[bin]]
name = &quot;cargo-fmt&quot;
[[bin]]
name = &quot;rustfmt-format-diff&quot;
[[bin]]
name = &quot;git-rustfmt&quot;</code></pre><p>从代码清单10-32中可以看出，[[bin]]表数组一共配置了四个可执行文件的名字，其中包括了cargo-fmt，用户通过cargo install命令安装rustfmt之后就自动拥有了cargo fmt命令。与这四个可执行文件相对应，在 rustfmt 源码中的 src/bin 目录下有四个 Rust 文件，分别是rustfmt.rs、cargo-fmt.rs、rustfmt-format-diff.rs 和 git-rustfmt.rs，因此在[[bin]]表数组下没有使用path来设置文件路径。 </p>
<p><strong>除了可以直接使用rustfmt默认的代码风格，还可以通过在包的根目录下添加rustfmt.toml文件来自定义代码风格</strong>，代码清单10-33展示了一份自定义的格式化配置供参考。 </p>
<p>代码清单<strong>10-33</strong>：<strong>rustfmt.toml</strong>配置 </p>
<pre><code># 最大宽度
max_width = 90
# fn函数宽度
fn_call_width = 90
# 链式调用一行最大宽度
chain_one_line_max = 80
# 压缩通配符前缀
condense wildcard suffixes = true</code></pre><p>关于更多的配置，可以参考rustfmt的相关文档。</p>
<p>另外，<strong>Cargo 还提供了两个在开发中相当有用的工具：cargo-fix 和 cargo-clippy。其中cargo-fix 提供了 cargo fix 命令，可以为开发者自动修复编译过程中出现的 Warning。cargo-clippy是Rust静态代码分析工具，其提供了cargo clippy命令，帮助开发者检测代码中潜在的错误和坏味道</strong>，并且从Rust 1.29版本开始可用于Rust稳定版中。</p>
<h2 id="10-2-模块系统"><a href="#10-2-模块系统" class="headerlink" title="10.2 模块系统"></a>10.2 模块系统</h2><p><strong>Rust官方团队鼓励开发者在开发包（crate）的时候，尽可能做到最小化。也就是说，每个包都应该尽量只负责单一的完整功能。有些第三方包，代码量比较少，只需要单个文件（比如 src/lib.rs）就能完成整个功能。有些包代码量却很多，可以写在单个文件中来实现整个功能，但是不利于维护。Rust是一门支持模块化的语言，对于代码量比较大的包，可以将其按文件分割为不同的模块，这样可以更合理地组织代码。</strong> </p>
<p><strong>在单个文件中，可以使用mod关键字来声明一个模块</strong>。在static_hashmap包中，就使用mod关键字声明了static_kv模块。<strong>在Rust中单个文件同时也是一个默认的模块，文件名就是模块名。每个包都拥有一个顶级（top-level）模块src/lib.rs或src/main.rs</strong>。 </p>
<p><strong>Rust 2015</strong> 模块 </p>
<p>现在对static_hashmap包按<strong>Rust 2015</strong>的模块系统规则进行重构。先将在src/main.rs中定义的static_kv模块移动到新的文件static_kv.rs中。文件结构如代码清单10-34所示。 </p>
<p>代码清单<strong>10-34</strong>：文件结构 </p>
<pre><code>src/
 |    |-- main.rs
 |    |-- static_kv.rs</code></pre><p>此时需要将main.rs中的mod static_kv{…}整块代码移动到static_kv.rs中，但要注意把mod声明去掉，如代码清单10-35所示。 </p>
<p>代码清单<strong>10-35</strong>：将<strong>static_kv</strong>模块代码移动到<strong>static_kv.rs</strong>文件中</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// src/static_kv.rs</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>collections<span class="token punctuation">:</span><span class="token punctuation">:</span>HashMap<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>sync<span class="token punctuation">:</span><span class="token punctuation">:</span>RwLock<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">const</span> NF<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str <span class="token operator">=</span> <span class="token string">"not found"</span><span class="token punctuation">;</span>
<span class="token macro-rules function">lazy_static!</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> MAP<span class="token punctuation">:</span> HashMap<span class="token operator">&lt;</span>u32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> HashMap<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> MAP_MUT<span class="token punctuation">:</span> RwLock<span class="token operator">&lt;</span>HashMap<span class="token operator">&lt;</span>u32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token operator">>></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> HashMap<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        RwLock<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如代码清单10-35所示的是static_kv.rs文件中的代码，<strong>这里已经去掉了之前的mod声明。这是因为Cargo会默认把static_kv.rs文件当作一个模块static_kv</strong>，如果加上之前的mod声明，那么在 main.rs 中调用该模块中定义的常量或静态变量时，则需要改成static_kv：：static_kv：：MAP或&amp;static_kv：：static_kv：：NF 这样的形式。这就相当于有两层命名空间，使用起来十分不便。 </p>
<p>要想在main.rs中使用新定义的static_kv.rs文件，还需要使用mod关键字引入static_kv模块，如代码清单10-36所示。 </p>
<p>代码清单<strong>10-36</strong>：在<strong>main.rs</strong>中使用<strong>mod</strong>关键字引入<strong>static_kv</strong>模块</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// main.rs</span>
<span class="token attribute attr-name">#[macro_use]</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> lazy_static<span class="token punctuation">;</span>
<span class="token keyword">mod</span> static_kv<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-36中，代码第4行<strong>使用mod关键字引入了static_kv模块，Cargo会自动查找到static_kv.rs文件</strong>。其他代码不变，故这里省略。 </p>
<p>现在main.rs文件中的另外两个函数read_kv和rw_mut_kv，同样可以被放到独立的文件中。在src目录下创建一个新的文件read_func.rs，然后把这两个函数都移动到这个新文件中，如代码清单10-37所示。 </p>
<p>代码清单<strong>10-37</strong>：将<strong>read_kv</strong>和<strong>rw_mut_kv</strong>两个函数从<strong>main.rs</strong>中移动到<strong>read_func.rs</strong>中</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// read_func.rs</span>
<span class="token keyword">use</span> static_kv<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">ref</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP<span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>
        static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
            <span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>?<span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> m <span class="token operator">=</span> static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
            <span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>?<span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-37展示了将read_kv和rw_mut_kv这两个函数移动到read_func.rs中以后能够正常编译的最终修改代码。注意跟之前的代码不同的地方一共有三处。 </p>
<p>因为在这两个函数中均<strong>用到了 static_kv 模块中定义的常量或静态变量，所以需要引入static_kv 模块。但是因为在顶级模块 main.rs 中已经使用 mod 关键字引入过了，所以在read_func.rs中只需要使用use直接打开模块即可</strong>，如代码第2行所示。这是其中一处变化。 </p>
<p>另外两处变化是，在read_kv和rw_mut_kv函数前面都加上了pub关键字，它表示public （公开的）。这是<strong>因为每个模块对外都是封闭的，在模块中定义的一切都是私有的，只有通过添加pub才可修改其可见性，变为对外可公开访问</strong>，如代码第3行和第10行所示。然后，在main.rs中通过mod关键字引入read_func模块，如代码清单10-38所示。 </p>
<p>代码清单<strong>10-38</strong>：在<strong>main.rs</strong>中引入<strong>read_func</strong>模块 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// main.rs</span>
<span class="token attribute attr-name">#[macro_use]</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> lazy_static<span class="token punctuation">;</span>
<span class="token keyword">mod</span> static_kv<span class="token punctuation">;</span>
<span class="token keyword">mod</span> read_func<span class="token punctuation">;</span>
<span class="token keyword">use</span> read_func<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>read_kv<span class="token punctuation">,</span> rw_mut_kv<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-38展示了main.rs文件的最终修改代码。代码第5行，通过mod关键字引入了read_func模块。代码第6行，<strong>使用use关键字来打开read_func模块，引入其中的read_kv和rw_mut_kv 函数，这样就可以直接在main函数中使用这两个函数了（之前的代码不需要修改）；否则，必须在main函数中用到这两个函数的地方加上命名空间</strong>，比如read_func：：read_kv和read_func：：rw_mut_kv。 </p>
<p>这样，通过模块化就将之前单个main.rs文件中的代码重构到了两个独立的文件中，代码结构变得更加清晰。接下来，在static_hashmap的根目录下执行cargo run命令，代码可以正常编译和运行。 </p>
<p>现在 src 目录下一共有三个独立文件：main.rs、read_func.rs 和static_kv.rs。但实际上static_kv.rs和read_func.rs在逻辑层面上并不独立，前者定义了静态变量MAP和MAP_MUT，后者定义了操作它们的读写行为。基于这种考虑，应该<strong>把 static_kv.rs 和 read_func.rs 合并为同一个模块。那么应该如何做呢？把它们归到同一个文件里吗？答案是否定的。其实完全可以把这两个文件放到同一个文件夹下来达成目的</strong>，如代码清单10-39所示。 </p>
<p>代码清单<strong>10-39</strong>：将<strong>static_kv.rs</strong>和<strong>read_func.rs</strong>放到同一个文件夹下</p>
<pre><code>static_hashmap
 |--src    
 |    |-- main.rs
 |    |-- static_func
 |        |-- mod.rs
 |        |-- read_func.rs
 |        |-- static_kv.rs</code></pre><p>在代码清单10-39中，创建了一个新的文件夹static_func，将static_kv.rs和read_func.rs置于其中，然后创建了新的文件mod.rs。此时，<strong>static_func就可以作为一个模块来使用，Cargo会自动查找该文件夹下的 mod.rs 文件作为该模块的根文件</strong>。现在只需要在 mod.rs 中引入static_kv和read_func两个模块即可，如代码清单10-40所示。 </p>
<p>代码清单<strong>10-40</strong>：在<strong>mod.rs</strong>中引入<strong>static_kv</strong>和<strong>read_func</strong>模块 </p>
<pre><code>// src/static_func/mod.rs
pub mod static_kv;
pub mod read_func;</code></pre><p>在代码清单10-40中使用mod关键字引入了static_kv和read_func模块，并通过pub关键字将其设置为对外公开。 </p>
<p>但是现在还无法通过编译，使用cargo build命令编译时会报出如下错误：</p>
<pre><code>error[E0432]: unresolved import `static_kv` --&gt; src/static_func/read_func.rs:1:5
1 | use static_kv;
  |     ^^^^^^^^ no `static_kv` in the root</code></pre><p>在read_func.rs中，use static_kv这行会报错，错误信息表明无法在根（root）目录下找到 static_kv。<strong>Cargo 查找文件是从包的根目录开始的，而不是当前文件的相对目录。想解决这个错误，只需要将use static_kv修改为use super：：static_kv，就可以找到static_kv。在路径上使用super关键字，可以让Cargo以相对路径的方式查找文件，super代表当前文件的上一层目录</strong>。 </p>
<p>还需要修改main.rs，如代码清单10-41所示。代码清单<strong>10-41</strong>：修改<strong>main.rs</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// main.rs</span>
<span class="token attribute attr-name">#[macro_use]</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> lazy_static<span class="token punctuation">;</span>
<span class="token keyword">mod</span> static_func<span class="token punctuation">;</span>
<span class="token keyword">use</span> static_func<span class="token punctuation">:</span><span class="token punctuation">:</span>static_kv<span class="token punctuation">;</span>
<span class="token keyword">use</span> static_func<span class="token punctuation">:</span><span class="token punctuation">:</span>read_func<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>read_kv<span class="token punctuation">,</span> rw_mut_kv<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-41中，代码第4行，使用mod关键字引入了static_func模块。代码第5行和第6行，通过use关键字打开static_func：：static_kv和static_func：：read_func两个模块供main函数使用，main函数之前的代码依然不需要修改。 </p>
<p>最后将Cargo.toml文件中的edtion修改为“2015”。此时使用cargo run命令可以正常编译和运行。可以通过随书源码中的static_hashmap_2015包来查看完整代码。 </p>
<p>经过这一系列重构，我们大概可以了解到，<strong>Rust中的模块可以按照类似于文件系统的方式进行组织，Cargo会根据文件名即模块名的默认约定来查找相关模块。</strong> </p>
<p><strong>Rust 2018</strong>模块 </p>
<p>Rust 2018对模块系统进行了改进，主要包括下面内容： </p>
<ul>
<li><strong>不再需要在根模块中使用extern crate语法导入第三方包</strong>。 </li>
<li><strong>在模块导入路径中使用crate关键字表示当前crate</strong>。 </li>
<li><strong>按照特定的规则，mod.rs可以省略</strong>。 </li>
<li><strong>use语句可以使用嵌套风格来导入模块</strong>。 </li>
</ul>
<p>下面通过再次重构static_hashmap_2015项目来说明Rust 2018中模块系统的变化。首先使用<strong>cargo</strong> </p>
<p><strong>new</strong>命令创建新的项目<strong>static_hashmap_2018</strong>，然后打开Cargo.toml文件添加依赖的第三方包 </p>
<p>lazy_static，注意此时edtion选项默认为“2018”。 </p>
<p>现在重新审视static_hashmap_2015项目中的static_func目录下的read_func和static_kv，发现它们之间还存在一层依赖关系。在 main.rs 中用的是 read_func 中的函数，而 read_func又依赖于static_kv。其实在static_hashmap_2015项目中并没有很好地反映出这一层关系。 </p>
<p>现在使用Rust 2018的新模块系统来修改。在<strong>static_hashmap_2018</strong>项目的src目录下创建read_func.rs文件，同时创建read_func目录，并在此目录下创建static_kv.rs文件。此时src目录结构如代码清单10-42所示。 </p>
<p>代码清单<strong>10-42</strong>：<strong>src</strong>目录结构 </p>
<pre><code> |--src    
 |    |-- main.rs
 |    |-- read_func
 |    |    |-- static_kv.rs
 |    |-- read_func.rs</code></pre><p>代码清单10-42所示的结构明确地反映出read_func和 static_kv的关系。<strong>在Rust 2018中，如果存在与文件同名的目录，则在该目录下定义的模块都是该文件的子模块。也就是说，在当前项目中，read_func.rs和read_func目录是同名的，所以定义在read_func目录下的static_kv模块就是read_func的子模块。</strong>注意，在Rust 2015中则不允许文件与目录同名。 </p>
<p>同时，在read_func.rs文件中需要使用mod关键字引入static_kv模块，如代码清单10-43所示。 </p>
<p>代码清单<strong>10-43</strong>：在<strong>read_func.rs</strong>文件中引入<strong>static_kv</strong>模块 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">mod</span> static_kv<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 同static_hashmap_2015项目内容</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 同static_hashmap_2015项目内容</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单 10-43 中省略了 read_kv 和 rw_mut_kv 函数的代码，其函数体等同于static_hashmap_2015项目中对应内容。需要注意，<strong>代码第1行直接引入了static_kv模块，并未加其余的路径前缀。这说明Rust会通过mod关键字自动到当前read_func模块的子模块中寻找static_kv模块</strong>。接下来修改static_kv.rs文件，如代码清单10-44所示。 </p>
<p>代码清单<strong>10-44</strong>：修改<strong>read_func/static_kv.rs</strong>文件 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> lazy_static<span class="token punctuation">:</span><span class="token punctuation">:</span>lazy_static<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>collections<span class="token punctuation">:</span><span class="token punctuation">:</span>HashMap<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>sync<span class="token punctuation">:</span><span class="token punctuation">:</span>RwLock<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">const</span> NF<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str <span class="token operator">=</span> <span class="token string">"not found"</span><span class="token punctuation">;</span>
<span class="token macro-rules function">lazy_static!</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 同static_hashmap_2015项目内容</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-44中同样省略了lazy_static！宏的具体代码。该文件主要的变化是代码第1行，使用 use 关键字引入了 lazy_static 包中的lazy_static！宏。如果不加这一行，则无法使用lazy_static！宏。因为<strong>在Rust2018中，可以在项目的根模块下也就是main.rs中省略＃[macro_use] extern crate lazy_static，但是在具体使用到lazy_static！宏的模块时就必须使用use引入。</strong> </p>
<p>接下来修改main.rs文件，如代码清单10-45所示。 </p>
<p>代码清单<strong>10-45</strong>：修改<strong>main.rs</strong>文件</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">mod</span> read_func<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>read_func<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>read_kv<span class="token punctuation">,</span> rw_mut_kv<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">read_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> <span class="token function">rw_mut_kv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> m <span class="token operator">=</span> read_func<span class="token punctuation">:</span><span class="token punctuation">:</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>MAP_MUT
                <span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map_err</span><span class="token punctuation">(</span><span class="token operator">|</span>e<span class="token operator">|</span> e<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"baz"</span><span class="token punctuation">,</span>
                <span class="token operator">*</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_func<span class="token punctuation">:</span><span class="token punctuation">:</span>static_kv<span class="token punctuation">:</span><span class="token punctuation">:</span>NF<span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Error {}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-45中，使用mod关键字引入了read_func模块。相比于static_hashmap_2015项目中的 main.rs 文件，代码要清晰很多，可读性更高。另外，代码第 7 行，调用 static_kv模块中的静态变量MAP_MUT需要使用read_func前缀，又一次体现了这种层次关系。 </p>
<p>另外，在代码第2行中，use语句使用了<strong>crate</strong>关键字前缀，代表引入的是当前crate中定义的 read_func 模块。当然，此处也可以使用 <strong>self</strong> 关键字来代替 <strong>crate</strong> 关键字，Rust 会以main.rs为起点寻找当前相对路径下的read_func模块。如果是第三方包，则不需要写crate前缀。这样也可以提高代码的可读性。</p>
<h2 id="10-3-从零开始实现一个完整功能包"><a href="#10-3-从零开始实现一个完整功能包" class="headerlink" title="10.3 从零开始实现一个完整功能包"></a>10.3 从零开始实现一个完整功能包</h2><p>通过对Cargo包管理和模块系统的学习，我们现在完全有能力写一个具有完整功能的包。以2017年C++17编码挑战赛为例，用Rust来实现挑战题。</p>
<p>这道挑战题是这样的：编写一个命令行工具，可以接收一个CSV文件，并且可以指定固定的值来覆盖指定列的所有数据，然后将结果输出到新的CSV文件中。原始CSV文件内容如代码清单10-46所示。 </p>
<p>代码清单<strong>10-46</strong>：原始<strong>CSV</strong>文件内容 </p>
<pre><code>First Name,Last Name,Age,City,Eyes color,Species
John,Doe,32,Tokyo,Blue,Human
Flip,Helm,12,Canberra,Red,Unknown
Terdos,Bendarian,165,Cracow,Blue,Magic tree
Dominik,Elpos,33,Paris,Purple,Orc
Brad,Doe,42,Dublin,Blue,Human
Ewan,Grath,51,New Delhi,Green,Human</code></pre><p>然后执行如下命令： </p>
<pre><code>$ ./your_program input/challenge.csv City Beijing output/output.csv</code></pre><p>your_program为编译后的可执行程序，其接收三个参数，分别是字段名（City）、要替换的城市（Beijing）和输出的文件名（output/output.csv）。执行命令后，输出文件内容如代码清单10-47所示。</p>
<p>代码清单<strong>10-47</strong>：替换后的<strong>CSV</strong>文件内容</p>
<pre><code>First Name,Last Name,Age,City,Eyes color,Species
John,Doe,32,Beijing,Blue,Human
Flip,Helm,12,Beijing,Red,Unknown
Terdos,Bendarian,165,Beijing,Blue,Magic tree
Dominik,Elpos,33,Beijing,Purple,Orc
Brad,Doe,42,Beijing,Blue,Human
Ewan,Grath,51,Beijing,Green,Human</code></pre><p>可以看到，City字段下面的所有值都被替换成了Beijing。挑战题其实很简单，本意是想让参与者完全用C++17的新特性来完成。借用此题，现在用Rust来实现。 </p>
<h3 id="10-3-1-使用Cargo创建新项目"><a href="#10-3-1-使用Cargo创建新项目" class="headerlink" title="10.3.1 使用Cargo创建新项目"></a>10.3.1 使用Cargo创建新项目</h3><p>现在使用Cargo命令来创建新的二进制项目csv_challenge。 </p>
<pre><code>$ cargo new --bin csv_challenge</code></pre><p>此时会生成标准的包目录，主要文件包括src/main.rs和Cargo.toml。进入csv_challenge目录中，在根目录下创建input文件夹，然后在该文件夹下创建一个challenge.csv文件，将原始CSV文件内容复制到其中。再回到csv_challenge根目录下，创建一个空文件夹output，用于存放将来输出的CSV文件。此时包的目录结构如下：</p>
<pre><code>.
└── csv_challenge
    ├── Cargo.toml
    ├── input
    │    ├── challenge.csv
    ├── output/
    └── src
        └── main.rs</code></pre><p>接下来要考虑的是如何从命令行接收参数。基本思路有两种：直接使用std：：env：：args和使用第三方包。前者的方式比较原始，还需要手动解析参数，所以这里使用第三方包。 </p>
<h3 id="10-3-2-使用structopt解析命令行参数"><a href="#10-3-2-使用structopt解析命令行参数" class="headerlink" title="10.3.2 使用structopt解析命令行参数"></a>10.3.2 使用structopt解析命令行参数</h3><p>可选的第三方包有两个：clap和structopt。其中clap的功能非常强大，但是使用起来没有那么直观；而structopt则是在clap基础上构建而成的，简化了操作。所以这里选用structopt包。打开Cargo.toml文件，加入下面依赖：</p>
<pre><code>[dependencies]
structopt = &quot;0.2&quot;
structopt-derive = &quot;0.2&quot;</code></pre><p>然后运行cargo build命令，从crates.io（或指定的国内源）下载并编译安装这两个包。因为structopt是基于过程宏（Procedural Macro）的，所以它需要依赖structopt-derive包。关于过程宏会在第12章中介绍。 </p>
<p>根据structopt的用法，需要一个结构体来封装所需要的参数。为了模块化，在src 根目录下创建新的文件opt.rs。此时csv_challenge包的目录结构如下： </p>
<pre><code>.
└── csv_challenge
    ├── Cargo.toml
    ├── input
    │    ├── challenge.csv
    ├── output/
    └── src
        ├── opt.rs
        └── main.rs</code></pre><p>在opt.rs文件中创建结构体Opt，如代码清单10-48所示。 </p>
<p>代码清单<strong>10-48</strong>：在<strong>src/opt.rs</strong>文件中创建结构体<strong>Opt</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> structopt_derive<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token attribute attr-name">#[derive(StructOpt, Debug)]</span>
#<span class="token punctuation">[</span><span class="token function">structopt</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"csv_challenge"</span><span class="token punctuation">,</span> about <span class="token operator">=</span> <span class="token string">"Usage"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Opt <span class="token punctuation">{</span>
    #<span class="token punctuation">[</span><span class="token function">structopt</span><span class="token punctuation">(</span>help <span class="token operator">=</span> <span class="token string">"Input file"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">pub</span> input<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
    #<span class="token punctuation">[</span><span class="token function">structopt</span><span class="token punctuation">(</span>help <span class="token operator">=</span> <span class="token string">"Column Name"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">pub</span> column_name<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
    #<span class="token punctuation">[</span><span class="token function">structopt</span><span class="token punctuation">(</span>help <span class="token operator">=</span> <span class="token string">"Replacement Column Name"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">pub</span> replacement<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
    #<span class="token punctuation">[</span><span class="token function">structopt</span><span class="token punctuation">(</span>help <span class="token operator">=</span> <span class="token string">"Output file, stdout if not present"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">pub</span> output<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-48中定义的结构体<strong>Opt</strong>专门用于构建如下命令： </p>
<pre><code>USAGE:
    csv_challenge [FLAGS] &lt;input&gt; &lt;column_name&gt; &lt;replacement&gt; [output]</code></pre><p>说明如下： </p>
<ul>
<li><strong>csv_challenge</strong>，为编译后的可执行文件。 </li>
<li><strong>[FLAGS]</strong>，为Flag参数，一般是侧重于表示“开”和“关”的标记。 </li>
<li><strong>＜input＞</strong>，表示输入文件，也就是原始CSV文件路径。它对应于代码第6行的字段input，并通过＃[structopt…]属性设置help说明文字。 </li>
<li><strong>＜column_name＞</strong>，表示指定要替换的CSV文件头部字段。它对应于代码第8行的字段column_name。 </li>
<li><strong>＜replacement＞</strong>，表示要替换的新值。它对应于代码第10行的字段replacement。 </li>
<li><strong>[output]</strong>，表示输出的文件路径。它对应于代码第 12 行的字段output，注意它为Option＜String＞类型，因为该参数可以省略，由默认的输出文件路径代替。 </li>
</ul>
<p>因为结构体和字段都需要在opt模块外使用，所以在代码清单10-48中使用pub关键字将它们的可见性都修改为公开。接下来修改src/main.rs文件，如代码清单10-49所示。 </p>
<p>代码清单<strong>10-49</strong>：修改<strong>src/main.rs</strong>文件 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> structopt<span class="token punctuation">:</span><span class="token punctuation">:</span>StructOpt<span class="token punctuation">;</span>
<span class="token keyword">mod</span> opt<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">self</span><span class="token punctuation">:</span><span class="token punctuation">:</span>opt<span class="token punctuation">:</span><span class="token punctuation">:</span>Opt<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> opt <span class="token operator">=</span> Opt<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?"</span><span class="token punctuation">,</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单 10-49 中，因为使用的是 Rust 2018，所以可以省略使用extern crate 和＃[macro_use]声明引入structopt和structopt_derive。现在可以直接使用use关键字引入StructOpt供本地使用。 </p>
<p>代码第2行和第3行，使用mod和use关键字来引入Opt供本地使用。在main函数中，使用structopt包提供的Opt：：from_args方法就可以接收来自命令行的参数。使用cargo run命令编译并运行，会看到如下提示：</p>
<pre><code>bill@ars:~/go/src/rust/rust1/csv_challenge$ cargo run
   Compiling csv_challenge v0.1.0 (/home/bill/go/src/rust/rust1/csv_challenge)
    Finished dev [unoptimized + debuginfo] target(s) in 0.92s
     Running `target/debug/csv_challenge`
error: The following required arguments were not provided:
    &lt;input&gt;
    &lt;column_name&gt;
    &lt;replacement&gt;

USAGE:
    csv_challenge &lt;input&gt; &lt;column_name&gt; &lt;replacement&gt; [output]

For more information try --help</code></pre><p>此时structopt包提供的方法会自动检查命令行有没有输入需要的参数，如果没有则给出提示，并自动提供–help参数。当执行<strong>cargo run – help</strong>命令后，会有如下输出：</p>
<p><img src="/2021/03/19/the-tao-of-rust-programming-10/image-20210517171841696.png" alt="image-20210517171841696"></p>
<p>structopt会根据Opt结构体中的定义，生成这样一份命令帮助清单，csv_challenge包的用法一目了然。在开始处理接收的参数之前，应该考虑定义统一的错误类型。 </p>
<h3 id="10-3-3-定义统一的错误类型"><a href="#10-3-3-定义统一的错误类型" class="headerlink" title="10.3.3 定义统一的错误类型"></a>10.3.3 定义统一的错误类型</h3><p>同样使用单独的模块来定义错误类型。在src目录下创建新的文件src/err.rs，并在其中写入如代码清单10-50所示的内容。 </p>
<p>代码清单<strong>10-50</strong>：<strong>src/err.rs</strong>文件内容</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">pub</span> <span class="token keyword">enum</span> Error <span class="token punctuation">{</span>
    <span class="token function">Io</span><span class="token punctuation">(</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Program</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> From<span class="token operator">&lt;</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token operator">></span> <span class="token keyword">for</span> Error <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">from</span><span class="token punctuation">(</span>e<span class="token punctuation">:</span> io<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token punctuation">)</span> <span class="token punctuation">-></span> Error <span class="token punctuation">{</span>
        Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Io</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> From<span class="token operator">&lt;</span><span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token operator">></span> <span class="token keyword">for</span> Error <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">from</span><span class="token punctuation">(</span>e<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">)</span> <span class="token punctuation">-></span> Error <span class="token punctuation">{</span>
        Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Program</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单 10-50 中定义了枚举类型 Error，其中包含两个值，即Io（io：：Error）和Program（&amp;＇static str），分别代表 I/O 错误和包自身的逻辑错误。同时实现了 From，使得 I/O错误和字符串类型错误可以方便地转换为Error。然后在src/main.rs中将此模块引入即可。 </p>
<p>此时csv_challenge包的目录结构如下： </p>
<pre><code>.
└── csv_challenge
    ├── Cargo.toml
    ├── input
    │    ├── challenge.csv
    ├── output/
    └── src
        ├── err.rs
        ├── opt.rs
        └── main.rs</code></pre><p>接下来就可以通过从命令行接收的参数来读取CSV文件了。</p>
<h3 id="10-3-4-读取CSV文件"><a href="#10-3-4-读取CSV文件" class="headerlink" title="10.3.4 读取CSV文件"></a>10.3.4 读取CSV文件</h3><p>在src目录下创建新的文件core.rs和文件夹core，所有操作CSV文件的代码都放在这里。处理CSV文件需要两步，先读取，再按指定的字段和值来替换旧值。把这两步分成两个独立的文件，即core/read.rs和core/write.rs。此时csv_challenge包的目录结构如下： </p>
<pre><code>.
└── csv_challenge
    ├── Cargo.toml
    ├── input
    │    ├── challenge.csv
    ├── output/
    └── src
        ├── core
        │    ├── read.rs
        │    ├── write.rs
        ├── core.rs
        ├── err.rs
        ├── opt.rs
        └── main.rs</code></pre><p>接下来修改core.rs文件，如代码清单10-51所示。 </p>
<p>代码清单<strong>10-51</strong>：修改<strong>core.rs</strong> 文件 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">mod</span> read<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">mod</span> write<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>err<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意要使用 pub 将模块的可见性修改为公开的，因为在 main 函数中要使用模块中的函数。另外，在read模块中要用到Error，所以必须从core.rs中引入才可以。 </p>
<p>接下来在core/read.rs中添加读取文件的方法，如代码清单10-52所示。</p>
<p>代码清单<strong>10-52</strong>：在<strong>core/read.rs</strong>中添加读取文件的方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>fs<span class="token punctuation">:</span><span class="token punctuation">:</span>File<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span>prelude<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">load_csv</span><span class="token punctuation">(</span>csv_file<span class="token punctuation">:</span> PathBuf<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Error<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> file <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>csv_file<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">write_csv</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> filename<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span>　Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Error<span class="token operator">></span>
<span class="token punctuation">{</span>
    <span class="token function">write</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">read</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> PathBuf<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Error<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> file <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    file<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token keyword">if</span> buffer<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token string">"input file missing"</span><span class="token punctuation">)</span>?
    <span class="token punctuation">}</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">:</span> PathBuf<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Error<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> file <span class="token operator">=</span> File<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> filename<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Error<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> File<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">create</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    buffer<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-52中，代码第1～4行，使用use引入了需要使用的几个标准库的类型，包括std：：path：：PathBuf、std：：fs：：File和std：：io：：prelude：：<em>。这里需要注意的是，**Rust会为每个包自动插入extern crate std，为每个模块自动插入use std：：prelude：：v1：： \</em>，所以在任何一个模块中都可以直接使用use来引入包含在std：：prelude：：v1：：*中的模块<strong>。代码第3行使用了</strong>super**关键字，是为了使用在当前模块的父模块core中引入的Error。 </p>
<p><strong>Rust将文件路径抽象为两种类型：Path和PathBuf，这两种类型的关系有点类似于&amp;str和String的关系。Path没有所有权，而PathBuf有独立的所有权</strong>。通过对路径进行抽象，可以让开发者无视底层操作系统的差异，统一处理文件路径。 </p>
<p><strong>在模块std：：fs中定义了操作本地文件系统的基本方法，并且所有方法都可以跨平台，开发者同样可以无视操作系统的差异而统一使用其中的方法</strong>。这里只用到了File结构体，使用其提供的open和create方法来打开和创建CSV文件。在离开作用域的时候，文件会自动被关闭。 </p>
<p><strong>在模块std：：io中定义了核心I/O功能的trait、类型和一些基本方法。包括Read、Write、Seek、BufRead这四个trait，是对I/O操作的抽象。通过std：：io：：prelude：：*可以引入一些I/O操作中最常见的模块。</strong></p>
<p>代码第5～13行定义了两个pub函数：load_csv和write_csv，分别用于读取和写入CSV文件。在这两个函数中又调用了封装好的独立函数read、open和write，像这样一个函数只做一件事，是一种最佳实践。 </p>
<p>接下来就可以在main.rs中使用这两个函数来操作CSV文件了，如代码清单10-53所示。 </p>
<p>代码清单<strong>10-53</strong>：在<strong>main.rs</strong>中使用<strong>load_csv</strong>和<strong>write_csv</strong>函数来操作<strong>CSV</strong>文件</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> structopt<span class="token punctuation">:</span><span class="token punctuation">:</span>StructOpt<span class="token punctuation">;</span>
<span class="token keyword">mod</span> opt<span class="token punctuation">;</span>
<span class="token keyword">use</span> opt<span class="token punctuation">:</span><span class="token punctuation">:</span>Opt<span class="token punctuation">;</span>
<span class="token keyword">mod</span> err<span class="token punctuation">;</span>
<span class="token keyword">mod</span> core<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">self</span><span class="token punctuation">:</span><span class="token punctuation">:</span>cor<span class="token punctuation">:</span><span class="token punctuation">:</span>read<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>process<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> opt <span class="token operator">=</span> Opt<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> filename <span class="token operator">=</span> PathBuf<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span>opt<span class="token punctuation">.</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> csv_data <span class="token operator">=</span> <span class="token keyword">match</span> <span class="token function">load_csv</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Ok</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> fname <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"main error: {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            process<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> output_file <span class="token operator">=</span> <span class="token operator">&amp;</span>out<span class="token punctuation">.</span>output
        <span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token string">"output/output.csv"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> <span class="token function">write_csv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>csv_data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>output_file<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"write success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"main error: {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            process<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-53中，引入了所有新添加的模块。 </p>
<p>代码第11行，使用PathBuf：：from方法将存储于opt.input字段中的输入CSV文件路径字符串转换为PathBuf类型。代码第12～18行，将得到的CSV文件路径filename传入load_csv函数中。这里使用match来处理load_csv返回的Result类型。 </p>
<p>代码第19行和第20行，声明了output变量绑定，代表输出CSV文件路径。因为opt.output是可以忽略的参数，所以这里使用unwrap_or方法定义了默认的输出路径。 </p>
<p>代码第21～29行，将读取到的原始CSV文件内容csv_data和输出路径output_file传入write_csv方法中来输出CSV文件。这里也需要使用match来处理Result，否则编译会发出警告。 </p>
<p>执行<strong>cargo run input/challenge.csv City Beijing</strong>命令，会看到生成output/output.csv文件，其内容和input/challenge.csv一致。 </p>
<p>但是挑战赛要求必须把指定字段（City）下的所有值都替换为新值（Beijing）。于是，接下来在core/write.rs中添加用于替换的函数。</p>
<h3 id="10-3-5-替换CSV文件中的内容"><a href="#10-3-5-替换CSV文件中的内容" class="headerlink" title="10.3.5 替换CSV文件中的内容"></a>10.3.5 替换CSV文件中的内容</h3><p>替换的基本思路是：使用lines方法将读取到的原始CSV字符串转换为迭代器，这样就可以按行处理这些内容了。第一行内容就是 CSV 文件的头部，将其用逗号分隔存储为Vec＜&amp;str＞数组。通过和指定的字段对比，就可以得到要替换字段的索引位置。然后将其他行的字符串存储到新的字符串中，继续通过lines方法转换为迭代器，结合前面得到的索引位置逐行替换相应位置的值。 </p>
<p>考虑到处理替换同样需要PathBuf、File和Error这三种类型的支持，为了避免代码重复，现在将引入这三种类型的代码移动到core.rs文件中，如代码清单10-54所示。 </p>
<p>代码清单<strong>10-54</strong>：修改<strong>core.rs</strong>和<strong>core/read.rs</strong>文件</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// core.rs</span>
<span class="token keyword">pub</span> <span class="token keyword">mod</span> read<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">mod</span> write<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>err<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">,</span>
    fs<span class="token punctuation">:</span><span class="token punctuation">:</span>File<span class="token punctuation">,</span>
    io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Read<span class="token punctuation">,</span> Write<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// core/read.rs</span>
<span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Error<span class="token punctuation">,</span> PathBuf<span class="token punctuation">,</span> File<span class="token punctuation">,</span> Read<span class="token punctuation">,</span> Write<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-54中，将在core/read.rs中引入的std模块都移出来，此处使用了Rust 2018新模块系统支持的use语句内嵌语法。在修改core.rs的同时，也需要修改core/read.rs，通过super前缀从父模块中引入要使用的类型。</p>
<p>接下来修改core/write.rs文件，如代码清单10-55所示。 </p>
<p>代码清单<strong>10-55</strong>：修改<strong>core/write.rs</strong>文件</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">replace_column</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> String<span class="token punctuation">,</span> column<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> replacement<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span>
<span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Error<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> lines <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> headers <span class="token operator">=</span> lines<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> columns<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span><span class="token operator">&amp;</span>str<span class="token operator">></span> <span class="token operator">=</span> headers<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> column_number <span class="token operator">=</span> columns<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>e<span class="token operator">|</span> e <span class="token operator">==</span> column<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> column_number <span class="token operator">=</span> <span class="token keyword">match</span> column_number <span class="token punctuation">{</span>
        <span class="token function">Some</span><span class="token punctuation">(</span>column<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> column<span class="token punctuation">,</span>
        None <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token string">"column name doesn't exist in the input file"</span><span class="token punctuation">)</span>?
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> result <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">with_capacity</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>column<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> records<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span><span class="token operator">&amp;</span>str<span class="token operator">></span> <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        records<span class="token punctuation">[</span>column_number<span class="token punctuation">]</span> <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>records<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-55中，代码第1行，同样<strong>使用了use spuer：：*来引入父模块core中的类型</strong>。 </p>
<p>代码第2行定义的pub函数replace_column接收三个参数：读取到的原始CSV字符串data、指定的字段column和要匹配的新值replacement。 </p>
<p>代码第4～11行，通过lines方法将data 转换为迭代器，通过调用一次next方法，得到CSV 文件的头部 headers。然后通过 split 方法用逗号分隔将 headers 转换为 Vec＜&amp;str＞数组columns，就可以通过position方法获取到指定字段的索引位置column_number。使用match匹配position方法的查找结果，因为有可能输入的字段是不存在的。 </p>
<p>代码第12～20行，创建了一个可变的新字符串result，将头部数组columns使用join方法转换为用逗号分隔的字符串，加上换行符。然后将剩余的 lines 按行迭代，每一行先转换为Vec＜&amp;str＞可变数组records，再通过column_number将指定位置的值替换为新值replacement。最后将替换好的records通过join方法转换为用逗号分隔的字符串，加上换行符。</p>
<p>代码第21行，返回最终结果。 </p>
<p>现在就可以在main函数中使用replace_column方法了，如代码清单10-56所示。 </p>
<p>代码清单<strong>10-56</strong>：在<strong>main.</strong>函数中使用<strong>replace_column</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// ......</span>
<span class="token keyword">use</span> <span class="token keyword">self</span><span class="token punctuation">:</span><span class="token punctuation">:</span>core<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
    read<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">,</span>
    write<span class="token punctuation">:</span><span class="token punctuation">:</span>replace_column<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ......</span>
    <span class="token keyword">let</span> modified_data <span class="token operator">=</span> <span class="token keyword">match</span>
    <span class="token function">replace_column</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">,</span> <span class="token operator">*</span>opt<span class="token punctuation">.</span>column_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opt<span class="token punctuation">.</span>replacement<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">Ok</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"main error: {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            process<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ......</span>
    <span class="token keyword">match</span> <span class="token function">write_csv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>modified_data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>output_file<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-56展示了main.rs中需要修改的部分。代码第2～5行，使用use引入core模块中的子模块read和write。 </p>
<p>代码第8～16行，使用replace_column方法替换原始CSV内容并生成新的修改过的内容modified_data。 </p>
<p>代码第18行，将修改过的内容modified_data写入output_file中。执行<strong>cargo run input/challenge.csv City Beijing</strong>命令，会看到在生成的output/output.csv文件中City字段下的所有值均被修改成Beijing。大功告成！</p>
<h3 id="10-3-6-进一步完善包"><a href="#10-3-6-进一步完善包" class="headerlink" title="10.3.6 进一步完善包"></a>10.3.6 进一步完善包</h3><p>虽然代码功能基本可用，但如果公开给别人使用的话，则还缺少一些必要的测试和文档。接下来就为csv_challenge包增加一些测试和文档。<strong>Rust支持四种测试：单元测试、文档测试、集成测试和基准测试。其中基准测试专门用于性能测试。</strong> </p>
<p><strong>(1) 增加单元测试</strong> </p>
<p><strong>Rust允许在文件中使用mod test为相关功能提供单元测试</strong>。现在为load_csv函数增加单元测试，如代码清单10-57所示。 </p>
<p>代码清单<strong>10-57</strong>：为<strong>load_csv</strong>函数增加单元测试 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> test <span class="token punctuation">{</span>
    <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">:</span><span class="token punctuation">:</span>load_csv<span class="token punctuation">;</span>
    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function">test_valid_load_csv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> filename <span class="token operator">=</span> PathBuf<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"./input/challenge.csv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> csv_data <span class="token operator">=</span> <span class="token function">load_csv</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">.</span><span class="token function">is_ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-57中，代码第1行的<strong>＃[cfg（test）]表示只有在执行cargo test时才编译下面的模块</strong>。 </p>
<p>代码第2行定义了test模块，其中通过use引入了PathBuf和load_csv，否则PathBuf和load_csv函数无法在test模块中使用。 </p>
<p>代码第 5 行的<strong>＃[test]属性表示其标识的函数为测试函数，否则为普通的函数。如果想忽略此测试函数，只需要在＃[test]属性下面再添加＃[ignore]属性即可</strong>。代码第6行定义了测试函数。注意，对测试函数名称并没有特殊的规定。</p>
<p>执行cargo test会看到正常的测试输出。限于篇幅，这里只为load_csv增加测试函数，同理，还可以为 write_csv 和 replace_column 方法增加单元测试。可以在随书源码中查看csv_challenge包的完整源码及测试代码。 </p>
<p><strong>(2) 增加集成测试</strong> </p>
<p><strong>有时候只有单元测试还不够，还需要增加集成测试来测试包的整体功能。但是Rust对于二进制包是不能增加集成测试的，因为二进制包只能独立使用，并不能对外提供可调用的函数。</strong>当前csv_challenge包是二进制包，需要将其改造一下。 </p>
<p>为了支持集成测试，只需要新增src/lib.rs文件，将所有的模块都引入其中，并暴露对外可以调用的函数，然后在main.rs中调用这些函数即可，如代码清单10-58所示。 </p>
<p>代码清单<strong>10-58</strong>：新增<strong>src/lib.rs</strong>文件 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">mod</span> opt<span class="token punctuation">;</span>
<span class="token keyword">mod</span> err<span class="token punctuation">;</span>
<span class="token keyword">mod</span> core<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 重新导出</span>
<span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token keyword">self</span><span class="token punctuation">:</span><span class="token punctuation">:</span>opt<span class="token punctuation">:</span><span class="token punctuation">:</span>Opt<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">use</span> <span class="token keyword">self</span><span class="token punctuation">:</span><span class="token punctuation">:</span>core<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
    read<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">,</span>
    write<span class="token punctuation">:</span><span class="token punctuation">:</span>replace_column<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-58中，分别引入了opt、err和core模块。 </p>
<p>代码第5～9行，使用了叫作重新导出（Re-exporting）的功能，这是为了简化外部调用的导出路径，而且也不需要对外暴露模块。 </p>
<p>然后修改mian.rs文件，如代码清单10-59所示。 </p>
<p>代码清单<strong>10-59</strong>：修改<strong>main.rs</strong>文件</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// ......</span>
<span class="token keyword">use</span> structopt<span class="token punctuation">:</span><span class="token punctuation">:</span>StructOpt<span class="token punctuation">;</span>
<span class="token keyword">use</span> csv_challenge<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
    Opt<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">,</span>
    replace_column<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>process<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ......</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 10-59 展示了 main.rs 文件中需要修改的部分。代码第 3 行，通过引入库包csv_challenge来使用其中暴露的函数。 </p>
<p>值得注意的是，这种main.rs配合lib.rs的形式，是二进制包的最佳实践。</p>
<p>如果使用cargo build命令编译正常，就可以增加集成测试了。在csv_challenge包的根目录下创建tests文件夹，在其中创建integration_test.rs文件。同时，在input目录下创建一个非法的CSV文件no_header.csv，将去掉头部的CSV内容复制到其中，用于测试异常情况。</p>
<p>此时csv_challenge包的目录结构如下：</p>
<pre><code>.
└── csv_challenge
    ├── Cargo.toml
    ├── input
    │    ├── challenge.csv
    │    ├── no_header.csv
    ├── output/
    └── src
    │    ├── core.rs
    │    │    ├── read.rs
    │    │    ├── write.rs
    │    ├── err.rs
    │    ├── opt.rs
    │    ├── lib.rs
    │   └── main.rs
    └── tests
        ├── integration_test.rs</code></pre><p>接下来在integration_test.rs中增加集成测试，如代码清单10-60所示。</p>
<p>代码清单<strong>10-60</strong>：<strong>integration_test.rs</strong>中增加集成测试</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> test <span class="token punctuation">{</span>
    <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
    <span class="token keyword">use</span> csv_challenge<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        Opt<span class="token punctuation">,</span>
        <span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">,</span>
        replace_column<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function">test_csv_challenge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> filename <span class="token operator">=</span> PathBuf<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"./input/challenge.csv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> csv_data <span class="token operator">=</span> <span class="token function">load_csv</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">.</span><span class="token function">is_ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> modified_data <span class="token operator">=</span> <span class="token function">replace_column</span><span class="token punctuation">(</span>
            csv_data<span class="token punctuation">,</span> <span class="token string">"City"</span><span class="token punctuation">,</span> <span class="token string">"Beijing"</span>
        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span>modified_data<span class="token punctuation">.</span><span class="token function">is_ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> output_file <span class="token operator">=</span> <span class="token function">write_csv</span><span class="token punctuation">(</span>
            <span class="token operator">&amp;</span>modified_data<span class="token punctuation">,</span> <span class="token string">"output/test.csv"</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span>output_file<span class="token punctuation">.</span><span class="token function">is_ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在技术上，写集成测试和写单元测试相差无几，主要目的是为了全局性测试所有模块是否可以正常协调工作。直接执行cargo test命令就可以运行集成测试，因为Cargo可以自动识别tests目录</strong>。</p>
<p><strong>(3) 增加文档和文档测试</strong> </p>
<p><strong>Rust支持通过注释来生成文档，以及在文档中进行测试</strong>，如代码清单10-61所示。 </p>
<p>代码清单<strong>10-61</strong>：为<strong>core/read.rs</strong>中的<strong>write_csv</strong>函数增加文档</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">/// # Usage:</span>
<span class="token comment" spellcheck="true">/// ```ignore</span>
<span class="token comment" spellcheck="true">/// let filename = PathBuf::from("./files/challenge.csv");</span>
<span class="token comment" spellcheck="true">/// let csv_data = load_csv(filename).unwrap();</span>
<span class="token comment" spellcheck="true">/// let modified_data = replace_column(</span>
<span class="token comment" spellcheck="true">///        csv_data, "City", "Beijing").unwrap();</span>
<span class="token comment" spellcheck="true">/// let output_file = write_csv(&amp;modified_data, "output/test.csv");</span>
<span class="token comment" spellcheck="true">/// assert!(output_file.is_ok());</span>
<span class="token comment" spellcheck="true">/// ```</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">write_csv</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> filename<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span>
<span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Error<span class="token operator">></span>
<span class="token punctuation">{</span>
    <span class="token function">write</span><span class="token punctuation">(</span>csv_data<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>?<span class="token punctuation">;</span>
    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-61展示了为函数write_csv增加文档。<strong>普通的注释使用两个斜杠（//），而文档注释使用三个斜杠（///）。在文档注释中支持Markdown 语法，但是如果要增加代码块，则需要指定语言，如果没有指定语言，则默认会将其识别为Rust代码，并且会执行文档测试</strong>。“///”会为其注释下方的语法元素生成文档。 </p>
<p>比如代码第2行，如果将<strong>ignore</strong>去掉，则在执行cargo test命令时注释中的代码会被当成 Rust 代码执行；如果去掉”```” 语法，则生成代码时无法高亮显示。因为在前面已经为write_csv 增加了单元测试，这里就没必要再进行测试了，所以使用 “```ignore”可以在编译时忽略这段代码的文档测试属性，只用来生成文档。 </p>
<p>也可以使用<strong>“//！”</strong>在包的根模块或任意模块文件顶部增加模块级文档，如代码清单10-62所示。所谓模块级文档，是指为整个模块而不是单独为其下方的语法元素生成文档。 </p>
<p>代码清单<strong>10-62</strong>：在<strong>src/lib.rs</strong>中增加模块级文档</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">//! This is documentation for the `csv_challenge` lib crate</span>
<span class="token comment" spellcheck="true">//! </span>
<span class="token comment" spellcheck="true">//! Usage:</span>
<span class="token comment" spellcheck="true">//! ```</span>
<span class="token comment" spellcheck="true">//!        use csv_challenge:: {</span>
<span class="token comment" spellcheck="true">//!            Opt,</span>
<span class="token comment" spellcheck="true">//!            {load_csv, write_csv},</span>
<span class="token comment" spellcheck="true">//!            replace_column,</span>
<span class="token comment" spellcheck="true">//!        }</span>
<span class="token comment" spellcheck="true">//!    ```</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-62中，在src/lib.rs模块文件顶部使用<strong>“//！”</strong>增加了模块级文档，所以在执行<strong>cargo test</strong>命令时文档注释中的代码不会被作为文档测试执行。 </p>
<p>现在执行<strong>cargo doc</strong>命令，则会在target/doc下根据文档注释生成相关的文档，<strong>UI</strong>界面和标准库文档是一样的。 </p>
<p><strong>(4) 增加性能基准测试</strong> </p>
<p><strong>Rust也支持性能基准测试，在csv_challenge包的根目录下创建benches目录，该目录是基准测试的默认目录，Cargo可以自动识别</strong>。创建benches/file_op_bench.rs文件，在其中写入如代码清单10-63所示的内容。 </p>
<p>代码清单<strong>10-63</strong>：<strong>benches/file_op_bench.rs</strong>文件内容</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(test)]</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> test<span class="token punctuation">;</span>
<span class="token keyword">use</span> test<span class="token punctuation">:</span><span class="token punctuation">:</span>Bencher<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>path<span class="token punctuation">:</span><span class="token punctuation">:</span>PathBuf<span class="token punctuation">;</span>
<span class="token keyword">use</span> csv_challenge<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
    Opt<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>load_csv<span class="token punctuation">,</span> write_csv<span class="token punctuation">}</span><span class="token punctuation">,</span>
    replace_column<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token attribute attr-name">#[bench]</span>
<span class="token keyword">fn</span> <span class="token function">bench_read_100times</span><span class="token punctuation">(</span>b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Bencher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> n <span class="token operator">=</span> test<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">black_box</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token punctuation">|</span>_<span class="token punctuation">,</span> _<span class="token punctuation">|</span></span><span class="token punctuation">{</span><span class="token function">test_load_csv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">test_load_csv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> filename <span class="token operator">=</span> PathBuf<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"./input/challenge.csv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">load_csv</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要使用基准测试，必须启用<strong>＃[features（test）]</strong>。注意，只有在Rust夜版下才可使用features功能。需要使用extern crate导入test包，此处不能省略。test：：Bencher提供了iter方法，它接收闭包作为参数。如果要写性能测试代码，那么只要将其放到该闭包中即可。 </p>
<p>代码第11～16行，创建bench_read_100times函数，使用<strong>＃[bench]</strong>属性对其标注，表示这是一个基准测试函数。在 iter 方法的闭包参数中，使用 test：：black_box（100）来确保调用test_load_csv函数100次不受编译器优化的影响，可以较为准确地测出load_csv函数的性能。然后用fold方法调用test_load_csv函数100次，如代码第14行所示。 </p>
<p>使用<strong>cargo bench</strong>命令执行基准测试，可以看到类似于下面这条内容的输出：发布到<strong>crates.io</strong>现在可以把具有完整功能的包发布到<strong>crates.io</strong>平台。首先需要注册crates.io网站的账号，登录之后在个人主页里生成一个Api Token，将此Token配置到<strong>.cargo/config</strong>的<strong>[registry]</strong>表下面，然后使用cargo login登录。注意，为了个人安全，不要对外公开此Token。 </p>
<p>接下来就可以直接在包的根目录下使用<strong>cargo publish</strong>命令，该命令会自动将其编译打包上传到crates.io平台。也可以单独使用<strong>cargo package</strong>命令先将其打包，然后再发布。打包以后的文件可以在target/package目录下找到。 </p>
<p>如果执行cargo publish命令报出如下错误： </p>
<pre><code>error: api errors: missing or empty metadata fields: description, license.
Please see http://doc.crates.io/mainfest.html#package-metadata for how to upload metadata</code></pre><p>则说明该包 Cargo.toml 文件的<strong>[package]</strong>表中还缺失必要的元信息，比如 description、license等。可以到错误信息提示的网址中查找更详细的内容。这些必要信息添加以后，就可以正常发布了。这样，其他开发者就可以通过<strong>cargo install</strong>命令来安装并使用此包了。</p>
<h2 id="10-4-可见性和私有性"><a href="#10-4-可见性和私有性" class="headerlink" title="10.4 可见性和私有性"></a>10.4 可见性和私有性</h2><p><strong>在Rust中代码以包、模块、结构体和Enum等复合类型、函数等分成不同层次结构的项（Item）。这些项默认是私有的，但是可以通过pub关键字来改变它们的可见性</strong>。通过这样的设定，开发者可以在创建对外公共接口的同时隐藏内部的实现细节。 </p>
<p>代码清单10-64展示了Rust 2015模块的可见性。 </p>
<p>代码清单<strong>10-64</strong>：<strong>Rust 2015</strong>模块可见性展示</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">mod</span> outer_mod <span class="token punctuation">{</span>
    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">outer_mod_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">mod</span> inner_mod <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 对外层模块`outer_mod`可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">in</span> outer_mod<span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">outer_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 对整个crate可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">crate_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 在`outer_mod` 内部可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">super_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 访问同一个模块的函数</span>
            <span class="token function">inner_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 访问父模块的函数需要使用"::"前缀</span>
            <span class="token punctuation">:</span><span class="token punctuation">:</span>outer_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">outer_mod_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 仅在`inner_mod`内部可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">inner_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inner_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">outer_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">crate_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">super_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 不能使用inner_mo的私有函数</span>
        <span class="token comment" spellcheck="true">// inner_mod::inner_mod_visible_fn();</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 该函数对整个crate可见</span>
    outer_mod<span class="token punctuation">:</span><span class="token punctuation">:</span>inner_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">crate_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 对函数只对outer_mod可见</span>
    <span class="token comment" spellcheck="true">// out_mod::inner_mod::super_mod_visible_fn();</span>
    <span class="token comment" spellcheck="true">// 该函数只对outer_mod可见</span>
    <span class="token comment" spellcheck="true">// outer_mod::inner_mod::outer_mod_visible_fn();</span>
    <span class="token comment" spellcheck="true">// 通过foo函数调用内部细节</span>
    outer_mod<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单10-64中，<strong>模块可见性的层级结构是outer_mod包含inner_mod，而outer_mod又被包含于默认的顶级模块中，也就是当前crate范围。</strong> </p>
<p>代码第2行，<strong>使用pub（self）关键字标注outer_mod_fn函数的可见性，只限于self的范围。也就是说，在outer_mod和inner_mod内部都可见，但是对顶级模块不可见。</strong> </p>
<p>代码第5行，<strong>使用pub（in outer_mod）关键字标注outer_mod_visible_fn函数的可见性，只限于outer_mod范围。也就是说，该函数虽然定义于inner_mod内部，但是可以在outer_mod中访问。但不能在顶级模块中访问。</strong> </p>
<p>代码第7行，<strong>使用pub（crate）关键字标注crate_visible_fn函数的可见性，代表该函数对整个crate范围可见。</strong> </p>
<p>代码第9行，<strong>使用pub（super）关键字标注super_mod_visible_fn函数的可见性，代表该函数只在outer_mod内部可见，和pub（in outer_mod）效果等价。super关键字表示当前模块的父模块。</strong> </p>
<p>代码第13行，<strong>在super_mod_visible_fn函数中调用outer_mod中定义的outer_mod_fn函数，需要使用“：：”前缀，代表从根模块开始寻找相应的模块路径。所以，“：：outer_mod”就表示从顶级模块开始查找outer_mod模块，然后在此模块中查找outer_mod_fn函数。这种路径写法在Rust中叫作统一路径（Uniform Path）。</strong> </p>
<p>代码第16行，<strong>使用pub（self）在inner_mod中定义了inner_mod_visible_fn函数，表示该函数仅在inner_mod内部可见。</strong> </p>
<p>代码第18～24行，<strong>使用pub关键字定义了foo函数，其内部分别调用了在inner_mod中定义的那四个函数。但是在调用inner_mod_visible_fn函数时会出错，因为它仅对inner_mod可见。通过pub关键字，可以将foo函数对外开放给顶层模块去调用。这样就实现了对外公共统一接口，而封装了内部的实现细节。</strong> </p>
<p>代码第26～35行，<strong>在顶层模块中定义了bar函数。其中调用了在outer_mod中定义的函数——只有对整个crate可见的crate_visible_fn函数，以及对顶层模块可见的foo函数；而另外两个函数则无法在外层模块中被调用。</strong> </p>
<p>由此可推出下列结论： </p>
<ul>
<li>如果不显示使用pub声明，则函数或模块的可见性默认为私有的。 </li>
<li>pub，可以对外暴露公共接口，隐藏内部实现细节。 </li>
<li>pub（crate），对整个crate可见。 </li>
<li>pub（in Path），其中Path是模块路径，表示可以通过此Path路径来限定可见范围。 </li>
<li>pub（self），等价于pub（in self），表示只限当前模块可见。 </li>
<li>pub（super），等价于pub（in super），表示在当前模块和父模块中可见。</li>
</ul>
<p>有了这几种可见性的设定，接下来就可以方便地组织项目代码了。 </p>
<p>然而，在 <strong>Rust 2018</strong> 中，模块系统有所变化，需要修改上面的代码，如代码清单 10-65所示。 </p>
<p>代码清单<strong>10-65</strong>：<strong>Rust 2018</strong>模块可见性展示</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">mod</span> outer_mod <span class="token punctuation">{</span>
    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">outer_mod_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">mod</span> inner_mod <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在Rust 2018 模块系统中必须使用use导入</span>
        <span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>outer_mod<span class="token punctuation">:</span><span class="token punctuation">:</span>outer_mod_fn<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 对外层模块`outer_mod`可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">in</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>outer_mod<span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">outer_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 在`outer_mod`内部可见</span>
        <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function">super_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 访问同一个模块的函数</span>
            <span class="token function">inner_mod_visible_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 因为使用use导入了outer_mod,所以这里直接使用</span>
            <span class="token function">outer_mod_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 其他代码同上</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 代码同上</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 其他代码同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单10-65展示了Rust 2018中模块可见性的相关变化。和Rust 2015 相比，主要变化的地方有以下几处： </p>
<ul>
<li>将统一路径暂时改为了锚定路径（<strong>Anchored Path</strong>）。所以在代码第5行，需要使用use明确地将outer_mod模块引入inner_mod模块中。不过，在不久的将来，应该会向统一路径迁移。 </li>
<li>代码第7行，<strong>pub（in crate：：outer_mod）</strong>中的路径需要以<strong>crate</strong>开头。因为crate代表当前crate，也就是顶层模块。锚定路径是以顶层模块为根（<strong>root</strong>）来查找模块的。 </li>
<li>代码第13行，可以直接使用outer_mod_fn函数，因为前面已经使用use从父模块中引入了该函数。 </li>
</ul>
<p>以上就是在Rust 2018中关于模块可见性的一些变化。另外，需要注意的是，对于<strong>trait</strong>中关联类型和<strong>Enum</strong>中变体的可见性，会随着trait和Enum 的可见性而变化。但是结构体中的字段则不是这样的，还需要单独使用 pub 关键字来改变其可见性。</p>
<h2 id="10-5-小结"><a href="#10-5-小结" class="headerlink" title="10.5 小结"></a>10.5 小结</h2><p>通过本章的学习，我们对Rust的模块化编程有了较为全面的了解。<strong>Rust提供了现代化的包管理系统 Cargo，通过它提供的一系列命令，开发者可以方便地处理从开发到发布的整个流程。同时 Cargo 也非常易于扩展，Rust 社区中也有一些优秀的第三方包管理插件，比如cargo-fix、rustfmt和clippy，是日常开发的必备利器。</strong> </p>
<p><strong>Rust的模块系统与文件系统有一定的联系。不仅可以使用mod关键字定义模块，而且单个文件也是一个默认的模块。将单个文件都聚合到同一个文件夹下，然后通过mod.rs文件，就可以将它们组织成一个更大的以文件夹名称命名的模块。模块天生是封闭的，这意味着其中定义的一切语法元素都不是对外公开的。所以，如果想在外部使用某个模块或方法，就需要使用pub关键字来修改其可见性。模块之间的路径依赖也遵循文件系统的规律，默认从当前包的根目录开始查找，但是可以通过super或self来指定相对于当前模块的相对路径，super表示上一层，self表示当前模块，这和文件系统中的“..”和“.”操作十分相似。</strong> </p>
<p>在<strong>Rust 2018中使用了新的模块系统，极大地提高了Rust代码模块化的可读性和可维护性。</strong>因此，在开发中要注意和Rust 2015模块系统的区别。</p>
<p>接下来，以一道编程挑战赛的题目为例，基于Rust 2018从实现思路到具体的代码实现都做了详细的描述，包括模块组织、代码复用、第三方包的选择、Path和I/O相关模块，以及增加单元测试、集成测试和性能测试等。通过从零开始实现一个功能完整的包，我们对Rust的模块化编程有了更深入的理解。 </p>
<p>最后，通过简单的示例我们了解了Rust 2015和Rust 2018中模块可见性的差异，主要和模块系统相关。 </p>
<p>本章虽然涵盖了Rust包管理和模块的主要内容，但并非所有细节，书中未讲到的细节还需要读者自行探索。 </p>

            </div>
            <hr />
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform: scale(1.3);
        -webkit-transform: scale(1.3);
        -o-transform: scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">
                写作不易，客官能否打赏一杯奶茶？
            </h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
                    

                        <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

                            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第10章 模块化编程》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/03/19/the-tao-of-rust-programming-10/" property="cc:attributionName"
               rel="cc:attributionURL">
                bill
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '查教程获取',
        clientSecret: '查教程获取',
        repo: 'billbliu.github.io',
        owner: 'billbliu',
        admin: "billbliu",
        id: '2021/03/19/the-tao-of-rust-programming-10/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
            

                

                            

                                        

                                                    
                                                        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

                                                            

                                                                

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/03/20/the-tao-of-rust-programming-11/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="第11章 安全并发">
                        
                        <span class="card-title">第11章 安全并发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            万物并育而不相害，道并行而不相悖。 
周末到了，你想在线上订购一张期待已久的电影票，选好座位点击确认后，网站却弹出一个窗口，提示你所选择的座位已经被别人预订。工作中，你兴致勃勃地专注于功能开发时，产品经理却过来告诉你，这个需求需要修改。年关
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rust编程之道/" target="_blank">
                        <span class="chip bg-color">Rust编程之道</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/18/the-tao-of-rust-programming-09/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="第9章 构建健壮的程序">
                        
                        <span class="card-title">第9章 构建健壮的程序</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            每个人都有错，但只有愚者才会执迷不悟。 
一个人，在经历挫折之时，可以反思错误，然后坚强面对；一栋大楼，在地震来临之际，可以吸收震力，屹立不倒；一套软件系统，在异常出现之时，可以阻止崩溃，稳定运行。这就是健壮性。健壮性是指系统在一定的内外部
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rust编程之道/" target="_blank">
                        <span class="chip bg-color">Rust编程之道</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    <script>
        $('#articleContent').on('copy', function (e) {
            // IE8 or earlier browser is 'undefined'
            if (typeof window.getSelection === 'undefined') return;

            var selection = window.getSelection();
            // if the selection is short let's not annoy our users.
            if (('' + selection).length < Number.parseInt('120')) {
                return;
            }

            // create a div outside of the visible area and fill it with the selected text.
            var bodyElement = document.getElementsByTagName('body')[0];
            var newdiv = document.createElement('div');
            newdiv.style.position = 'absolute';
            newdiv.style.left = '-99999px';
            bodyElement.appendChild(newdiv);
            newdiv.appendChild(selection.getRangeAt(0).cloneContents());

            // we need a <pre> tag workaround.
            // otherwise the text inside "pre" loses all the line breaks!
            if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
                newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
            }

            var url = document.location.href;
            newdiv.innerHTML += '<br />'
                + '来源: bill的博客<br />'
                + '作者: bill<br />'
                + '链接: <a href="' + url + '">' + url + '</a><br />'
                + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

            selection.selectAllChildren(newdiv);
            window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
        });
    </script>

    <!--<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
    <script>
        const btw = new BTWPlugin();
        btw.init({
            id: 'artDetail',
            blogId: '20962-1585405055583-879',
            name: '算法码上来',
            qrcode: 'https://godweiyang.com/medias/gzh.jpg',
            keyword: 'VIP',
        });
    </script>
-->
    
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; Bill. 版权所有

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">
                    440.3k
                </span>
                

                    <br>
                    <span id="sitetime"></span>

                    
                        
        </div>
        <div class="col s12 m4 l4 social-link ">
            
    <a href="https://github.com/billbliu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:billliu201919@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=1321531943&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>

        </div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        // 50ms周期检测函数
        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>

</html>