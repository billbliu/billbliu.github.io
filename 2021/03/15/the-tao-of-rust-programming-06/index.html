<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第6章 函数、闭包与迭代器, Golang Rus Bill 数据结构和算法 网络 设计模式">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="语言影响或决定人类的思维方式。 
Rust是一门混合范式的编程语言，有机地融合了面向对象、函数式和泛型编程范式。它并非将这些特性进行简单堆砌，而是通过高度一致性的类型系统融合了这三种范式的编程思想。

可以通过impl关键字配合结构体和tr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第6章 函数、闭包与迭代器 | bill的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/medias/logo.png" class="circle logo-img" alt="LOGO">
                        
                            <span class="logo-span">
                                bill的博客
                            </span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">bill的博客</div>
        <div class="logo-desc">
            
            华东交通大学 | 区块链工程师 | golang rust
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/billbliu/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/billbliu/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
                
    </nav>

</header>
    



    <div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
        <div class="container">
            <div class="row">
                <div class="col s12 m12 l12">
                    <div class="brand">
                        <div class="description center-align post-title">
                            第6章 函数、闭包与迭代器
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Rust编程之道/" target="_blank">
                                    <span class="chip bg-color">
                                        Rust编程之道
                                    </span>
                                </a>
                                
                        </div>
                        
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                                
                        </div>
                        
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>
                    发布日期:&nbsp;&nbsp;
                        2021-03-15
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>
                    作者:&nbsp;&nbsp;
                        
                                    bill
                                        
                </div>

                
                    
                        <div class="info-break-policy">
                            <i class="fa fa-file-word-o fa-fw"></i>
                            文章字数:&nbsp;&nbsp;
                                29.8k
                        </div>
                        

                            
                                <div class="info-break-policy">
                                    <i class="fa fa-clock-o fa-fw"></i>
                                    阅读时长:&nbsp;&nbsp;
                                        117
                                            分
                                </div>
                                
                                    

                                        
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>语言影响或决定人类的思维方式。 </p>
<p><strong>Rust是一门混合范式的编程语言，有机地融合了面向对象、函数式和泛型编程范式</strong>。它并非将这些特性进行简单堆砌，而是<strong>通过高度一致性的类型系统融合了这三种范式的编程思想</strong>。</p>
<ul>
<li>可以通过impl关键字配合结构体和trait来实现面向对象范式中的多态和封装。</li>
<li>也可以通过函数、高阶函数、闭包、模式匹配来实现函数式范式中的一些编程工具。</li>
<li>Rust支持零成本静态分发的泛型编程，并且将它很好地融入了其他两种编程范式中，提供了更高的抽象层次。</li>
</ul>
<p>通过将这三种编程范式完美融合起来，Rust语言拥有了更高程度的抽象以及更强的表达能力。 </p>
<p>函数式语言的历史要比面向对象语言悠久，它源自古老的 LISP 语 言，其后发明的语言或多或少都受到了函数式编程思想的影响，比如Python、Ruby，以及更纯的函数式语言Haskell。<em>随着摩尔定律的失效， CPU性能的提升转为主要依赖核数的增加，多核时代到来后，函数式编程因为其天生对并发友好的特性又逐渐受到了重视</em>。所以近年来很多新诞生的语言也吸收了函数式范式的诸多特性，比如Elixir、Scala、Swift都受到了LISP和Haskell的影响，对代数数据类型（algebraic data type）、模式匹配、高阶函数、闭包等特性各有所支持。甚至一些年代久远的主流语言，比如C++和Java也都开始吸收函数式语言的特性。Rust作为一门在多核时代诞生的现代编程语言，引入函数式编程范式完全是顺势而为的。 </p>
<p>本章内容主要<strong>从函数和闭包两个方面来探讨Rust对函数式编程范式的支持，还会讲迭代器及其在闭包中的应用</strong>。</p>
<h2 id="6-1-函数"><a href="#6-1-函数" class="headerlink" title="6.1 函数"></a>6.1 函数</h2><p>对于一些重复执行的代码，可以将其定义为一个函数，方便调用。在第2章我们已经了解到，可以使用fn关键字来定义函数。一个标准的函数定义如代码清单6-1所示。 </p>
<p>代码清单<strong>6-1</strong>：函数定义示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 函数定义形式</span>
<span class="token keyword">fn</span> <span class="token function">func_name</span><span class="token punctuation">(</span>arg1<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> arg2<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">-></span> Vec<span class="token operator">&lt;</span>u32<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* 函数体 */</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 利用Raw identifier将语言关键字用作函数名(Rust 2018版本)</span>
<span class="token keyword">fn</span> r#<span class="token keyword">match</span><span class="token punctuation">(</span>nddele<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> haystack<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>
    haystack<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span>r#<span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"foobar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如代码清单 6-1 所示，<strong>fn 关键字后面为函数名称，通常以蛇形命名法（snake_case）命名，否则编译器会发出警告。函数参数必须明确地指定类型，如果有返回值也必须指定返回值的类型。</strong>需要注意的是，Rust中的函数参数不能指定默认值。<strong>函数体被包含于花括号之内，除函数体之外的函数声明被称为函数签名。可以说，一个函数是由函数签名和函数体组合而成的。</strong> </p>
<p>一般来说，函数定义时不允许直接使用语言中的保留字和关键字等作为函数名。但是<strong>在Rust 2018版本中，通过将原生标识操作符（Raw Identifier）r＃作为前缀，即可使用关键字为函数命名，该语法一般用于FFI中，用于避免C函数名和Rust的关键字或保留字重名而引起的冲突</strong>，如代码清单6-1的第6行所示。 </p>
<p>通过前面的章节我们了解到，<strong>函数参数可以按值传递，也可以按引用传递。当参数按值传递时，会转移所有权或者执行复制（Copy）语义。当参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数。当符合生命周期参数省略规则时，编译器可以通过自动推断补齐函数参数的生命周期参数，否则，需要显式地为参数标明生命周期参数。</strong></p>
<p><strong>函数参数也分为可变和不可变。Rust的函数参数默认不可变，当需要可变操作的时候，需要使用mut关键字来修饰。</strong>代码清单6-2展示了当参数按值传递时使用mut的情况。 </p>
<p>代码清单<strong>6-2</strong>：按值传递的参数使用<strong>mut</strong>关键字 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">mut</span> v<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>u32<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Vec<span class="token operator">&lt;</span>u32<span class="token operator">></span> <span class="token punctuation">{</span>
    v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">modify</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-2定义了modify函数，以对传入其中的动态数组进行修改，所以需要其参数为可变的。main函数的第6行声明的变量绑定v是<em>Vec＜u32＞类型，将其传到modify中，它的所有权会被转移</em>。对于第1行的modify函数来说，参数相当于重新声明的另一个变量绑定， mut关键字被放到参数变量前面作为可变修饰。所以，在main函数中，声明v的时候并没有使用mut关键字。 </p>
<p>代码清单6-3展示了按引用传递参数时mut的用法。 </p>
<p>代码清单<strong>6-3</strong>：按引用传递参数时的<strong>mut</strong>用法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">modify</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>u32<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    v<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">modify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [3, 2, 1]</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-3中的modify函数参数本身已经是可变引用类型&amp;mut [u32]，所以此处的函数参数前面不需要再使用 mut 关键字。在 main 函数中，如果想把第5 行声明的变量绑定v作为可变引用参数，就必须使用mut关键字来将其声明为可变变量。 </p>
<h3 id="6-1-1-函数屏蔽"><a href="#6-1-1-函数屏蔽" class="headerlink" title="6.1.1 函数屏蔽"></a>6.1.1 函数屏蔽</h3><p><strong>当声明变量绑定之后，如果再次声明同名的变量绑定，则之前的变量绑定会被屏蔽，这叫作变量屏蔽（variable shadow）。变量可以如此，但函数不能被多次定义。</strong>假如代码清单6-3中的modify函数被定义多次，编译器会报如下错误： </p>
<pre><code>error[E0428]: the name `modify` is defined multiple times</code></pre><p><strong>可以通过显式地使用花括号将同名的函数分隔到不同的作用域中，这样编译器就不会报错。也就是说，在同一个作用域中不能定义多个同名函数，因为默认的函数定义只在当前作用域内有效，会屏蔽作用域外的同名函数</strong>，如代码清单6-4所示。 </p>
<p>代码清单<strong>6-4</strong>：作用域内的函数会屏蔽掉作用域外的同名函数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">print!</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>
    <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>
        <span class="token keyword">fn</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">print!</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>
    <span class="token keyword">fn</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">print!</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-4的输出结果为232。在main函数第9行定义的函数f屏蔽了main函数外定义的函数f，所以第3行和第8行会输出2。第6行定义的函数f则屏蔽了main函数中定义的函数f，所以第5行会输出3。 </p>
<h3 id="6-1-2-函数参数模式匹配"><a href="#6-1-2-函数参数模式匹配" class="headerlink" title="6.1.2 函数参数模式匹配"></a>6.1.2 函数参数模式匹配</h3><p><strong>函数中的参数等价于一个隐式的let绑定，而let绑定本身是一个模式匹配的行为。所以函数参数也支持模式匹配</strong>，如代码清单6-5所示。 </p>
<p>代码清单<strong>6-5</strong>：函数参数支持模式匹配 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> S<span class="token punctuation">{</span>i<span class="token punctuation">:</span> i32<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">ref</span> _s<span class="token punctuation">:</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> _s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x7ffdd1364b80</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> S<span class="token punctuation">{</span>i<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// println!("{:?}", s);</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-5中定义了函数f，其<strong>参数使用ref关键字来修饰，这意味着要使用模式匹配来获取参数的不可变引用。与ref相对的是ref mut，ref mut用来匹配可变引用</strong>。所以，代码第4行才可以通过＂{：p}＂来打印指针地址。但是main函数中作为参数传递的变量绑定s的所有权会被转移。</p>
<p><strong>除了ref和ref mut，函数参数也可以使用通配符来忽略参数</strong>，如代码清单6-6所示。 </p>
<p>代码清单<strong>6-6</strong>：使用通配符忽略参数 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现某个trait中的方法时，有时并不会用到其函数签名中声明的所有参数，这时可以使用通配符来进行忽略，这样不会引起编译错误。 </p>
<p><strong>Rust 中的 let 语句可以通过模式匹配解构元组（Tuple），函数参数也可以</strong>，如代码清单6-7所示。 </p>
<p>代码清单<strong>6-7</strong>：函数参数利用模式匹配来解构元组 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">,</span> i32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>i32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"Alex"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-7中，函数swap的参数利用了模式匹配来解构元组。当然，如果只想解构元组中的单个值，则使用通配符将其他值忽略掉即可。 </p>
<h3 id="6-1-3-函数返回值"><a href="#6-1-3-函数返回值" class="headerlink" title="6.1.3 函数返回值"></a>6.1.3 函数返回值</h3><p><strong>Rust中的函数只能有唯一的返回值，即便是没有显式返回值的函数，其实也相当于返回了一个单元值（）。如果需要返回多个值，亦可使用元组类型</strong>，如代码清单6-8所示。</p>
<p>代码清单<strong>6-8</strong>：使用元组类型让函数返回多个值 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">addsub</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> isize<span class="token punctuation">,</span> y<span class="token punctuation">:</span> isize<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>isize<span class="token punctuation">,</span> isize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">,</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">addsub</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a：{:?}, b: {:?}"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-8中的addsub函数返回了元组类型，main函数中使用let模式匹配解构了返回的元组，分别声明了变量绑定a和b。 </p>
<p><strong>Rust语言提供了return关键字来返回函数中的值。对于只需要返回函数体最后一行表达式所求值的函数，return可以省略，比如addsub函数。在某些控制结构中，比如循环或条件分支，如果需要提前退出函数并返回某些值，则需要显式地使用return关键字来返回</strong>，如代码清单6-9所示。</p>
<p>代码清单<strong>6-9</strong>：使用<strong>return</strong>提前返回示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单 6-9 中，函数 gcd 使用<strong>欧几里得算法（辗转相除法）求两数中的最大公约数</strong>。如果a%b的余数不为0，则将b和a相互置换，将余数作为b的值，继续递归求值；如果余数为0，则提前返回a。其实此例中如果gcd函数使用if-else条件分支，阅读性会更好一些。 </p>
<p>我们在第2章中见到过函数<strong>返回值类型为“！”的发散函数（diverging function），这类函数将永远不会有任何返回值。</strong> </p>
<h3 id="6-1-4-泛型函数"><a href="#6-1-4-泛型函数" class="headerlink" title="6.1.4 泛型函数"></a>6.1.4 泛型函数</h3><p>Rust的函数也支持泛型。通过实现泛型函数，可以节省很多工作量，如代码清单 6-10所示。 </p>
<p>代码清单<strong>6-10</strong>：实现泛型函数示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Mul<span class="token punctuation">;</span>
<span class="token keyword">fn</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Mul<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Output<span class="token operator">=</span>T<span class="token operator">>></span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">,</span> y<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token punctuation">{</span>
    x <span class="token operator">*</span> y
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b<span class="token punctuation">:</span> f64 <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">37.2</span><span class="token punctuation">,</span> <span class="token number">41.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1517</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">1528.92</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 浮点数执行结果可能有所差别</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-10实现了一个求乘积的函数square，该函数参数并未指定具体的类型，而是用了泛型T，对T只有一个Mul trait限定，即只有实现了Mul的类型才可以作为参数，从而保证了类型安全，这是实现泛型函数需要注意的地方。因为Mul trait有关联类型，所以这里需要显式指定为Output=T。这样，在main函数中可以将其应用于i32或f64等类型，而不需要单独为某个类型实现一遍square函数。 </p>
<p>注意，<strong>这里调用square函数的时候并未指定具体类型，而是靠编译器来进行自动推断的</strong>。此示例使用的都是基本原生类型，编译器推断起来比较简单。但<strong>肯定存在编译器无法自动推断的情况，此时就需要显式地指定函数调用的类型，需要用到第3章提到过的turbofish操作符：：＜＞</strong>，如代码清单6-11所示。 </p>
<p>代码清单<strong>6-11</strong>：使用<strong>turbofish</strong>操作符</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Mul<span class="token punctuation">;</span>
<span class="token keyword">fn</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Mul<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Output<span class="token operator">=</span>T<span class="token operator">>></span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">,</span> y<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token punctuation">{</span>
    x <span class="token operator">*</span> y
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> square<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>u32<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> square<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>f32<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">37.2</span><span class="token punctuation">,</span> <span class="token number">41.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1517</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">1528.9199</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-11的第6行和第7行使用turbofish操作符指定了具体的类型，因而就不需要在变量绑定a和b之后再次显式地指定类型了。 </p>
<h3 id="6-1-5-方法与函数"><a href="#6-1-5-方法与函数" class="headerlink" title="6.1.5 方法与函数"></a>6.1.5 方法与函数</h3><p><strong>Rust中的方法和函数是有区别的。方法来自面向对象编程范式，在语义上，它代表某个实例对象的行为。函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用的，但它必须关联一个方法接收者。</strong> </p>
<p>代码清单6-12中为结构体User实现了方法。 </p>
<p>代码清单<strong>6-12</strong>：为结构体<strong>User</strong>实现方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> User <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span>
    avatar_url<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> User <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"name: {:?}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"avatar: {:?}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>avatar_url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> user <span class="token operator">=</span> User <span class="token punctuation">{</span>
        name<span class="token punctuation">:</span> <span class="token string">"Alex"</span><span class="token punctuation">,</span>
        avatar_url<span class="token punctuation">:</span> <span class="token string">"https://avatar.com/alex"</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// User::show(&amp;user);</span>
    user<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-12中定义了结构体User，包含两个成员字段name和avatar_url。我们<strong>使用impl关键字为User实现了show方法，其参数为 &amp;self。此处self为结构体User的任意实例，&amp;self则为实例的引用。</strong> </p>
<p>这样就可以在main函数中使用点操作来调用show方法了（代码第18行），而结构体实例 user 会被隐式传递给 show 方法，user 就是 show方法的接收者。user.show 等价于User：：show（&amp;user）这样的函数调用。在第7章中还会讲到更多关于结构体和方法的内容。</p>
<h3 id="6-1-6-高阶函数"><a href="#6-1-6-高阶函数" class="headerlink" title="6.1.6 高阶函数"></a>6.1.6 高阶函数</h3><p>在数学和计算机科学里均有高阶函数的定义。在数学中，高阶函数也叫算子或泛函。比如微积分中的导数就是一个函数到另一个函数的映射。<strong>在计算机科学里，高阶函数是指以函数作为参数或返回值的函数，它也是函数式编程语言最基础的特性。Rust语言也支持高阶函数，因为函数在Rust中是一等公民。函数可以作为参数进行传递</strong>，如代码清单6-13所示。 </p>
<p>代码清单<strong>6-13</strong>：函数本身作为参数 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">math</span><span class="token punctuation">(</span>op<span class="token punctuation">:</span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">,</span> a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    <span class="token function">op</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">product</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    a <span class="token operator">*</span> b
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">math</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">math</span><span class="token punctuation">(</span>product<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-13的第1行代码定义了函数math，其中第一个参数op类型为fn（i32，i32）-＞i32，代表其为一个函数。第4行到第6行定义了一 个求和函数sum，第7行到第9行定义了一个求积函数product，然后在main函数中将sum和product分别作为参数传到math中进行调用，编译运行之后得到预期的值。<strong>函数 math 就是一个高阶函数，注意其在调用的时候传入的只是函数名</strong>。 </p>
<p><strong>实现这一切的基础在于Rust支持类似C/C++语言中的函数指针。函数指针，顾名思义，是指向函数的指针，其值为函数的地址</strong>，如代码清单6-14所示。 </p>
<p>代码清单<strong>6-14</strong>：函数指针</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"hello function pointer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> fn_str<span class="token punctuation">:</span> <span class="token keyword">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> hello<span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> fn_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x562bacfb9f80</span>
    <span class="token keyword">let</span> other_fn <span class="token operator">=</span> hello<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// println!("{:p}", other_fn); // 非函数指针</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">other_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fn_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>fn_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-14的第5行声明了一个函数指针。这里需要注意的地方是，<strong>let声明必须显式指定函数指针类型fn（），以及赋值使用的是函数名hello而非带括号的函数调用</strong>。第6行通过打印fn_ptr的指针地址，证明 </p>
<p>其为一个函数指针。 </p>
<p>代码第7行的let声明并没有指定函数指针类型，如果取消第8行的注释，那么编译此代码时，打印other_fn指针地址会报如下错误：</p>
<pre><code>error[E0277]: the trait bound `fn() {hello}: std::fmt::Pointer` is not satisfied
8 | println!(&quot;{:p}&quot;, other_fn);
  |                        ^^^^^^^^ the trait `std::fmt::Pointer` is not implemented for `fn() {hello}`</code></pre><p>根据此错误信息可以了解到，other_fn的类型实际上是fn（）{hello}，这其实是函数hello本身的类型，而非函数指针类型，所以 other_fn不是函数指针类型。虽然如此，并不会影响第10行的函数调用。</p>
<p>回到代码清单6-13中，函数math的参数op的类型指定为fn（i32，i32）-＞i32，就是函数指针类型。当main函数中调用math函数时，<em>传入sum和product函数名之后，会自动通过模式匹配转换为函数指针类型</em>。 </p>
<p><strong>对于函数指针类型，可以使用type关键字为其定义别名，便于提升代码可读性</strong>，如代码清单6-15所示。 </p>
<p>代码清单<strong>6-15</strong>：使用<strong>type</strong>关键字定义函数指针类型别名 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">type</span> MathOp <span class="token operator">=</span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">math</span><span class="token punctuation">(</span>op<span class="token punctuation">:</span> MathOp<span class="token punctuation">,</span> a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">op</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，也可以将函数作为返回值，如代码清单6-16所示。 </p>
<p>代码清单<strong>6-16</strong>：将函数作为返回值</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">type</span> MathOp <span class="token operator">=</span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">math</span><span class="token punctuation">(</span>op<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> MathOp <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
        a <span class="token operator">+</span> b
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">product</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
        a <span class="token operator">*</span> b
    <span class="token punctuation">}</span>
    <span class="token keyword">match</span> op <span class="token punctuation">{</span>
        <span class="token string">"sum"</span> <span class="token operator">=</span><span class="token operator">></span> sum<span class="token punctuation">,</span>
        <span class="token string">"product"</span> <span class="token operator">=</span><span class="token operator">></span> product<span class="token punctuation">,</span>
        _<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span>
                <span class="token string">"Warning: Not Implemented {:?} oprator, Replace with sum"</span><span class="token punctuation">,</span>
                op
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span><span class="token string">"sum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> div <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">product</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">div</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-16中实现的math函数，接收一个字符串作为参数，函数中使用match进行匹配，如果字符串为sum，则返回sum函数；如果字符串是product，则返回product函数。注意在match匹配中，sum和product函数均只是函数指针（函数名）。该代码可以正确编译执行，注意代码第25行，因为没有实现div函数，所以代码会打印指定的warning提示，并使用sum函数替代div函数。 </p>
<p>假设现在想把 math 函数修改一下，让其作为返回值的函数直接和参与计算的值进行绑定，如代码清单6-17所示。 </p>
<p>代码清单<strong>6-17</strong>：将返回的函数和参与计算的参数直接绑定</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">product</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    a <span class="token operator">*</span> b
<span class="token punctuation">}</span>
<span class="token keyword">type</span> MathOp <span class="token operator">=</span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32
<span class="token keyword">fn</span> <span class="token function">math</span><span class="token punctuation">(</span>op<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> MathOp <span class="token punctuation">{</span>
    <span class="token keyword">match</span> op <span class="token punctuation">{</span>
        <span class="token string">"sum"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span>
        _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">product</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span><span class="token string">"sum"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-17编译会报类型不匹配的错误。因为在math函数调用的时候，match匹配中的sum（a，b）和product（a，b）会同时进行求值，得到的是i32类型，而不是MathOp类型。所以，要想返回函数，还必须使用函数指针。 </p>
<p>再来看另外一个将函数作为返回值的示例，如代码清单6-18所示。 </p>
<p>代码清单<strong>6-18</strong>：返回默认加<strong>1</strong>的计数函数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">inc</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
        n <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    inc
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-18中定义了默认加1的计数函数，现在我们把其改为可以直接指定增长值的函数，如代码清单6-19所示。 </p>
<p>代码清单<strong>6-19</strong>：让<strong>counter</strong>函数可以直接指定增长值<strong>i</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">inc</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
        n <span class="token operator">+</span> i
    <span class="token punctuation">}</span>
    inc
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 编译会报以下错误：</span>
error<span class="token punctuation">[</span>E0434<span class="token punctuation">]</span><span class="token punctuation">:</span> can't capture dynamic enviroment <span class="token keyword">in</span> a <span class="token keyword">fn</span> item<span class="token punctuation">;</span> <span class="token keyword">use</span> the <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token punctuation">}</span> closure form instead
<span class="token number">3</span> <span class="token operator">|</span>     n <span class="token operator">+</span> i
  <span class="token operator">|</span>         <span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Rust不允许fn定义的函数inc捕捉动态环境（函数counter）中的变量绑定i，因为变量绑定i会随着栈帧的释放而释放。如果一定要这么做，需要使用闭包来代替。</p>
<h2 id="6-2-闭包"><a href="#6-2-闭包" class="headerlink" title="6.2 闭包"></a>6.2 闭包</h2><p><strong>闭包（Closure）通常是指词法闭包，是一个持有外部环境变量的函数。外部环境是指闭包定义时所在的词法作用域。外部环境变量，在函数式编程范式中也被称为自由变量，是指并不是在闭包内定义的变量。将自由变量和自身绑定的函数就是闭包。</strong> </p>
<p>回到代码清单6-19中，如果想在返回的函数中继续使用变量 i，则 需要用到闭包，如代码清单6-20所示。 </p>
<p>代码清单<strong>6-20</strong>：返回闭包 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">counter</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> Box<span class="token operator">&lt;</span>dyn <span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token operator">></span> <span class="token punctuation">{</span>
    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token operator">|</span>n<span class="token punctuation">:</span> i32<span class="token operator">|</span> n <span class="token operator">+</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-20中，counter函数返回的是一个闭包，放到了Box＜T＞中，因为闭包的大小在编译期是未知的。在Rust 2018版本中，返回的闭包也可以使用<strong>impl Trait</strong>语法写成impl Fn（i32）-＞i32，这样就不需要使用Box＜T＞了。 </p>
<p>在代码第2行的闭包 |n：i32 | n + i 中，i为自由变量，因为闭包自身的参数只有n。第5章介绍过闭包捕获自由变量的三种方式，因为此时 i 为 复制语义类型，所以它肯定会按引用被捕获。此引用会妨碍闭包作为函数返回值，编译器会报错。所以这里使用 move 关键字来把自由变量 i 的所有权转移到闭包中，当然，因为变量 i 是复制语义，所以这里只会进行按位复制。 </p>
<p>注意这里<strong>闭包的类型为 Fn（i32）-＞ i32，以大写字母 F 开头的 Fn 并不是函数指针类型fn（i32）-＞i32，它是一个trait</strong>，本章后面的章节有更详细的介绍。 </p>
<p>在main函数中，第5行变量f绑定了counter（3）函数调用返回的闭包。该闭包持有counter函数传入的参数值3，在第6行调用f（1）时参与了计算，得到最终的结果4。 </p>
<p>通过此例看得出来，闭包包含以下两种特性： </p>
<ul>
<li><p>延迟执行。返回的闭包只有在需要调用的时候才会执行。 </p>
</li>
<li><p>捕获环境变量。闭包会获取其定义时所在作用域中的自由变量， 以供之后调用时使用。 </p>
</li>
</ul>
<p>现在我们对闭包有了大致的了解，接下来将系统地学习Rust中闭包的具体概念和实现。 </p>
<h3 id="6-2-1-闭包的基本语法"><a href="#6-2-1-闭包的基本语法" class="headerlink" title="6.2.1 闭包的基本语法"></a>6.2.1 闭包的基本语法</h3><p>Rust的闭包语法形式参考了Ruby语言的lambda表达式，如代码清单 6-21所示。 </p>
<p>代码清单<strong>6-21</strong>：闭包基本语法示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">|</span></span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>闭包由管道符（两个对称的竖线）和花括号（或圆括号）组合而成。管道符里是闭包函数的参数，可以像普通函数参数那样在冒号后面 添加类型标注，也可以省略为以下形式</strong>： </li>
</ul>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>a<span class="token punctuation">,</span> b<span class="token punctuation">|</span></span> <span class="token punctuation">-></span> i32<span class="token punctuation">{</span>a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>花括号里包含的是闭包函数执行体，花括号和返回值也可以省略</strong>： </li>
</ul>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token operator">|</span>a<span class="token punctuation">,</span> b<span class="token operator">|</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略</strong>：</li>
</ul>
<pre><code>let (a, b) = (1, 2);
let add = || a + b;</code></pre><ul>
<li><strong>闭包的参数可以是任意类型的</strong>，如代码清单6-22所示。 </li>
</ul>
<p>代码清单<strong>6-22</strong>：闭包参数可以为任意类型</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token operator">|</span>a<span class="token punctuation">:</span> <span class="token keyword">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token operator">|</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
    <span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-22的第3行定义的闭包有两个参数，第一个是函数指针类型，第二个是元组类型。虽然元组类型中的参数没有显式地标注类型，但是Rust编译器会通过函数指针类型的信息来推断其为i32类型，所以代码可以正常编译运行。 </p>
<p>需要注意的是，<em>两个定义一模一样的闭包也并不一定属于同一种类型</em>，如代码清单6-23所示。 </p>
<p>代码清单<strong>6-23</strong>：两个相同定义的闭包却不属于同一种类型 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c1 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c2 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token punctuation">[</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-23声明了两个形式一样的闭包，将它们保存到一个数组中。因为数组只能保存相同类型的元素，所以编译会报如下错误： </p>
<pre><code>error[E0308]: mismatched types
5 |     let v = [c1, c2];
  |                  ^^ expected closure, found a different closure</code></pre><p>这表示两个相同定义的闭包完全不属于同一种类型。 </p>
<h3 id="6-2-2-闭包的实现"><a href="#6-2-2-闭包的实现" class="headerlink" title="6.2.2 闭包的实现"></a>6.2.2 闭包的实现</h3><p>假如现在想<strong>显式地指定闭包的类型</strong>，该如何操作？可以通过代码清单6-24所示的方法来查看一个闭包的类型。 </p>
<p>代码清单<strong>6-24</strong>：查看闭包类型</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c1<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"i'm a closure"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-24编译会报如下错误： </p>
<pre><code>error[E0308]: mismatched types
3 |     let c1: () = || {println!(&quot;i&#39;m a closure&quot;)};
  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found closure
          = note: expected type `()` found type `[closure@src/main.rs:3:19 3:49]`</code></pre><p>错误信息提示，期望得到的类型是单元类型，但是实际得到的类型是[closure@src/main.rs：3：19：3：49]。这个闭包类型与 Rust 类型系统提供的常规类型不同，它是一个由编译器制造的临时存在的闭包实例类型。</p>
<p>其实<strong>在Rust中，闭包是一种语法糖。也就是说，闭包不属于Rust语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法。闭包和普通函数的差别就是闭包可以捕获环境中的自由变量</strong>。如果用现在已经学过的知识来实现一个自己的闭包，该如何做？</p>
<p>能想到的第一个办法是使用指针。如图6-1所示，闭包||{a+b}的实现可以通过函数指针和捕获变量指针组合来实现。指针放栈上，捕获变量放到堆上。实际上，早期的Rust版本实现闭包就采用了类似的方式，因 为要把闭包捕获变量放到堆上，所以称其为装箱（Boxed）闭包。这种方式带来的问题就是影响性能。Rust是基于LLVM的语言，这种闭包实现方式使得LLVM难以对其进行内联和优化。</p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210428215222848.png" alt="image-20210428215222848"></p>
<p>所以，Rust团队又对闭包的实现做了重大改进，也就是当前版本中的闭包实现方式。<strong>改进方案称为非装箱（Unboxed）闭包，此方案是Rust语言一致性的再一次体现</strong>。 </p>
<p><strong>非装箱闭包方案有三个目标</strong>： </p>
<ul>
<li>可以让用户更好地控制优化。 </li>
<li>支持闭包按值和按引用绑定环境变量。 </li>
<li>支持三种不同的闭包访问，对应self、&amp;self和&amp;mut self三种方法。</li>
</ul>
<p><strong>实现这三个目标的核心思想是，通过增加trait将函数调用变为可重载的操作符</strong>。比如，将a（b，c，d）这种函数调用变为如下形式：</p>
<pre class="line-numbers language-rust"><code class="language-rust">Fn<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span>
FnMut<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> a<span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span>
FnOnce<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">call_once</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Rust增加的这三个trait分别就是Fn、FnMut和FnOnce。它们在Rust源码中的定义如代码清单6-25所示。 </p>
<p>代码清单<strong>6-25</strong>：<strong>Fn</strong>、<strong>FnMu</strong>、<strong>FnOnce</strong>在源码中的定义示例</p>
<pre class="line-numbers language-rust"><code class="language-rust">#<span class="token punctuation">[</span>lang <span class="token operator">=</span> <span class="token string">"fn_once"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[rustc_paren_sugar]</span>
<span class="token attribute attr-name">#[fundamental]</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> FnOnce<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_once</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
#<span class="token punctuation">[</span>lang <span class="token operator">=</span> <span class="token string">"fn_mut"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[rustc_paren_sugar]</span>
<span class="token attribute attr-name">#[fundamental]</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> FnMut<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">:</span> FnOnce<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
#<span class="token punctuation">[</span>lang <span class="token operator">=</span> <span class="token string">"fn"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[rustc_paren_sugar]</span>
<span class="token attribute attr-name">#[fundamental]</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> Fn<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">:</span> FnMut<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从代码清单6-25中看得出来，这三个trait都标记了三个相同的属性。</p>
<p>第一个属性是<strong>＃[lang=＂fn/fn_mut/fn_once＂]，表示其属于语言项（Lang Item），分别以fn、fn_mut、fn_once名称来查找这三个trait</strong>。 </p>
<p>第二个属性是<strong>＃[rustc_paren_sugar]，表示这三个trait是对括号调用语法的特殊处理，在编译器内部进行类型检查的时候，仅会将最外层为圆括号的情况识别为方法调用。在类型签名或方法签名中有时候有尖括号，比如＜F：Fn（u8，u8）-＞u8＞，而此时尖括号里面的括号就不会被识别为方法调用</strong>。 </p>
<p>第三个属性为<strong>＃[fundamental]，在第3章介绍过，这是为了支持trait一致性而增加的属性，加上此属性则被允许为Box＜T＞实现指定的trait，在此例中是这三个Fn系列的trait</strong>。 </p>
<p>函数调用为什么要分成三个trait？这和所有权系统有关。</p>
<ul>
<li>FnOnce调用参数为self，这意味着它会转移方法接收者的所有权。换句话说，就是这种方法调用只能被调用一次。 </li>
<li>FnMut调用参数为&amp;mut self，这意味着它会对方法接收者进行可 变借用。</li>
<li>Fn调用参数为&amp;self，这意味着它会对方法接收者进行不可变借用，也就是说，这种方法调用可以被调用多次。 </li>
</ul>
<p>现在函数调用被抽象成为了三个 trait，实现闭包就简单了，只需要用结构体代替闭包表达式，然后按具体的需求为此结构体实现对应的 trait即可。这样的话，每个闭包表达式实际上就是该闭包结构体的具体实例，该结构体内部成员可以存储闭包捕获的变量，然后在调用的时候使用即可，如代码清单6-26所示。 </p>
<p>代码清单<strong>6-26</strong>：模拟编译器对闭包的实现</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(unboxed_closures, fn_traits)]</span>
<span class="token keyword">struct</span> Closure <span class="token punctuation">{</span>
    env_var<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> FnOnce<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token keyword">for</span> Closure <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> u32<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_once</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"call it FnOnce()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>env_var <span class="token operator">+</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> FnMut<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token keyword">for</span> Closure <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"call it FnMut()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>env_var <span class="token operator">+</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Fn<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token keyword">for</span> Closure <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"call it Fn()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>env_var <span class="token operator">+</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> call_it<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token operator">&amp;</span>F<span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> call_it_mut<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> call_it_once<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">FnOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> env_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> Closure <span class="token punctuation">{</span>env_var<span class="token punctuation">:</span> env_var<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">call_once</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> Closure <span class="token punctuation">{</span>env_var<span class="token punctuation">:</span> env_var<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">call_it</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">call_it_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">call_it_once</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-26的第1行使用了<strong>feature特性＃！ [feature（unboxed_closures，fn_traits）]，注意此特性只能应用于Nightly版本下</strong>。 </p>
<p>第2行定义了结构体Closure，有一个成员字段代表从环境中捕获的自由变量。然后分别为其实现了FnOnce、FnMut、Fn这三个trait。 </p>
<p>第24行到第32行定义了call_it、call_it_mut、call_it_once三个泛型函数，它们分别使用FnOnce、FnMut、Fn这三个trait来做泛型参数的限定，用来测试Closure结构体实例调用。在main函数中，第35行定义了Closure结构体实例，将环境变量env_var保存在其成员字段中。因为该结构体实现了指定的trait，所以在第36行其实例c可以像函数那样被调用。 </p>
<p>最终的执行结果如代码清单6-27所示。 </p>
<p>代码清单<strong>6-27</strong>：自定义闭包实现的输出结果</p>
<pre><code>call it Fn()
call it Fn()
call it FnMut()
call it FnOnce()
call it Fn()
call it FnMut()
call it FnOnce()</code></pre><p>代码清单6-27第1行是代码清单6-26中第36行的输出结果。它说明，默认的函数调用c（）是Fn trait中实现的call方法。此处结构体实例可以像函数那样被调用，这看起来像“魔法”，实际上是由下面的代码实现的。</p>
<pre><code>extern &quot;rust-call&quot; fn call(&amp;self, args: ()) -&gt; u32</code></pre><p>此处<strong>extern关键字用于fn前面，表示使用指定的ABI（Application Binary Interface，程序二进制接口），此处代表指定使用Rust语言的rust-call ABI，它的作用是将函数参数中的元组类型做动态扩展，以便支持可变长参数</strong>。因为在 Fn、FnMut、FnOnce 这三个 trait 里的方法要接收闭包的参数，而编译器本身并不可能知道开发者给闭包设定的参数个数，所以这里只能传元组，然后由rust-call ABI在底层做动态扩展。 </p>
<p>但是需要注意的是，如果想使用 rust-call ABI，必须像代码清单 6-26 第 1 行那样声明unboxed_closures特性。 代码清单6-26第37行至第39行分别显式地调用了相应的call、call_mut、call_once方法，但是注意必须显式地指定一个单元值为参数，这里为了演示，指定了args参数为单元类型。分别输出代码清单6-27的第2行至第4行的结果。 </p>
<p>代码清单6-26的第40行重新声明了Closure结构体实例，这是因为在第39行call_once调用之后，之前的实例c的所有权被转移，无法再次被 使用。要注意call_once方法中的参数是self。代码清单6-26的第41行到第49行使用了call_it、call_it_mut、call_it_once函数来测试相应的trait限定，对应的trait限定如下。 </p>
<pre><code>F: Fn() -&gt; u32
F: FnMut() -&gt; u32
F: FnOnce() -&gt; u32</code></pre><p>输出的结果为代码清单6-27的第5行至第7行，和预期相符。 </p>
<p>代码清单6-26等价于下面的闭包代码，如代码清单6-28所示。 </p>
<p>代码清单<strong>6-28</strong>：与代码清单<strong>6-26</strong>等价的闭包示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> env_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token operator">||</span> env_var <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 6-28 中定义的闭包 c 相当于代码清单 6-26 中已经实现了相应 trait 的结构体Closure的实例c。 </p>
<p>代码清单6-26模拟的闭包实现并不等同于Rust编译器源码中真正的闭包实现。这里只是做一个思路的演示。 </p>
<p>现在我们知道了闭包是基于trait的语法糖，那么就可以通过使用trait对象来显式地指定其类型，如代码清单6-29所示。 </p>
<p>代码清单<strong>6-29</strong>：显式指定闭包类型 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> env_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token operator">></span> <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span>env_var <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-29的第3行显式地指定了闭包的类型为Box＜Fn（）-＞ i32＞，该类型为trait对象，此处必须使用trait对象。 </p>
<h3 id="6-2-3-闭包与所有权"><a href="#6-2-3-闭包与所有权" class="headerlink" title="6.2.3 闭包与所有权"></a>6.2.3 闭包与所有权</h3><p>闭包表达式会由编译器自动翻译为结构体实例，并为其实现Fn、FnMut、FnOnce三个trait中的一个。但是对于开发者来说，如何才能知道某个闭包表达式由编译器默认实现了哪种trait呢？ </p>
<p>前面提到过，这三个trait和所有权有关系。更准确地说，这<strong>三个trait的作用</strong>如下。 </p>
<ul>
<li><strong>Fn，表示闭包以不可变借用的方式来捕获环境中的自由变量，同时也表示该闭包没有改变环境的能力，并且可以多次调用。对应&amp;self。</strong></li>
<li><strong>FnMut，表示闭包以可变借用的方式来捕获环境中的自由变量，同时意味着该闭包有改变环境的能力，也可以多次调用。对应&amp;mut self。</strong></li>
<li><strong>FnOnce，表示闭包通过转移所有权来捕获环境中的自由变量，同时意味着该闭包没有改变环境的能力，只能调用一次，因为该闭包会消耗自身。对应self。</strong> </li>
</ul>
<p>第5章讲所有权系统时，<strong>对不同环境变量类型介绍过闭包捕获其环境变量的方式</strong>： </p>
<ul>
<li><strong>对于复制语义类型，以不可变引用（&amp;T）来进行捕获。</strong> </li>
<li><strong>对于移动语义类型，执行移动语义，转移所有权来进行捕获。</strong> </li>
<li><strong>对于可变绑定，并且在闭包中包含对其进行修改的操作，则以可变引用（&amp;mut T）来进行捕获。</strong> </li>
</ul>
<p>也就是说，<strong>闭包会根据环境变量的类型来决定实现哪种trait</strong>。这三个trait的关系如图6-2所示。 </p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503090421954.png" alt="image-20210503090421954"></p>
<p>图6-2展示了Fn、FnMut、FnOnce三个trait之间的关系。FnMut继承了FnOnce，Fn又继承了FnMut。这意味着，如果要实现Fn，就必须实现FnMut和FnOnce；如果要实现FnMut，就必须实现FnOnce；如果只需要实现FnOnce，就不需要实现FnMut和Fn。</p>
<p>复制语义类型自动实现<strong>Fn</strong> 相关代码如代码清单6-30所示。 </p>
<p>代码清单<strong>6-30</strong>：复制语义类型自动实现<strong>Fn</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-30中，声明了变量绑定s为字符串字面量，其为复制语义类型。闭包c会按照不可变引用来捕获s。第4行和第5行代码两次调用闭包c，第6行的println！打印s，均可以正常编译运行，因此就可以做出这样的推理：闭包c可以两次调用，说明编译器自动为闭包表达式实现的结构体实例并未失去所有权。第6行的println！语句会对s进行一次不可变借用，这就证明第3行闭包对s进行了不可变借用，只有不可变借用才可以借用多次。 </p>
<p>综上所述，闭包c默认自动实现了Fn这个trait，并且该闭包以不可变借用捕获环境中的自由变量。 </p>
<p>要实现Fn就必须实现FnMut和FnOnce，所以，代码清单6-30中的闭包如果被编译器翻译为匿名结构体和trait，那么Fn、FnMut、FnOnce都 会被实现，如代码清单6-31所示。 </p>
<p>代码清单<strong>6-31</strong>：代码清单<strong>6-30</strong>中的闭包被翻译为匿名结构体和<strong>trait</strong>的情况</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(unboxed_closures, fn_traits)]</span>
<span class="token keyword">struct</span> Closure<span class="token operator">&lt;</span>'a<span class="token operator">></span> <span class="token punctuation">{</span>
    env_var<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'a u32
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a> FnOnce&lt;()> for Closure&lt;'</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_once</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>env_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a> FnMut&lt;()> for Closure&lt;'</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>env_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a> Fn&lt;()> for Closure&lt;'</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span>  <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>env_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> env_var <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> <span class="token function">Closure</span><span class="token punctuation">(</span>env_var<span class="token punctuation">:</span> <span class="token operator">&amp;</span>env_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span>
    c<span class="token punctuation">.</span><span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span>
    c<span class="token punctuation">.</span><span class="token function">call_once</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-31中，闭包被翻译为结构体Closure＜＇a ＞，因为环境变量是按不可变借用进行捕获的，所以其成员字段是引用类型，注意这里需要明确指定生命周期参数。在 main函数的第24行，闭包结构体实例c的调用操作默认是执行Fn实现中的call方法。因为这里要实现Fn，必须同时实现 FnMut 和 FnOnce，所以第 25 行和第 26 行可以显式地直接调用call_mut和call_once方法。因此，在代码清单6-30的闭包调用中也可以显式地调用call_mut和call_once方法，如代码清单6-32所示。 </p>
<p>代码清单<strong>6-32</strong>：实现了<strong>Fn</strong>的闭包也可以显式调用<strong>call_mut</strong>和<strong>call_once</strong>方法 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(fn_tarits)]</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
    c<span class="token punctuation">.</span><span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
    c<span class="token punctuation">.</span><span class="token function">call_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
    c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hello"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-32的第1行使用了<strong>＃！[feature（fn_traits）]</strong>特性，是为了显式调用trait实现中的call、call_mut、call_once方法，如果是默认的闭包调用，并不需要此特性（比如代码清单6-30）。 </p>
<p>代码第4行使用了mut关键字改变了闭包的可变性，这是为了调用call_mut方法，此方法需要可变闭包。 </p>
<p>代码第5行默认的闭包调用是Fn实现的call方法。第6行依然可以再次调用闭包c。 </p>
<p>代码第7行显式地调用了call_mut方法，正常输出结果。 </p>
<p>代码第8行显式地调用了call_once方法，正常输出结果。此时闭包c捕获的变量s默认实现了Copy，因此默认实现的FnOnce也会自动实现Copy。此处调用call_once方法并不会导致闭包c的所有权被转移。第9行再次调用闭包c，正常输出。但是如果闭包c的捕获变量是移动语义，那么调用call_once就会转移所有权。 </p>
<p>第10行正常打印变量绑定s，证明闭包c并没有被后面的call_mut和 call_once调用所影响，闭包依旧是按不可变借用捕获的。这也证明闭包被编译器翻译为的结构体是一种固定的结构体。</p>
<p>移动语义类型自动实现<strong>FnOnce</strong>,相关代码如代码清单6-33所示。 </p>
<p>代码清单<strong>6-33</strong>：移动语义类型自动实现<strong>FnOnce</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token operator">||</span> s<span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// c(); // error: use of moved value: `c`</span>
    <span class="token comment" spellcheck="true">//println!("{:?}", s); // error: use of moved value: `c`</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-33中，变<em>量绑定s为String，是典型的移动语义类型</em>。第5行第二次调用闭包c的时候，编译出错，提示c已经被转移了所有权，因而无法使用。而第6行在第4行闭包c调用之后，也会编译出错，提示s已经被转移了所有权而无法使用。综上所述，可以做出这样的推理：闭包c在第一次调用时转移了其所有权，导致第二次调用失效，证明其实现的闭包结构体实例所实现的trait方法参数必然是self。足以证明该闭包实现的是FnOnce。第6行的s因为失去所有权而失效，也足以证明闭包c夺走了s的所有权。 </p>
<p>既然闭包的默认调用是FnOnce，这也说明，编译器翻译的闭包结构体中记录捕获变量的成员字段不是引用类型，并且只实现 FnOnce，所以，肯定无法显式地调用 call 或 call_mut方法，如代码清单6-34所示。 </p>
<p>代码清单<strong>6-34</strong>：闭包只实现了<strong>FnOnce</strong>，所以无法显式地调用<strong>call</strong>和<strong>call_mut</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(fn_traits)]</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token operator">||</span> s<span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// error: expected a closure that implements the `FnMut` trait,  but this     </span>
    <span class="token comment" spellcheck="true">//         closure only implements `FnOnce`</span>
    <span class="token comment" spellcheck="true">// c.call(());</span>
    <span class="token comment" spellcheck="true">// error: expected a closure that implements the `FnMut` trait,  but this     </span>
    <span class="token comment" spellcheck="true">//         closure only implements `FnOnce`</span>
    <span class="token comment" spellcheck="true">// c.call_mut(());</span>
    <span class="token comment" spellcheck="true">// c.(); // error: use of moved value: `c`</span>
    <span class="token comment" spellcheck="true">// println!("{:?}", s); // error: use of moved value: `c`</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-34的第3行声明闭包时使用了mut关键字来设置闭包的可变性，同样是为了显式调用call_mut。 </p>
<p>闭包c默认实现了FnOnce，所以代码第8行和第11行分别显式地调用call和call_mut方法时，编译器都报错了，并且提示闭包只实现了FnOnce。</p>
<p>注意代码中已被注释掉的第12行，再次调用闭包c将报所有权转移的错误。这是因为闭包c的捕获变量是String类型，它是移动语义，所以在上面第一次调用闭包c之后，它的所有权已被转移。 </p>
<p>使用<strong>move</strong>关键字自动实现<strong>Fn</strong> </p>
<p><strong>Rust 针对闭包提供了一个关键字 move，使用此关键字的作用是强制让闭包所定义环境中的自由变量转移到闭包中</strong>，如代码清单6-35所示。</p>
<p>代码清单<strong>6-35</strong>：环境变量为复制语义类型时使用<strong>move</strong>关键字</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-35中的<em>变量绑定s为复制语义类型，虽然move关键字强制执行，但闭包捕获的s执行的对象是复制语义后获取的新变量。原始的s并未失去所有权</em>。所以整个代码可以正常通过编译。由此，可以做出这样的推理：闭包c可以连续两次被调用，说明编译器自动生成的闭包结构体实例并未失去所有权，所以肯定是&amp;self和&amp;mut self中的一种。又因为闭包c本身是不可变的，所以只存在&amp;self。因为要进行不可变借用，所以必须使用mut关键字将c本身修改为可变。因此，该闭包实现的一定是Fn。 </p>
<p>代码清单6-36展示的是环境变量为移动语义类型的情况。 </p>
<p>代码清单<strong>6-36</strong>：环境变量为移动语义类型时使用<strong>move</strong>关键字 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// println!("{:?}", s); // error: use of moved value: `s`</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-36中的<em>变量绑定s为移动语义类型String。在使用move关键字强制转移所有权之后，变量s已经无法再次被使用了</em>，所以第6行会出错。而闭包c依然是默认不可变的，并且可以进行多次调用。同理，该闭包实现的一定是Fn。那么，move关键字是否只影响捕获自由变量的所有权的转移情况，而不影响闭包本身呢？我们来看一下代码清单6-37。 </p>
<p>代码清单<strong>6-37</strong>：<strong>move</strong>关键字是否影响闭包本身</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> call<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">FnOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 未使用move</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> incr_x <span class="token operator">=</span> <span class="token operator">||</span> x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">call</span><span class="token punctuation">(</span>incr_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// call(incr_x); // ERROR: `incr_x` moved in the call above.</span>
    <span class="token comment" spellcheck="true">// 使用move</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> incr_x <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token operator">||</span> x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">call</span><span class="token punctuation">(</span>incr_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">call</span><span class="token punctuation">(</span>incr_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 对移动语义类型使用move</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> expend_x <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token operator">||</span> x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">call</span><span class="token punctuation">(</span>expend_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// call(expend_x); // ERROR: use of moved value; `expend_x`</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-37定义了call函数，以<strong>FnOnce</strong>（）闭包作为参数，在函数体内执行闭包，该函数主要用于判断闭包自身的所有权是否转移。</p>
<p>代码第4行到第7行定义了闭包incr_x，并未使用move关键字，其捕获变量x为复制语义。将此闭包作为参数传给call函数调用两次，在第二次调用的时候会报错，提示incr_x所有权已经被转移。 </p>
<p>代码第9行到第12行再次定义了闭包incr_x，但是这次使用了move关键字。将其作为参数传给call函数调用两次，均可正常编译执行。 </p>
<p>代码第14行到第17行定义了闭包expend_x，使用了move关键字，其捕获变量x现在为移动语义类型。将其作为参数传给call函数调用两次，第二次调用报错，提示expend_x的所有权已经被转移。 </p>
<p>通过代码清单6-37看得出来，<strong>闭包在使用move关键字的时候，如果捕获变量是复制语义类型的，则闭包会自动实现Copy/Clone；如果捕获变量是移动语义类型的，则闭包不会自动实现Copy/Clone，这也是出于保证内存安全的考虑。</strong></p>
<p><em>修改环境变量以自动实现FnMut，很多时候需要通过修改环境变量的闭包来自动实现FnMut</em>，如代码清单6-38所示。 </p>
<p>代码清单<strong>6-38</strong>：修改环境变量的闭包来自动实现<strong>FnMut</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token string">"rust"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span>s <span class="token operator">+=</span> <span class="token string">" rust"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// error: cannot borrow `s` as immutable</span>
        <span class="token comment" spellcheck="true">//        because it is also borrowed as mutable</span>
        <span class="token comment" spellcheck="true">// println!("{:?}", s);</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-36中的变量绑定s使用mut关键字修改了其可变性，成为了可变绑定。变量s通过第4行的闭包c进行了自我修改，所以闭包c在声明时也使用了mut关键字。如果想修改环境变量，必须实现FnMut。由编译器生成的闭包结构体实例在调用fn_mut方法时，需要&amp;mut self。 </p>
<p>闭包c同样可以调用两次。但是如果在和闭包c同样的作用域中使用s的不可变借用，编译器就会报错，因为s已经被闭包c按可变借用进行了捕获。所以在第9行的println！语句中使用s就会报错。但是在第11行，s依旧可以作为不可变借用，因为之前s的可变借用在离开第10行作用域之后就已经归还了所有权。 </p>
<p>实现了FnMut的闭包，必然会实现FnOnce，但不会实现Fn，如代码清单6-39所示。 </p>
<p>代码清单<strong>6-39</strong>：实现了<strong>FnMut</strong>的闭包的情况</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(fn_tarits)]</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token string">"rust"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> <span class="token operator">||</span> s <span class="token operator">+=</span> <span class="token string">" rust"</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// error: expencted a closure that implements the `Fn` trait,</span>
        <span class="token comment" spellcheck="true">//         but this closure only implements `FnMut`</span>
        <span class="token comment" spellcheck="true">// c.call(());</span>
        c<span class="token punctuation">.</span><span class="token function">call_once</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// error: cannot borrow `s` as immutable</span>
        <span class="token comment" spellcheck="true">//         because it is also borrowed as mutable</span>
        <span class="token comment" spellcheck="true">// println!("{:?}", s);</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "rust rust rust"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-39中，第9行显式地调用call方法时，编译器会报错，并提示该闭包只实现了FnMut。而第10行则可以显式地调用call_once方法。</p>
<p>未捕获任何环境变量的闭包会自动实现<strong>Fn</strong> </p>
<p>没有捕获任何自由变量的闭包，会自动实现Fn，如代码清单6-40所示。</p>
<p>代码清单<strong>6-40</strong>：没有捕获任何环境变量的闭包自动实现<strong>Fn</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-40定义的闭包c没有捕获任何环境变量，并且也没有使用mut关键字改变其可变性，然而可以被多次调用。这足以证明编译器为其自动实现的结构体实例并未失去所有权，只可能是&amp;self。所以，该闭包一定实现了Fn。规则总结 </p>
<p><strong>综合上面的几种情况，可以得出如下规则:</strong></p>
<ol>
<li><strong>如果闭包中没有捕获任何环境变量，则默认自动实现Fn。</strong> </li>
<li><strong>如果闭包中捕获了复制语义类型的环境变量</strong>，则： <ol>
<li>➢ 如果不需要修改环境变量，无论是否使用move关键字，均会自动实现Fn。 </li>
<li>➢ 如果需要修改环境变量，则自动实现FnMut。 </li>
</ol>
</li>
<li><strong>如果闭包中捕获了移动语义类型的环境变量</strong>，则： <ol>
<li>➢ 如果不需要修改环境变量，且没有使用move关键字，则自动实现FnOnce。</li>
<li>➢ 如果不需要修改环境变量，且使用了move关键字，则自动实现Fn。</li>
<li>➢ 如果需要修改环境变量，则自动实现FnMut。 </li>
</ol>
</li>
<li><strong>使用 move 关键字，如果捕获的变量是复制语义类型的，则闭包会自动实现Copy/Clone，否则不会自动实现Copy/Clone。</strong> </li>
</ol>
<p>在日常的开发中，基本可以根据上面的规则对闭包会实现哪个trait做出正确的判断。 </p>
<h3 id="6-2-4-闭包作为函数参数和返回值"><a href="#6-2-4-闭包作为函数参数和返回值" class="headerlink" title="6.2.4 闭包作为函数参数和返回值"></a>6.2.4 闭包作为函数参数和返回值</h3><p>闭包存在于很多语言中，尤其是动态语言，诸如JavaScript、Python和Ruby之类，闭包的使用范围非常广泛。但是在这些动态语言中，闭包捕获的环境变量基本都是对象（此处指面向对象编程语言中的对象，属于引用类型），使用不当容易造成内存泄漏。并且在这些语言中，闭包是在堆中分配的，运行时动态分发，由GC来回收内存，调用和回收闭包都会消耗多余的CPU时间，更不用说使用内联技术来优化这些闭包了。而<strong>Rust使用trait和匿名结构体提供的闭包机制是非常强大的。Rust的闭包实现受到了现代C++的启发，将捕获的变量放到结构体中，这样的好处就是不会占用堆内存，拥有更高的性能，可以使用内联技术来消除函数调用开销并实现其他关键的优化，比如对编译器自动实现的闭包结构体进行优化等。从而允许在任何环境（包括裸机）中使用闭包。</strong></p>
<p><strong>Rust的闭包实现机制使得每个闭包表达式都是一个独立的类型，这样可能有一些不便，比如无法将不同的闭包保存到一个数组中，但是可以通过把闭包当作trait对象来解决这个问题</strong>，如代码清单6-41所示。 </p>
<p>代码清单<strong>6-41</strong>：把闭包作为<strong>trait</strong>对象 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">boxed_closure</span><span class="token punctuation">(</span>c<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Vec<span class="token operator">&lt;</span>Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"second"</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">||</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">move</span><span class="token operator">||</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">||</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"third"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">boxed_closure</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> c <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first / second / third</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-41第8行声明了一个可变闭包，指定类型为Vec＜Box＜Fn（）＞＞，这表示该动态数组中存储的元素类型为Box＜Fn（）＞类型。Box＜Fn（）＞是一个trait对象，把闭包放到Box＜T＞中就可以构建一个闭包的trait对象，然后就可以当作类型来使用。通过第3章的学习可以知道，trait对象是动态分发的，在运行时通过查找虚表（vtable）来确定调用哪个闭包。这里需要注意的是，第 4 行代码中的闭包默认以不可变借用方式捕获了环境变量s，但是这里需要将闭包装箱，稍后在iter_call函数中调用，所以这里必须使用move关键字将s的所有权转移到闭包中，因为变量s是复制语义类型，所以该闭包捕获的是原始变量s的副本。</p>
<p>像这种<strong>在函数boxed_closure调用之后才会使用的闭包，叫作逃逸闭包（escape closure）。因为该闭包捕获的环境变量“逃离”了boxed_closure函数的栈帧，所以在函数栈帧销毁之后依然可用。与之相对应，如果是跟随函数一起调用的闭包，则是非逃逸闭包（non-escape closure）。</strong></p>
<p><strong>(1) 闭包作为函数参数</strong> </p>
<p><strong>闭包可以作为函数参数，这一点直接提升了Rust语言的抽象表达能力</strong>，令其有了完全不弱于Ruby、Python这类动态语言的抽象表达能力。下面比较了Rust和Ruby两种语言中的any方法，该方法用于按指定条件确认数组中的元素是否存在。 </p>
<p>Rust语言： </p>
<pre class="line-numbers language-rust"><code class="language-rust">v<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>x<span class="token operator">|</span> x <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Ruby语言： </p>
<pre class="line-numbers language-ruby"><code class="language-ruby">v<span class="token punctuation">.</span>any<span class="token operator">?</span><span class="token punctuation">{</span>i<span class="token operator">|</span> i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看得出来，Rust语言和Ruby语言中对闭包的用法基本相似。 </p>
<p><strong>因为闭包属于trait语法糖，所以当它被当作参数传递时，它可以被用作泛型的trait限定，也可以直接作为trait对象来使用</strong>。代码清单6-42首先以trait限定的方式实现了一个any方法。</p>
<p>代码清单<strong>6-42</strong>：以<strong>trait</strong>限定的方式实现<strong>any</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Fn<span class="token punctuation">;</span>
<span class="token keyword">trait</span> Any <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> any<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token keyword">where</span>
    Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Any <span class="token keyword">for</span> Vec<span class="token operator">&lt;</span>u32<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> any<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token keyword">where</span>
    Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token operator">&amp;</span>x <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-42中，第1行的use语句是可有可无的，因为Fn并不受trait孤儿规则的限制。从第 2 行开始定义了一个 trait，将其命名为 Any。需要注意的是，此处自定义的Any不同于标准库提供的Any。该trait中声明了泛型函数any，该函数泛型F的trait限定为Fn（u32）-＞bool，这种形式更像函数指针类型，有别于一般的泛型限定＜F：Fn＜ u32，bool＞＞。其实函数指针也是默认实现了Fn、FnMut、FnOnce这三个triat的，比如代码清单6-43就展示了函数指针作为闭包参数的情况。</p>
<p>代码清单<strong>6-43</strong>：函数指针也可以作为闭包参数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> call<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 
<span class="token keyword">where</span> F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32
<span class="token punctuation">{</span>
    <span class="token function">closure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">counter</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">call</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-43第8行中，<em>函数指针当作闭包参数传入了call函数，代码正常编译运行。这是因为此函数指针counter也实现了Fn</em>。</p>
<p>回到代码清单6-42，第3行的where从句对Self做了Sized限定，这意味着，当Any被作为trait对象使用时，该方法不能被动态调用，这属于一种优化策略。 </p>
<p>代码清单6-42的第7行使用impl关键字为Vec＜u32＞类型实现了any方法。该方法会迭代传入的闭包，依次调用，如果满足闭包表达式中指定的条件，则返回true，否则返回false。 </p>
<p>在main函数中，则可以使用形如代码清单6-42第22行那样的形式来调用any方法，以查找动态数组v中是否存在满足条件的元素。<strong>像这样通过将闭包作为参数，可以把一段动态的逻辑按需传入指定方法中进行计算，这极大地提高了程序的灵活性和抽象能力。最重要的是，在Rust中使用闭包，完全不需要担心性能问题。</strong> </p>
<p><strong>除了上述静态分发的形式，也可以将闭包作为trait对象动态分发</strong>，如代码清单6-44所示。代码清单<strong>6-44</strong>：将闭包作为<strong>trait</strong>对象进行动态分发</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">trait</span> Any <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Any <span class="token keyword">for</span> Vec<span class="token operator">&lt;</span>u32<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token operator">&amp;</span>x <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-44将闭包作为了trait对象，这样代码更加简练。动态分发比静态分发的性能低一些，但还是完全可以和 C++媲美的。<strong>动态分发闭包在实际中更加常用于回调函数（callback）</strong>。 </p>
<p>比如Rust的Web开发框架Rocket的中间件实现，就利用了闭包作为回调函数，其实现如代码清单6-45所示。 </p>
<p>代码清单<strong>6-45</strong>：<strong>Rocket</strong>框架中间件代码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> AdHoc <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span>
    kind<span class="token punctuation">:</span> AdHocKind<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">enum</span> AdHocKind <span class="token punctuation">{</span>
    <span class="token punctuation">...</span>
    <span class="token attribute attr-name">#[doc(hidden)]</span>
    <span class="token function">Request</span><span class="token punctuation">(</span>Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> Request<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Data<span class="token punctuation">)</span> <span class="token operator">+</span> Send <span class="token operator">+</span> Sync <span class="token operator">+</span> '<span class="token keyword">static</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> AdHoc <span class="token punctuation">{</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> on_request<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> AdHoc
        <span class="token keyword">where</span> F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> Request<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Data<span class="token punctuation">)</span> <span class="token operator">+</span> Send <span class="token operator">+</span> Sync <span class="token operator">+</span> '<span class="token keyword">static</span>
        <span class="token punctuation">{</span>
            AdHoc<span class="token punctuation">{</span>name<span class="token punctuation">,</span> kind<span class="token punctuation">:</span> AdHocKind<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Request</span><span class="token punctuation">(</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Fairing <span class="token keyword">for</span> AdHoc <span class="token punctuation">{</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> <span class="token function">on_request</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> request<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Request<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> AdHocKind<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Request</span><span class="token punctuation">(</span><span class="token keyword">ref</span> callback<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>kind <span class="token punctuation">{</span>
            <span class="token function">callback</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-45展示了Rocket框架中间件Fairing实现的简单示意，为了突出重点，这里省略了很多代码。 </p>
<p>代码第1行定义了AdHoc结构体，接下来定义AdHocKind枚举体，其中包含了四种枚举值（Attach、Launch、Request、Response），本示例中只显示出Request一种，它包含的值类型是一个trait对象的闭包，Box＜Fn（&amp;mut Request，&amp;Data）+Send+Sync+＇static＞。 </p>
<p>代码第13行为AdHoc结构体实现了on_request方法，其参数为一个闭包F，该闭包的trait限定为Fn（&amp;mut Request，&amp;Data）+Send+Sync+＇static，表明该闭包接收两个参数，第一个是可变引用，第二个是不可变引用，并且是可以在线程中安全传递的，＇<strong>static</strong> 生命周期用来约束该闭包必须是一个逃逸闭包，只有逃逸闭包才能装箱，代码清单6-46的示例展示了这一点。 </p>
<p>代码清单<strong>6-46</strong>：测试＇<strong>static</strong>约束 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> '<span class="token keyword">static</span><span class="token operator">></span> <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">move</span><span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span><span class="token punctuation">{</span>s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果对代码清单6-46第3行的闭包去掉move关键字，则变为Fn闭包，会以不可变引用方式来捕获变量绑定s，因为有了＇<strong>static</strong>约束，编译器会报错。现在使用了move关键字，会强制执行复制语义，则编译通过。</p>
<p>回到代码清单 6-45 中，从第 21 行代码开始，为 AdHoc 实现了 Fairing trait 中定义的on_request方法，该方法内部使用了if let，如果匹配到相关的闭包，则调用该闭包。这是动态分发的闭包在实际中作为回调函数的示例。 </p>
<p><strong>(2) 闭包作为函数返回值</strong> </p>
<p>因为闭包是trait语法糖，所以无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用trait对象，如代码清单6-47所示。 </p>
<p>代码清单<strong>6-47</strong>：将闭包作为函数返回值 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">|</span>i<span class="token operator">|</span> i <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-47返回一个闭包来计算平方。返回的闭包为trait对象Box＜Fn（i32）-＞i32＞，在main函数中可以直接调用它。代码清单 6-47 中的闭包指定为 Fn，可以多次调用，但是如果希望只调用一次，那么是不是就可以直接指定FnOnce呢？如代码清单6-48所示。</p>
<p>代码清单<strong>6-48</strong>：指定返回闭包为<strong>FnOnce</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Box<span class="token operator">&lt;</span><span class="token function">FnOnce</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token operator">></span> <span class="token punctuation">{</span>
    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span>i<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 编译会报如下错误：</span>
error<span class="token punctuation">[</span>E0161<span class="token punctuation">]</span><span class="token punctuation">:</span> cannot <span class="token keyword">move</span> a value of <span class="token keyword">type</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">FnOnce</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 the size of std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">FnOnce</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 cannot <span class="token keyword">be</span> statically determined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该错误的含义是：对于编译期无法确定大小的值，不能移动其所有权。在代码清单6-48中，如果要调用闭包Box＜FnOnce（i32）-＞i32＞，就必须先把FnOnce（i32）-＞i32从Box＜T＞中移出来。而此时Box ＜T＞中的T无法在编译期确定大小，不能移动所有权，所以就报出了上述错误。 </p>
<p>FnOnce 装箱为 Box＜FnOnce＞之后，其对应的由编译器生成的闭包结构体实例就是Box＜ClosureStruct＞类型（假如闭包结构体名为ClosureStruct），该闭包结构体实现FnOnce的call_once方法的接收者本来是self，也就是闭包结构体实例，现在变成了Box＜self＞，也就是装箱的闭包结构体实例。现在想从Box＜self＞里移出self这个闭包结构体实例来进行调用，因为编译期无法确定其大小，所以无法获取self。而对于Fn和FnMut来说，装箱以后分别对应的是&amp;Box＜self＞和&amp;mut Box＜self＞，所以不会报错。对于此问题，Rust给出了一个解决方案，如代码清单6-49所示。 </p>
<p>代码清单<strong>6-49</strong>：使用<strong>FnBox</strong>代替<strong>FnOnce</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(fnbox)]</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>boxed<span class="token punctuation">:</span><span class="token punctuation">:</span>FnBox<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Box<span class="token operator">&lt;</span><span class="token function">FnBox</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token operator">></span> <span class="token punctuation">{</span>
    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span>i<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-49第1行<strong>使用了＃！[feature（fnbox）]特性，同时也需要使用use来引入定义于标准库的boxed模块中的FnBox trait。只需要简单地把FnOnce替换为FnBox，即可解决上面编译错误的问题</strong>。这是因为FnBox施加了一点小小的“魔法”，代码清单6-50展示了FnBox的源码。 </p>
<p>代码清单<strong>6-50</strong>：<strong>FnBox</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[rustc_paren_sugar]</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> FnBox<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">call_box</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>Self<span class="token operator">></span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>A<span class="token punctuation">,</span> F<span class="token operator">></span> FnBox<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token keyword">for</span> F
    <span class="token keyword">where</span> F<span class="token punctuation">:</span> FnOnce<span class="token operator">&lt;</span>A<span class="token operator">></span>
    <span class="token punctuation">{</span>
        <span class="token keyword">type</span> Output <span class="token operator">=</span> F<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span>
        <span class="token keyword">fn</span> <span class="token function">call_box</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">-></span> F<span class="token punctuation">:</span><span class="token punctuation">:</span>Output <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">call_once</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a, A, R> FnOnce&lt;A> for Box&lt;FnBox&lt;A, Output = R> + '</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> R<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_once</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">-></span> R <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">call_box</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于篇幅限制，代码清单6-50只展示了部分FnBox源码。看得出来，FnBox也是一个调用语法糖，因为使用了<strong>＃[rustc_paren_sugar]属性，该trait实现了call_box方法，第一个参数和之前的Fn、FnMut、FnOnce定义的方法有很大不同，该方法的第一个参数self是Box＜Self＞类型</strong>。其实之前trait中的self、&amp;self、&amp;mut self参数都是一种省略形式，其完整形式如下所示。 </p>
<ul>
<li>Self对应self：Self。 </li>
<li>&amp;self 对应 self：&amp;Self。 </li>
<li>&amp;mut self对应 self：&amp;mut Self。 </li>
</ul>
<p>理论上，self：SomeType＜Self＞这种形式应该适用于任意类型（SomeType），但实际上，这里只支持Box＜T＞。所以，self：Box＜Self＞这种类型指定会自动解引用并移动Self的所有权，因为Box＜T＞支持DerefMove（参见第5章）。 </p>
<p>Self：Box＜self＞是通过调用 call_box 来间接调用 call_once 的，因为 Box＜FnBox＞实现了FnOnce。这看上去完全是一个“曲线救国”的方案，所以，在装箱时使用FnBox来替代FnOnce只是临时的解决方案，在未来的Rust版本中，FnBox会被弃用。 </p>
<p>出现这种问题的根本原因在于，Rust中的函数返回值里只能出现类型。虽然有trait对象可用，但是性能上也会有所消耗。为了解决此问题，Rust团队提出了一个新的方案，叫<strong>impl Trait</strong>语法，该方案可以让函数直接返回一个trait，如代码清单6-51所示。 </p>
<p>代码清单<strong>6-51</strong>：<strong>impl Trait</strong>示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">impl</span> <span class="token function">FnOnce</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
    <span class="token closure-params"><span class="token punctuation">|</span>i<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>i <span class="token operator">*</span> i<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-51中用到的<strong>impl Trait</strong>语法是Rust 2018版本中引入的。<strong>impl Trait</strong>代表的是实现了指定trait的那些类型，相当于泛型，属于静态分发。 </p>
<p>代码第2行直接返回一个impl FnOnce（u8，u8）-＞u8。在impl关键字后面加上了闭包trait，这样就可以直接返回一个FnOnce trait。</p>
<h3 id="6-2-5-高阶生命周期"><a href="#6-2-5-高阶生命周期" class="headerlink" title="6.2.5 高阶生命周期"></a>6.2.5 高阶生命周期</h3><p>闭包可以作为函数的参数和返回值，那么闭包参数中如果含有引用的话，其生命周期参数该如何标注？先来思考代码清单6-52。 </p>
<p>代码清单<strong>6-52</strong>：泛型<strong>trait</strong>作为<strong>trait</strong>对象时的生命周期参数 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token punctuation">;</span>
<span class="token keyword">trait</span> DoSomething<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> valut<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a, T: Debug> DoSomething&lt;T> for &amp;'</span>a usize <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> foo<span class="token operator">&lt;</span><span class="token string">'a>(b: Box&lt;DoSomething&lt;&amp;'</span>a usize<span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s<span class="token punctuation">:</span> usize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>2usize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-52定义了DoSomething＜T＞，它是一个泛型trait，其中定义了方法签名do_sth，然后为&amp;usize类型实现了该trait。 </p>
<p>代码第 10 行到第 13 行定义了一个函数 foo，其参数 b 以 trait 对象Box＜DoSomething＜&amp;usize＞＞为类型。在该函数内，参数b调用do_sth方法，并把局部变量绑定s的不可变借用作为do_sth方法的参数。整个函数foo也被标注了生命周期参数。在main函数中声明了一个Box＜&amp;usize＞变量绑定x，并调用foo（x）。整段代码在编译时会报如下错误： </p>
<pre><code>error[E0597]: `s` does not live long enough
12 |     b.do_sth(&amp;s)
   |               ^ does not live long enough
13 |     }
   |     - borrowed value only lives untill here</code></pre><p>该错误表明，s的生命周期不够长，在foo函数调用结束后就会被析构，从而&amp;s就会变成悬垂指针，这是Rust绝不可能允许出现的情况，如图6-3所示。 </p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503150624262.png" alt="image-20210503150624262"></p>
<p>代码清单6-52第10行的foo函数签名中的生命周期参数有什么问题呢？现在这样的生命周期参数的意义是，把foo函数自身的生命周期和其内部的局部变量绑定s的生命周期关联了起来，这就要求，foo函数内b.do_sth（&amp;s）方法调用参数s的生命周期必须长于main函数中foo（x）函数调用的生命周期。在main函数中会自动产生临时变量绑定，代码第16行相当于let_3=foo（x）。这违反了第5章学过的借用规则，有产生悬垂指针的风险。 </p>
<p>然而，foo函数中传入的trait对象Box＜DoSomething＜&amp;usize＞＞包含的&amp;usize引用是从外部引入的，如代码清单6-52第15行所示，是在main函数中直接定义好，然后才传给foo函数的。所以，该引用的生命周期和foo函数没有直接关系。目前代码清单6-52的生命周期参数标记则完全无法正确表达这一层意思，那么对于这种情况该如何定义生命周期参数呢？</p>
<p>Rust为此专门提供了一个方案，叫作<strong>高阶生命周期（Higher-Ranked Lifetime），也叫高阶trait限定（Higher-Ranked Trait Bound，HRTB）。该方案提供了一个for＜＞语法</strong>，具体使用方式如代码清单6-53所示。 </p>
<p>代码清单<strong>6-53</strong>：使用<strong>for</strong>＜＞语法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token punctuation">;</span>
<span class="token keyword">trait</span> DoSomething<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a, T: Debug> DoSomething&lt;T> for &amp;'</span>a usize <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">.</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">bar</span><span class="token punctuation">(</span>b<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span><span class="token keyword">for</span><span class="token operator">&lt;</span><span class="token string">'f> DoSomething&lt;&amp;'</span>f unsize<span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s<span class="token punctuation">:</span> usize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>2usize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-53第10行定义了bar函数，其函数签名中的生命周期参数使用了<strong>高阶生命周期参数for＜＇f＞DoSomething＜&amp;＇f usize＞，这样就修复了生命周期的问题</strong>，正常编译运行。 </p>
<p><strong>for＜＞语法整体表示此生命周期参数只针对其后面所跟着的“对象”，在本例中是DoSomething＜&amp;＇f usize＞，生命周期参数＇f是在for＜＇f ＞中声明的。使用for＜＇f ＞语法，就代表bar函数的生命周期和DoSomething＜&amp;＇f usize＞没有直接关系</strong>，所以编译正常。 </p>
<p>实际开发中会经常用闭包，而闭包实现的三个trait本身也是泛型trait，所以肯定也存在闭包参数和返回值都是引用类型的情况，如代码清单6-54所示。 </p>
<p>代码清单<strong>6-54</strong>：闭包参数和返回值都是引用类型的情况</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> Pick<span class="token operator">&lt;</span>F<span class="token operator">></span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">,</span>
    func<span class="token punctuation">:</span> F<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>F<span class="token operator">></span> Pick<span class="token operator">&lt;</span>F<span class="token operator">></span>
<span class="token keyword">where</span> F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>u32
<span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>u32 <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">max</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>u32 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> data<span class="token number">.0</span> <span class="token operator">></span> data<span class="token number">.1</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span>data<span class="token number">.0</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span>data<span class="token number">.1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> elm <span class="token operator">=</span> Pick <span class="token punctuation">{</span>data<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func<span class="token punctuation">:</span> max<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> elm<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-54中，泛型结构体Pick模拟了闭包的行为，字段data使用元组类型存储模拟闭包的参数，字段func用来存储一个可执行的闭包。</p>
<p>代码第5行到第11行为结构体Pick实现了一个call方法，泛型F使用Fn（&amp;（u32，u32））-＞&amp;u32作为trait限定。整段代码编译正常运行。 </p>
<p>值得注意的是，此处的trait限定中使用了引用类型，但是并没有显式地标记生命周期参数，为什么可以正常编译呢？这是因为编译器自动为其补齐了生命周期参数。</p>
<p>代码第9行会调用存储于结构体Pick中的闭包，并且会把call方法中的&amp;self作为参数进行传递。这个调用与代码清单6-52和6-53中所示的情况很相似，如果要显式地添加生命周期参数，则不能让call方法自身的生命周期和self.func方法的生命周期相关联，因为闭包的捕获引用是从外部环境获取的，和call方法没有关系。否则编译肯定无法通过，比如像下面这种写法就会产生编译错误： </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> call<span class="token operator">&lt;</span><span class="token string">'a>(&amp;'</span>a <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>'a u32 <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>所以这里正确地使用生命周期参数的方式就是用高阶生命周期，如代码清单6-55所示。 </p>
<p>代码清单<strong>6-55</strong>：编译器按高阶生命周期来自动补齐闭包参数中的生命周期参数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> Pick<span class="token operator">&lt;</span>F<span class="token operator">></span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">,</span>
    func<span class="token punctuation">:</span> F<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>F<span class="token operator">></span> Pick<span class="token operator">&lt;</span>F<span class="token operator">></span>
<span class="token keyword">where</span> F<span class="token punctuation">:</span> <span class="token keyword">for</span><span class="token operator">&lt;</span><span class="token string">'F> Fn(&amp;'</span><span class="token function">f</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>'f u32<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 显示指定</span>
<span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>u32 <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">max</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>u32 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> data<span class="token number">.0</span> <span class="token operator">></span> data<span class="token number">.1</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span>data<span class="token number">.0</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span>data<span class="token number">.1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> elm <span class="token operator">=</span> Pick <span class="token punctuation">{</span>data<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func<span class="token punctuation">:</span> max<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> elm<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-55第6行使用了高阶生命周期，代码正常编译运行。但需要注意的是，<strong>高阶生命周期的这种for＜＞语法只能用于标注生命周期参数，而不能用于其他泛型类型</strong>。</p>
<h2 id="6-3-迭代器"><a href="#6-3-迭代器" class="headerlink" title="6.3 迭代器"></a>6.3 迭代器</h2><p><strong>在Rust语言中，闭包最常见的应用场景是，在遍历集合容器中的元素的同时，按闭包内指定的逻辑进行操作</strong>。比如代码清单6-42中实现的any方法，就利用了for循环来迭代动态数组，依次查找符合闭包指定条件的元素。 </p>
<p><strong>用循环语句迭代数据时，必须使用一个变量来记录数据集合中每一次迭代所在的位置，而在许多编程语言中，已经开始通过模式化的方式来返回迭代过程中集合的每一个元素。这种模式化的方式就叫迭代器（Iterator）模式，使用迭代器可以极大地简化数据操作。迭代器设计模式也被称为游标（Cursor）模式，它提供了一种方法，可以顺序访问一个集合容器中的元素，而又不需要暴露该容器的内部结构和实现细节</strong>。 </p>
<h3 id="6-3-1-外部迭代器和内部迭代器"><a href="#6-3-1-外部迭代器和内部迭代器" class="headerlink" title="6.3.1 外部迭代器和内部迭代器"></a>6.3.1 外部迭代器和内部迭代器</h3><p><strong>迭代器分为两种，外部迭代器（External Iterator）和内部迭代器（Internal Iterator）。</strong> </p>
<p><strong>外部迭代器也叫主动迭代器（Active Iterator），它独立于容器之外，通过容器提供的方法（比如，next方法就是所谓的游标）来迭代下一个元素，并需要考虑容器内可迭代的剩余数量来进行迭代。外部迭代器的一个重要特点是，外部可以控制整个遍历进程。</strong>比如Python、Java和C++语言中的迭代器，就是外部迭代器。 </p>
<p><strong>内部迭代器则通过迭代器自身来控制迭代下一个元素，外部无法干预。这意味着，只要调用了内部迭代器，并通过闭包传入了相关操作，就必须等待迭代器依次为其中的每个元素执行完相关操作以后才可以停止遍历。</strong>比如Ruby语言中的each迭代器就是典型的内部迭代器。 </p>
<p>早期的（1.0版本之前）Rust提供的是内部迭代器，而内部迭代器无法通过外部控制迭代进程，再加上Rust的所有权系统，导致使用起来很复杂。</p>
<p>代码清单6-56展示了一个自定义的内部迭代器。</p>
<p>代码清单<strong>6-56</strong>：自定义的内部迭代器 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">trait</span> InIterator<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Copy<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> each<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Copy<span class="token operator">></span> InIterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">for</span> Vec<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> each<span class="token operator">&lt;</span>F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token operator">|</span>i<span class="token operator">|</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-56创建了一个自定义的内部迭代器each。看得出来，内部迭代器与容器的绑定较紧密，并且无法从外部来控制其遍历进程。更重要的是，对于开发者来说，扩展性较差。Rust官方和社区经过很长时间的论证，决定改为外部迭代器，也就是for循环，如代码清单6-57所示。</p>
<p>代码清单<strong>6-57</strong>：<strong>for</strong>循环示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> v <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-57是一个简单的for循环示例。<strong>for循环是一个典型的外部迭代器，通过它可以遍历动态数组v中的元素，并且此遍历过程完全可以在动态数组v之外进行控制。Rust中的for循环其实是一个语法糖。</strong>代码清单6-58展示了for循环展开后的等价代码。 </p>
<p>代码清单<strong>6-58</strong>：<strong>for</strong>循环展开后的等价代码 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 等价于for循环的scope</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> _iterator <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">loop</span> <span class="token punctuation">{</span>
            <span class="token keyword">match</span> _iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
                    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                None <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">break</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-58从第3行开始，创造了一个内部作用域，等价于for循环的作用域。代码第4行通过调用v的into_iter方法声明了一个可变迭代器_iterator。在第5行的loop循环中，通过match匹配此迭代器的next方法，遍历v中的元素，直到next方法返回None，退出循环，遍历结束。 </p>
<h3 id="6-3-2-Iterator-trait"><a href="#6-3-2-Iterator-trait" class="headerlink" title="6.3.2 Iterator trait"></a>6.3.2 Iterator trait</h3><p>简单来说，<strong>for循环就是利用迭代器模式实现的一个语法糖，它属于外部迭代器</strong>。迭代器也是Rust一致性的典型表现之一。不出所料，<strong>Rust 中依然使用了trait来抽象迭代器模式</strong>。代码清单6-59展示了Rust中迭代器Iterator trait的源码。 </p>
<p>代码清单<strong>6-59</strong>：<strong>Iterator trait</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-59展示了Iterator trait是Rust中对迭代器模式的抽象接口。其中next方法是实现一个迭代器时必须实现的方法。事实上，该trait中包含了很多其他方法，基本都包含了默认实现。该trait中还包含了一个关联类型Item，并且next方法会返回Option＜Self：：Item＞类型。Item和Self可以看作占位类型，它们表示实现该trait的具体类型的相关信息。</p>
<p>通过实现该trait，可以创建自定义的迭代器，如代码清单6-60所示。</p>
<p>代码清单<strong>6-60</strong>：通过实现<strong>Iterator trait</strong>创建自定义迭代器</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> Counter <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Iterator <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item <span class="token operator">=</span> usize<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>usize<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">6</span> <span class="token punctuation">{</span>
            <span class="token function">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            None
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> counter <span class="token operator">=</span> Counter <span class="token punctuation">{</span>count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>None<span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-60中定义了一个结构体Counter，为其实现Iterator之后，它就成为了一个迭代器。通过调用next方法来迭代其内部元素。 </p>
<p>值得注意的是，在为Counter实现next方法时，指定了关联类型Item为usize类型，因为Counter中字段count是usize类型，next方法要返回的是Option＜usize＞类型。 </p>
<p>代码第8行，next方法的if表达式中的条件被硬编码为小于6，这只是为了演示。对于一个真正的迭代器，除了需要使用next方法获取下一个元素，还需要知道迭代器的长度信息，这对于优化迭代器很有帮助。 </p>
<p>在Iterator trait中还提供了一个方法叫<strong>size_hint</strong>，代码清单6-61展示了其默认实现。 </p>
<p>代码清单<strong>6-61</strong>：<strong>Iterator trait</strong>提供的<strong>size_hint</strong>方法源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> <span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>usize<span class="token punctuation">,</span> Option<span class="token operator">&lt;</span>usize<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 6-61 展示了 size_hint 方法的默认实现，其返回类型是一个元组（usize，Option＜usize＞），此元组表示迭代器剩余长度的边界信息。元组中第一个元素表示下限（lower bound），第二个元素表示上限（upper bound）。第二个元素是Option＜usize＞类型，代表已知上限 或者上限超过usize的最大取值范围，比如无穷迭代。此方法的默认返回 值（0，None）适用于任何迭代器。 </p>
<p>代码清单6-62展示了将数组转换为迭代器的size_hint方法。 </p>
<p>代码清单<strong>6-62</strong>：将数组转换为迭代器的<strong>size_hint</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-62中的数组通过iter方法转换成为一个迭代器，每次调用next方法，迭代器的剩余长度就会减少，直到减为0为止。方法size_hint返回的元组上限和下限是一致的。第3行方法调用a.iter（）使用了数组a的不可变借用，其类型为&amp;＇a [i32；3]。对于&amp;＇a [T]和&amp;＇a mut [T] 类型，size_hint方法实际返回的是迭代器起点指针到终点指针的距离值，如图6-4所示。 </p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503155939010.png" alt="image-20210503155939010"></p>
<p>第3行方法调用a.iter（）返回的迭代器是一个结构体，其成员包含了起始指针ptr和终点指针end，它们之间的距离就是size_hint方法返回的 值。</p>
<p>方法size_hint的目的就是优化迭代器，不要忘记Rust是一门系统级编程语言，性能永远是一项重要的指标。迭代器和集合容器几乎形影不离，<strong>实际开发中经常有使用迭代器来扩展集合容器的需求，此时方法size_hint就派上用场了。如果事先知道准确的迭代器长度，就可以做到精准地扩展容器容量，从而避免不必要的容量检查，提高性能</strong>。代码清单6-63展示了如何使用迭代器来追加字符串。</p>
<p>代码清单<strong>6-63</strong>：使用迭代器来追加字符串 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> message <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    message<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'R'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"Hello Rust"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-63中声明了String类型的字符串message，通过调用extend方法为其追加字符。事实上，extend方法是被定义于Extend trait中的。代码清单6-64展示了Extend和String中实现extend方法的源码。 </p>
<p>代码清单<strong>6-64</strong>：<strong>Extend</strong>和<strong>String</strong>类型实现<strong>extend</strong>方法的源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Extend<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> extend<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> iter<span class="token punctuation">:</span> T<span class="token punctuation">)</span>
    <span class="token keyword">where</span>
    T<span class="token punctuation">:</span> IntoIterator<span class="token operator">&lt;</span>Item <span class="token operator">=</span> A<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">...</span>
<span class="token keyword">impl</span> Extend<span class="token operator">&lt;</span>char<span class="token operator">></span> <span class="token keyword">for</span> String <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> extend<span class="token operator">&lt;</span>I<span class="token punctuation">:</span> IntoIterator<span class="token operator">&lt;</span>Item <span class="token operator">=</span> char<span class="token operator">>></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> iter<span class="token punctuation">:</span> I<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> iterator <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>lower_bound<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>lower_bound<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> ch <span class="token keyword">in</span> iterator <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Extend trait是一个泛型trait，其中定义了extend方法，这是一个泛型方法，<em>其泛型参数T使用了trait限定IntoIterator＜Item=A＞，这表示该泛型方法只接受实现了IntoIterator的类型。而String类型正好针对char类型实现了该泛型trait。</em> </p>
<p>在代码第9行String类型实现的extend方法中，首先使用into_iter方法获取了一个迭代器，然后通过迭代器的size_hint方法获取其长度，代码第10 行取的是迭代器的下限。对于数组来说，上限和下限的值是一样的，所以这里取哪个都可以。 </p>
<p>代码第11行调用了字符串的reserve方法，该方法可以确保扩展的字节长度大于或等于给定的值。这样做是为了避免频繁分配。代码清单6-63中给定的迭代器长度应该是5，那么为字符串分配的额外空间至少应该是20个字节（因为每个字符占4字节），也可能是100个字节。reserve方法只是提供了一种保证，它并不做出分配空间的行为。 </p>
<p>代码第12行用for循环遍历该字符迭代器，之后通过String类型的push方法逐个添加给字符串。 </p>
<p><strong>现在可以看得出来size_hint方法的重要性了。为了确保该方法可以获得迭代器长度的准确信息，Rust又引入了两个trait，分别是ExactSizeIterator和TrustedLen，它们均是Iterator的子trait，均被定义于std：：iter模块中。</strong> </p>
<ul>
<li>ExactSizeIterator提供了两个额外的方法len和is_empty，要实现len必须先实现Iterator，这就要求size_hint方法必须提供准确的迭代器长度信息。</li>
<li>TrustedLen是实验性trait，还未正式公开，但是在Rust源码内部，它就像一个标签trait，只要实现了 TrustedLen 的迭代器，其 size_hint 获取的长度信息均是可信任的，有了该 trait就完全避免了容器的容量检查，从而提升了性能。 </li>
</ul>
<p>ExactSizeIterator和TrustedLen的区别在于，后者应用于没有实现ExactSizeIterator的大多数情况。开发者可以根据具体的情况自定义实现ExactSizeIterator，但是对于某些迭代器，开发者并不能为其实现ExactSizeIterator，所以需要TrustedLen做进一步的限定。 </p>
<h3 id="6-3-3-IntoIterator-trait和迭代器"><a href="#6-3-3-IntoIterator-trait和迭代器" class="headerlink" title="6.3.3 IntoIterator trait和迭代器"></a>6.3.3 IntoIterator trait和迭代器</h3><p>上一节介绍了Iterator trait，我们了解到，如果想迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用。并且在 for 循环语法糖中，也使用了 into_iter 之类的方法来获取一个迭代器。那么迭代器到底是什么？要寻找答案，必须先从IntoIterator trait开始。 </p>
<p>第3章讲过类型转换用到的From和Into两个trait，它们定义了两个方法，分别是from和 into，这两个方法互为反操作。对于迭代器来说，并没有用到这两个 trait，但是这里值得注意的是，<strong>Rust中对于trait的命名也是具有高度一致性的</strong>。 </p>
<p><strong>Rust也提供了FromIterator和IntoIterator两个trait，它们也互为反操作。FromIterator可以从迭代器转换为指定类型，而 IntoIterator 可以从指定类型转换为迭代器。</strong>关于FromIterator的细节在6.3.5节会着重介绍，这里先介绍IntoIterator。 </p>
<p>代码清单6-65展示了IntoIterator的源码。 </p>
<p>代码清单<strong>6-65</strong>：<strong>IntoIterator</strong>源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> IntoIterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token keyword">type</span> IntoIter<span class="token punctuation">:</span> Iterator<span class="token operator">&lt;</span>Item <span class="token operator">=</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>IntoIter<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从代码清单6-65中可以看出，方法into_iter是在该trait中定义的。into_iter的参数是self，代表该方法会转移方法接收者的所有权。同时，该方法会返回Self：：IntoIter类型。<strong>Self：：IntoIter是关联类型，并且指定了trait限定Iterator＜Item=Self：：Item＞，意味着必须是实现了Iterator的类型才能作为迭代器</strong>。 </p>
<p><strong>最常用的集合容器就是Vec＜T＞类型，它实现了IntoIterator，可以通过into_iter方法转换为迭代器</strong>。代码清单6-66展示了Vec＜T＞类型实现IntoIterator的源码。 </p>
<p>代码清单<strong>6-66</strong>：<strong>Vec</strong>＜<strong>T</strong>＞实现<strong>IntoIterator</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> IntoIterator <span class="token keyword">for</span> Vec<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">type</span> IntoIter <span class="token operator">=</span> IntoIter<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> IntoIter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token punctuation">...</span>
            IntoIter <span class="token punctuation">{</span>
                buf<span class="token punctuation">:</span> Shared<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new_unchecked</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">,</span>
                cap<span class="token punctuation">,</span>
                ptr<span class="token punctuation">:</span> begin<span class="token punctuation">,</span>
                end<span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 6-66 为了演示方便只展示了部分源码。看得出来，最终返回的是一个定义于std：：vec模块中的IntoIter结构体。该结构体包含下列四个成员字段。 </p>
<ul>
<li><strong>Buf</strong>，通过Vec＜T＞类型的动态数组起始地址begin生成一个内部使用的Shared指针，指向该动态数组中实际存储的数据。 </li>
<li><strong>Cap</strong>，获得该动态数组的容量大小，也就是内存占用大小。 </li>
<li><strong>Ptr</strong>，指定了begin的值，代表迭代器的起始指针。 </li>
<li><strong>End</strong>，代表迭代器的终点指针，根据Vec＜T＞动态数组的长度len和起始地址begin计算offset获得。 </li>
</ul>
<p>IntoIter结构体也实现了Iterator trait，拥有了next、size_hint和count三个方法，它是一个名副其实的迭代器。 </p>
<p>简单而言，<strong>就是Vec＜T＞实现了IntoIterator，因此可以通过into_iter方法将一个Vec＜T＞类型的动态数组转换为一个IntoIter结构体。IntoIter结构体拥有该动态数组的全部信息，并且获得了该动态数组的所有权。同时，IntoIter结构体实现了Iterator trait，允许其通过next、size_hint和count方法对其进行迭代处理。</strong>所以，IntoIter就是Vec＜T＞转换而成的迭代器。整个过程如图6-5所示。</p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503164116049.png" alt="image-20210503164116049"></p>
<p><strong>转换 IntoIter 迭代器的代价是要转移容器的所有权</strong>，在实际开发中，有很多情况是不能转移所有权的。因此，<strong>Rust 还提供了另外两个迭代器专门处理这种情况，分别是 Iter 和IterMut。这三种迭代器类型和所有权有如下对应关系</strong>。 </p>
<ul>
<li><strong>IntoIter</strong>，转移所有权，对应self。 </li>
<li><strong>Iter</strong>，获得不可变借用，对应&amp;self。 </li>
<li><strong>IterMut</strong>，获得可变借用，对应&amp;mut self。 </li>
</ul>
<p><strong>Iter和IterMut迭代器的典型应用就是slice类型</strong>，代码清单6-67展示了slice类型数组的循环示例。 </p>
<p>代码清单<strong>6-67</strong>：<strong>slice</strong>类型数组循环示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-67中声明了slice类型的数组，该类型的数组使用for循环时，并不能自动转换为迭代器，因为并没有为[T]类型实现IntoIterator， 而只是为&amp;＇a [T]和&amp;＇a mut [T]类型实现了IntoIterator，相应的into_iter方法内部实际也分别调用了iter和iter_mut方法。也就是说，在for循环中使用&amp;arr可以自动转换为迭代器，而无须显式地调用iter方法。<strong>用iter或iter_mut方法可以将slice类型的数组转换为Iter或IterMut迭代器</strong>。</p>
<p>代码清单6-68展示了迭代器Iter的源码。 </p>
<p>代码清单<strong>6-68</strong>：<strong>Iter</strong>迭代器的源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> Iter<span class="token operator">&lt;</span><span class="token string">'a, T: '</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> T<span class="token punctuation">,</span>
    end<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> T<span class="token punctuation">,</span>
    _marker<span class="token punctuation">:</span> marker<span class="token punctuation">:</span><span class="token punctuation">:</span>PhantomData<span class="token operator">&lt;</span><span class="token operator">&amp;</span>'a T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看得出来，迭代器Iter中只包含ptr和end指针，均为不可变的裸指针*const T，用于计算迭代器的长度，而_marker字段只是编译期标记，是为了让生命周期参数＇a有用武之地，通过编译。关于PhantomData的更多内容会在第13章中详细介绍。 </p>
<p><strong>Iter 迭代器也被称为不可变迭代器，因为它不能改变原来容器中的数据。</strong>代码清单 6-69展示了可变迭代器IterMut的源码。 </p>
<p>代码清单<strong>6-69</strong>：<strong>IterMut</strong>迭代器源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> IterMut<span class="token operator">&lt;</span><span class="token string">'a, T: '</span>a<span class="token operator">></span> <span class="token punctuation">{</span>
    ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> T<span class="token punctuation">,</span>
    end<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> T<span class="token punctuation">,</span>
    _marker<span class="token punctuation">:</span> marker<span class="token punctuation">:</span><span class="token punctuation">:</span>PhantomData<span class="token operator">&lt;</span><span class="token operator">&amp;</span>'a <span class="token keyword">mut</span> T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>迭代器IterMut中包含的ptr和end指针均为可变裸指针，意味着此迭代器可以改变容器内的值</strong>。代码清单6-70展示了如何使用iter_mut方法获得一个可变迭代器，然后使用它在for循环中遍历并修改slice类型数组中的每个元素。 </p>
<p>代码清单<strong>6-70</strong>：使用可变迭代器</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 3, 4, 5, 6]</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Rust中的迭代器其实不仅有IntoIter、Iter和IterMut三种。比如，String类型和HashMap类型均有Drain迭代器，可以迭代删除指定范围内的值，为字符串和HashMap的处理提供方便</strong>。不管Rust中的迭代器有多少种，重要的是，这些迭代器的实现都遵循上述规律，这也是Rust高度一致性的设计所带来的好处。反过来，<strong>不管是Slice类型的数组，还是Vec＜T＞类型的动态数组，亦或是HashMap等容器，迭代器模式都将其统一抽象地看待成一种数据流容器，通过对迭代器提供的“游标”进行增减就可以遍历流中的每一个元素。</strong> </p>
<h3 id="6-3-4-迭代器适配器"><a href="#6-3-4-迭代器适配器" class="headerlink" title="6.3.4 迭代器适配器"></a>6.3.4 迭代器适配器</h3><p><strong>迭代器将数据容器的操作抽象为了统一的数据流</strong>，这就好比现实世界中，每家每户的自来水管都是标准化的接口，只需要打开水龙头就可以按需用水。但是不同的场景有不同的需求，厨房用水需要对水进行加热；而洗澡间则不只需要加热，还需要让冷热水混合，甚至还需要将水流分解为更细小的水流，这样洗澡才够舒服。要满足这些不同的需求，所要做的不是让自来水厂按需铺设专门的管道，而只需要在自来水接口上安装不同的设备。厨房只需要安装厨宝，将流经的水加热后再输出；洗澡间需要安装热水器，另外铺设冷热管道和花洒即可满足需求。<strong>这些不同的设备虽然功能不同，但是它们都遵循自来水管道的标准规范，这样才能适配各种各样的场景。</strong> </p>
<p>在软件世界中，<strong>通过适配器模式同样可以将一个接口转换成所需的另一个接口。适配器模式能够使得接口不兼容的类型在一起工作。适配器也有一个别名，叫包装器（Wrapper）。Rust在迭代器基础上增加了适配器模式，这就极大地增强了迭代器的表现力。</strong> </p>
<p><strong>Map适配器Map是Rust里最常见的一个迭代器适配器</strong>，如代码清单6-71所示。</p>
<p>代码清单<strong>6-71</strong>：<strong>map</strong>方法示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-71的第3行通过into_iter方法将数组转换为迭代器，然后调用迭代器的map方法创建了一个新的迭代器iter。然后依次调用iter的next方法迭代数组中的每个元素，同时，对每个元素执行闭包中指定的 逻辑，最后输出相应结果。 </p>
<p>map 方法创建的新迭代器就是一个迭代器适配器。代码清单 6-72展示了定义于std：：iter：：Iterator中的map方法源码。 </p>
<p>代码清单<strong>6-72</strong>：迭代器<strong>map</strong>方法源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> map<span class="token operator">&lt;</span>B<span class="token punctuation">,</span> F<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> Map<span class="token operator">&lt;</span>Self<span class="token punctuation">,</span> F<span class="token operator">></span>
    <span class="token keyword">where</span>
    Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> B<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        Map <span class="token punctuation">{</span>iter<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> f<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>map是Iterator trait中实现的方法，第一个参数self代表实现Iterator的具体类型，第二个参数f是一个FnMut闭包。该闭包trait限定为 FnMut（Self：：Item）-＞B，其中的Self：：Item是指为实现Iterator具体类型设置的关联类型Item。最终，该方法返回了一个结构体Map＜Self，F＞，值得注意的是，这里Self被限定为Sized，否则Self在编译期无法确定大小就会报错。这个结构体Map就是一个迭代器适配器。 </p>
<p>代码清单6-73展示了定义Map的源码。 </p>
<p>代码清单<strong>6-73</strong>：迭代器适配器<strong>Map</strong>源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust">#<span class="token punctuation">[</span>must_use<span class="token operator">=</span><span class="token string">"iterator adaptors are lazy ......"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[derive(Clone)]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Map<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span> <span class="token punctuation">{</span>
    iter<span class="token punctuation">:</span> I<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> F<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>B<span class="token punctuation">,</span> I<span class="token punctuation">:</span> Iterator<span class="token punctuation">,</span> F<span class="token operator">></span> Iterator <span class="token keyword">for</span> Map<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span>
<span class="token keyword">where</span> F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> B
<span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item <span class="token operator">=</span> B<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>usize<span class="token punctuation">,</span> Option<span class="token operator">&lt;</span>usize<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看得出来，Map是一个泛型结构体，它只有两个成员字段，一个是<strong>iter</strong>，一个<strong>f</strong>，分别存储的是迭代器和传入的闭包。然后为其实现了Iterator trait，Map就成为了一个地道的迭代器。与一般迭代器不同的地方在于，其核心方法next和size_hint都是调用其内部存储的原始迭代器的相应方法。值得注意的是，第12行调用的map方法是next方法返回的Option＜T＞中实现的另一个 map 方法，后面的章节中会介绍该方法。 通过第 12 行代码中的 map 方法传入Map中存储的闭包，就可以对每个元素执行相应的逻辑，最终再返回一个Option＜T＞类型。</p>
<p>你可能已经注意到了，代码清单 6-73 中迭代器适配器 Map 的源码上方使用了<strong>＃[must_use=＂……＂]属性，该属性是用来发出警告，提示开发者迭代器适配器是惰性的，也就是说，如果没有对迭代器产生任何“消费”行为，它是不会发生真正的迭代的。</strong>这就好比水龙头上装好了花洒，但是不打开水龙头，就无法真正使用花洒。而调用next方法就属于“消费”行为。Rust中所有的迭代器适配器都使用了must_use来发出警告。</p>
<p>了解Map适配器之后，再回到代码清单6-71来查看其整个执行流程示意，如图6-6所示。</p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503171104396.png" alt="image-20210503171104396"></p>
<p>图6-6是代码清单6-71的执行过程的简单示意图。数组a通过into_iter方法创建了迭代器IntoIter并转移所有权，然后IntoIter再调用Iterator trait中实现的map方法，传入闭包，IntoIter迭代器创建了一个迭代器适配器Map。Map中存储了迭代器IntoIter和传入的闭包F，然后通过next方法遍 历“消费”其元素，依次产生新的数据。 </p>
<p>其他适配器 </p>
<p><strong>除了Map，Rust标准库中还提供了很多迭代器适配器，都定义于std：：iter模块中</strong>。下面是一个迭代器适配器常用列表。 </p>
<ul>
<li><strong>Map</strong>，通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。 </li>
<li><strong>Chain</strong>，通过连接两个迭代器来创建一个新的迭代器。 </li>
<li><strong>Cloned</strong>，通过拷贝原始迭代器中全部元素来创建新的迭代器。 </li>
<li><strong>Cycle</strong>，创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。·</li>
<li><strong>Enumerate</strong>，创建一个包含计数的迭代器，它会返回一个元组（i，val），其中 i 是 usize类型，为迭代的当前索引，val是迭代器返回的值。</li>
<li><strong>Filter</strong>，创建一个基于谓词判断式（predicate，产生布尔值的表达式）过滤元素的迭代器。 </li>
<li><strong>FlatMap</strong>，创建一个类似Map的结构的迭代器，但是其中不会含有任何嵌套。 </li>
<li><strong>FilterMap</strong>，相当于Filter和Map两个迭代器依次使用后的效果。 </li>
<li><strong>Fuse</strong>，创建一个可以快速结束遍历的迭代器。在遍历迭代器时， 只要返回过一次None，那么之后所有的遍历结果都为None。该迭代器适配器可以用于优化。 </li>
<li><strong>Rev</strong>，创建一个可以反向遍历的迭代器。 </li>
</ul>
<p>代码清单6-74展示了其中一部分迭代器适配器使用的示例。 </p>
<p>代码清单<strong>6-74</strong>：部分迭代器适配器使用示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c1 <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Vec<span class="token operator">&lt;</span>i32<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c1<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"h"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c2 <span class="token operator">=</span> arr2<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter_map</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> x<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span>collect<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Vec<span class="token operator">&lt;</span>i32<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c2<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>idx<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token keyword">in</span> arr3<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"idx: {:?}, val: {}"</span><span class="token punctuation">,</span> idx<span class="token punctuation">,</span> val<span class="token punctuation">.</span><span class="token function">to_uppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-74第2行到第4行使用了map方法，相应地，它会创建Map适配器。最终通过collect方法迭代生成第3行断言中所显示的Vec＜i32＞动态数组。 </p>
<p>代码第5行到第8行使用了filter_map方法，它会创建FilterMap适配器。同样通过collect方法生成第7行断言中所示的Vec＜i32＞动态数组。 </p>
<p>代码第9行到第12行使用了enumerate方法，它会创建Enumerate适配器，这里使用了for循环，因为此迭代器的next方法返回的是元组，所以第10行for循环内使用（idx，val）形式。 </p>
<p>另外一个值得介绍的迭代器适配器是 Rev，它使用 rev 方法，可以支持反向遍历，如代码清单6-75所示。 </p>
<p>代码清单<strong>6-75</strong>：<strong>rev</strong>方法示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rev</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-75中使用rev方法创建了迭代器适配器，调用其next方法就是反向遍历。这里面存在什么“魔法”呢？代码清单6-76展示了rev方法 的源码。</p>
<p>代码清单<strong>6-76</strong>：<strong>rev</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">rev</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Rev<span class="token operator">&lt;</span>Self<span class="token operator">></span>
    <span class="token keyword">where</span> Self<span class="token punctuation">:</span> Sized <span class="token operator">+</span> DoubleEndedIterator<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        Rev <span class="token punctuation">{</span>iter<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看得出来，rev 方法返回了 Rev 结构体，它就是实现反转遍历的迭代器适配器。注意这里Self的trait限定中包含了一个DoubleEndIterator trait，意味着只有实现该trait的类型才可以使用此方法。 </p>
<p>代码清单6-77展示了Rev迭代器适配器的源码。</p>
<p>代码清单<strong>6-77</strong>：<strong>Rev</strong>迭代器适配器源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> Rev<span class="token operator">&lt;</span>T<span class="token operator">></span>  <span class="token punctuation">{</span>
    iter<span class="token punctuation">:</span> T<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>I<span class="token operator">></span> Iterator <span class="token keyword">for</span> Rev<span class="token operator">&lt;</span>I<span class="token operator">></span>
<span class="token keyword">where</span> I<span class="token punctuation">:</span> DoubleEndedIterator<span class="token punctuation">,</span>
<span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item <span class="token operator">=</span> <span class="token operator">&lt;</span>I <span class="token keyword">as</span> Iterator<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;&lt;</span>I <span class="token keyword">as</span> Iterator<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">next_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Rev泛型结构体中只有一个成员字段iter，只用来保存迭代器。在为其实现Iterator时，指定了DoubleEndIterator限定。并且将关联类型Item 通过无歧义完全限定语法指定了Iterator中的关联类型。 </p>
<p>值得注意的是，在 next 方法中，调用了 Rec 中存储的迭代器的next_back 方法。这个next_back方法实际上是在DoubleEndIterator中定义的，代码清单6-78展示了其源码。 </p>
<p>代码清单<strong>6-78</strong>：<strong>DoubleEndIterator</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> DoubleEndedIterator<span class="token punctuation">:</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>限于篇幅，代码清单 6-78 只展示了 DoubleEndIterator 的部分源码。看得出来，DoubleEndIterator是Iterator的子trait，这样定义实际是为了扩展Iterator。next_back和next方法签名非常相似，反转遍历正是基于 此方法来实现的。代码清单6-79展示了next_back的使用示例。 </p>
<p>代码清单<strong>6-79</strong>：<strong>next_back</strong>方法使用示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>None<span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>None<span class="token punctuation">,</span> iter<span class="token punctuation">.</span><span class="token function">next_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-79第4行调用了next方法，返回的是Some（1），属于正常遍历。</p>
<p>代码第5行和第6行调用了next_back方法，返回的分别是Some（6）和Some（5），说明这两次遍历是反向遍历，但是第7行到第9行依次又调用了next方法，返回值分别是Some（2）、Some（3）和Some（4）。这说明，在执行<strong>next_back</strong>方法之后，迭代器的“游标”还是会返回到上一次<strong>next</strong>执行的位置继续执行<strong>next</strong>，这也是该方法命名为<strong>next_back</strong>的原因。在第10行和第11行中，迭代已经完毕，均返回None。 </p>
<p>至此，我们就知道了<strong>Rev迭代器适配器的工作机制：在next迭代中，调用next_back方法。只有实现了 DoubleEndIterator 的迭代器才有next_back 方法，也就是说，只有实现了DoubleEndIterator的迭代器才能调用Iterator：：rev方法进行反向遍历。</strong> </p>
<p>Rust标准库中还提供更多的迭代器适配器，这些迭代器适配器可以自由灵活地组合，以便应对不同的需求。图6-7展示了迭代器适配器的心智模型。</p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503193025835.png" alt="image-20210503193025835"></p>
<h3 id="6-3-5-消费器"><a href="#6-3-5-消费器" class="headerlink" title="6.3.5 消费器"></a>6.3.5 消费器</h3><p><strong>Rust 中的迭代器都是惰性的，也就是说，它们不会自动发生遍历行为，除非调用 next方法去消费其中的数据。最直接消费迭代器数据的方法就是使用for循环，前面已经了解到，for循环会隐式地调用迭代器的next方法，从而达到循环的目的。</strong> </p>
<p>为了编程的便利性和更高的性能，<strong>Rust也提供了for循环之外的用于消费迭代器内数据的方法，它们叫作消费器（Consumer）。下面列出了Rust标准库std：：iter：：Iterator中实现的常用消费器。</strong> </p>
<ul>
<li><strong>any</strong>，其功能类似代码清单6-42中实现的any方法的功能，<strong>可以查找容器中是否存在满足条件的元素</strong>。</li>
<li><strong>fold</strong>，来源于函数式编程语言。<strong>该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器，它会将闭包每次迭代执行的结果进行累计，并最终作为 fold 方法的返回值。</strong>在其他语言中，也被用作 reduce或inject。</li>
<li><strong>collect，专门用来将迭代器转换为指定的集合类型。</strong>比如代码清单 6-74 中使用collect：：＜Vec＜i32＞＞（）这样的turbofish语法为其指定了类型，最终迭代器就会被转换为Vec＜i32＞这样的数组。因此， 它也被称为“收集器”。 </li>
</ul>
<p><strong>(1) any和fold</strong> </p>
<p>代码清单6-80展示了消费器any和fold的使用示例。 </p>
<p>代码清单<strong>6-80</strong>：<strong>any</strong>和<strong>fold</strong>的使用示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>x<span class="token operator">|</span> x <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span>acc<span class="token punctuation">,</span> x<span class="token operator">|</span> acc <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-80的第3行中，any方法检查数组a中是否存在不等于2的元素，返回true。代码第4行使用fold方法来对数组a进行求和，图6-8展示了fold的求值过程。 </p>
<p><img src="/2021/03/15/the-tao-of-rust-programming-06/image-20210503193930266.png" alt="image-20210503193930266"></p>
<p>代码清单6-80中值得注意的地方在于，any和fold传入的闭包的参数是一个引用。这是为什么呢？代码清单6-81展示了any和fold的源码。 </p>
<p>代码清单<strong>6-81</strong>：<strong>any</strong>和<strong>fold</strong>的源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> any<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token keyword">mut</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool
    <span class="token keyword">where</span> Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
        F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">false</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> fold<span class="token operator">&lt;</span>B<span class="token punctuation">,</span> F<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> init<span class="token punctuation">:</span> B<span class="token punctuation">,</span> <span class="token keyword">mut</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> B
    <span class="token keyword">where</span> Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
        F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> B<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> accum <span class="token operator">=</span> init<span class="token punctuation">;</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
            accum <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>accum<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        accum
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看得出来，any和fold的内部都包含了一个for循环，它们实际上是通过for循环来实现内部迭代器的。内部迭代器的特点是，一次遍历到底，不支持<strong>return</strong>、<strong>break</strong>或<strong>continue</strong>操作，因此可以避免一些相应的检查，更有利于底层LLVM的优化。 </p>
<p>在代码清单6-80的第3行中，使用的是数组的iter方法，创建的迭代器是Iter类型，该类型的next方法返回的是Option＜&amp;[T]＞或Option＜&amp;mut [T]＞类型的值。而for循环实际上是一个语法糖，会自动调用迭代器的 next 方法，for 循环中的循环变量则是通过模式匹配，从next返回的Option＜&amp;[T]＞或Option＜&amp;mut [T]＞类型中获取&amp;[T]或&amp;mut [T]类型的值的。 </p>
<p>因此，在代码清单6-81的第8行中，any方法的内部for循环中的循环变量x是一个引用。所以，在代码清单6-80中，第3行传给any的闭包参数只能是引用形式，否则就会报错。代码清单6-82展示了更多细节。 </p>
<p>代码清单<strong>6-82</strong>：<strong>any</strong>方法示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>x<span class="token operator">|</span> x <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> <span class="token operator">*</span>x <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// error:</span>
    <span class="token comment" spellcheck="true">// the trait bound `&amp;{integer}:std::cmp::PartialEq&lt;{integer}>` is not satisfied</span>
    <span class="token comment" spellcheck="true">// let result2 = arr.iter().any(|x| x != 2);</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>result1<span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>result2<span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-82中，第3行和第4行的any方法闭包参数分别使用了&amp;x和x，都可以正常运行。对于&amp;x参数的闭包来说，在any方法内部调用时，会因为闭包参数的模式匹配获取x的值，故而可以正常运行。对于x参数的闭包来说，因为闭包执行体使用了解引用操作符，因此也可以正常运行。但是像第7行那样的用法就会抛出注释所示的错误。这是因为此时x为引用，不能进行比较操作。 </p>
<p>对于fold方法来说，也是同样的道理，如代码清单6-83所示。 </p>
<p>代码清单<strong>6-83</strong>：使用<strong>fold</strong>对数组求和示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span> acc<span class="token punctuation">,</span> x<span class="token operator">|</span> acc <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span> acc<span class="token punctuation">,</span> x<span class="token operator">|</span> acc <span class="token operator">+</span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum3 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span> acc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token operator">|</span> acc <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum4 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span> acc<span class="token punctuation">,</span> x<span class="token operator">|</span> acc <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>sum1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>sum2<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>sum3<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>sum4<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-83中，第3行、第4行和第5行通过iter方法获取的动态数组arr的不可变迭代器为Iter类型，所以能获取多次。第6行使用into_iter方法来创建的迭代器是IntoIter类型，会获取arr的所有权。 </p>
<p>因为Iter类型的迭代器在for循环中产生的循环变量为引用，所以在fold内部的for循环中传入闭包的循环变量也是引用。故而代码清单6-83 的第3行、第4行和第5行都可以正常运行。加法操作对引用是适用的。 </p>
<p>而IntoIter类型的迭代器的next方法返回的是Option＜T＞类型，在for循环中产生的循环变量是值，不是引用。所以在代码清单6-83第6行使用fold时，其内部的for循环的循环变量也是值，所以这里闭包参数也只能是值。如果把第6行闭包参数中的x改为&amp;x，或者把闭包体内的x改为*x，均会报错。 </p>
<p>Rust除了提供any和fold两个消费器（内部迭代器），还提供了其他的内部迭代器，比如all、for_each和position等，可以在std：：iter：：Iterator的文档中找到它们的用法和源码。在众多消费器中，最特殊的应该算collect消费器了。 </p>
<p><strong>collect</strong>消费器 </p>
<p>通过前面的几个示例我们已经知道，collect消费器有“收集”功能， 在语义上可以理解为将迭代器中的元素收集到指定的集合容器中，比如前面示例中所看到的collect：：＜Vec＜i32＞＞（），就是将迭代器元素收集到 Vec＜i32＞类型的动态数组容器中。通过turbofish语法还可以指定其他的集合容器，比如collect：：＜HashMap＜i32，i32＞＞（）等。代码清单6-84展示了collect消费器源码。 </p>
<p>代码清单<strong>6-84</strong>：<strong>collect</strong>源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>
    <span class="token punctuation">...</span>
    <span class="token keyword">fn</span> collect<span class="token operator">&lt;</span>B<span class="token punctuation">:</span> FromIterator<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">>></span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> B <span class="token keyword">where</span> Self<span class="token punctuation">:</span>Sized <span class="token punctuation">{</span>
        FromIterator<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_iter</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看得出来collect消费器的源码很简单，其内部只是调用FromIterator：：from_iter方法。前面已经讲过，FromIterator和IntoIterator 是互为逆操作的两个 trait。代码清单 6-85 展示了FromIterator的源码。</p>
<p>代码清单<strong>6-85</strong>：<strong>FromIterator</strong>源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> FromIterator<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> from_iter<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> IntoIterator<span class="token operator">&lt;</span>Item<span class="token operator">=</span>A<span class="token operator">>></span><span class="token punctuation">(</span>iter<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该 trait 只定义了唯一的泛型方法 from_iter，它的方法签名中使用了trait 限定IntoIterator＜Item=A＞，表示只有实现了IntoIterator的类型才可以作为其参数。集合容器只需要实现该trait，就可以拥有使用collect消费器收集迭代器元素的能力，代码清单6-86所展示的集合MyVec就实现了FromIberotor trait。 </p>
<p>代码清单<strong>6-86</strong>：自定义集合<strong>MyVec</strong>实现<strong>FromIterator</strong></p>
<pre><code>use std::iter::FromIterator;
#[derive(Debug)]
struct MyVec(Vec&lt;i32&gt;);
impl MyVec {
    fn new() -&gt; MyVec {
        MyVec(Vec::new())
    }
    fn add(&amp;mut self, elem: i32) {
        self.0.push(elem);
    }
}
impl FromIterator&lt;i32&gt; for MyVec {
    fn from_iter&lt;I: IntoIterator&lt;Item = i32&gt;&gt;(iter: I) -&gt; Self {
        let mut c = MyVec::new();
        for i in iter {
            c.add(i);
        }
        c
    }
}
fn main() {
    let iter = (0..5).into_iter();
    let c = MyVec::from_iter(iter);
    assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
    let iter = (0..5).into_iter();
    let c: MyVec = iter.collect();
    assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
    let iter = (0..5).into_iter();
    let c = iter.collect::&lt;MyVec&gt;();
    assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
}</code></pre><p>在代码清单6-86中，通过元组结构体包装Vec＜i32＞创建了MyVec结构体，将其作为自定义的集合容器，并为其实现FromIterator。然后在main函数中就可以使用collect来把迭代器元素收集到自定义的MyVec容器中了。</p>
<p>这里需要注意的是，直接调用MyVec：：from_iter方法和使用collect方法的效果是一样的。 </p>
<h3 id="6-3-6-自定义迭代器适配器"><a href="#6-3-6-自定义迭代器适配器" class="headerlink" title="6.3.6 自定义迭代器适配器"></a>6.3.6 自定义迭代器适配器</h3><p>Rust虽然提供了很多迭代器适配器，但是面对实际开发中各种各样的需求时还是显得不够用。幸运的是，在Rust中可以很容易地自定义迭代器适配器，这得益于Rust的高度一致性。 </p>
<p>接下来要实现一个自定义的迭代器适配器，主要功能是让迭代器按指定的步数来遍历，而不是逐个遍历。首先，需要定义一个迭代器适配器Step＜I＞，如代码清单6-87所示。 </p>
<p>代码清单<strong>6-87</strong>：定义迭代器适配器<strong>Step</strong>＜<strong>I</strong>＞ </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Clone, Debug)]</span>
#<span class="token punctuation">[</span>must_use <span class="token operator">=</span> <span class="token string">"iterator adaptors are lazy and do nothing unless consumed"</span><span class="token punctuation">]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Step<span class="token operator">&lt;</span>I<span class="token operator">></span> <span class="token punctuation">{</span>
    iter<span class="token punctuation">:</span> I<span class="token punctuation">,</span>
    skip<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-87定义了泛型结构体Step＜I＞，将它作为迭代器适配器，其成员iter用于存储迭代器，skip用于存储迭代的步数。接下来，需要为其实现Iterator，如代码清单6-88所示。 </p>
<p>代码清单<strong>6-88</strong>：为<strong>Step</strong>实现<strong>Iterator</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>I<span class="token operator">></span> Iterator <span class="token keyword">for</span> Step<span class="token operator">&lt;</span>I<span class="token operator">></span>
    <span class="token keyword">where</span> I<span class="token punctuation">:</span> Iterator<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">type</span> Item <span class="token operator">=</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">;</span>
        <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> elt <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>skip <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
                <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>skip <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            elt
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-88为Step实现了Iterator中定义的两个核心方法next。值得注意的是，这里需要将关联类型Item指定为原迭代器的关联类型I：：Item。</p>
<p>实现next和size_hint方法时，必须符合Iterator trait中next方法签名规定的参数和返回值类型。其中next方法必须按指定的步数来迭代，所以此处next方法实现的时候，需要根据Step适配器中的skip字段来跳到相应的元素。如果skip是2，调用next时则需要跳过第一个元素，直接到第二个元素。注意代码第8行使用了nth方法，该方法会直接返回迭代器中第n个元素。 </p>
<p>接下来，需要创建一个step方法来产生Step适配器，如代码清单6-89所示。</p>
<p>代码清单<strong>6-89</strong>：创建<strong>step</strong>方法来产生<strong>Step</strong>适配器</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> step<span class="token operator">&lt;</span>I<span class="token operator">></span><span class="token punctuation">(</span>iter<span class="token punctuation">:</span> I<span class="token punctuation">,</span> step<span class="token punctuation">:</span> usize<span class="token punctuation">)</span> <span class="token punctuation">-></span> Step<span class="token operator">&lt;</span>I<span class="token operator">></span>
<span class="token keyword">where</span> I<span class="token punctuation">:</span> Iterator<span class="token punctuation">,</span>
<span class="token punctuation">{</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span>step <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Step <span class="token punctuation">{</span>
        iter<span class="token punctuation">:</span> iter<span class="token punctuation">,</span>
        skip<span class="token punctuation">:</span> step <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-89创建了step方法，接收两个参数，第一个为迭代器，第二个为指定步数。返回一个Step结构体实例。</p>
<p>现在，一个完整的迭代器适配器已经创建好了。最后只需要为所有的迭代器实现step方法即可，如代码清单6-90所示。 </p>
<p>代码清单<strong>6-90</strong>：为所有的迭代器实现<strong>step</strong>方法 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> IterExt<span class="token punctuation">:</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> usize<span class="token punctuation">)</span> <span class="token punctuation">-></span> Step<span class="token operator">&lt;</span>Self<span class="token operator">></span>
    <span class="token keyword">where</span> Self<span class="token punctuation">:</span> Szied<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> IterExt <span class="token keyword">for</span> T <span class="token keyword">where</span> T<span class="token punctuation">:</span> Iterator <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-90做了两件事。第一件事是自定义了一个继承自Iterator 的子 trait，名为IterExt，其中定义了step方法并给出了默认的实现：直接使用step函数创建Step适配器并返回。第二件事如代码第8行所示，使用impl为所有实现了Iteraotr的类型T实现IterExt。至此，整个迭代器适配器才算大功告成，可以直接使用了，如代码清单6-91所示。 </p>
<p>代码清单<strong>6-91</strong>：应用迭代器适配器<strong>Step</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">step</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span>acc<span class="token punctuation">,</span> x<span class="token operator">|</span> acc <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 3, 5]</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单6-91中，数组arr通过iter方法转换为迭代器之后，就可以直接调用step方法来指定迭代的步数了，此例中指定步数为2，迭代的元素应该是[1，3，5]，所以使用fold消费器对其求和所得值等于9。 </p>
<p>以上就是自定义迭代器适配器的具体思路。 </p>
<p>实际上，Rust社区有很多第三方包（crate）也提供了迭代器适配器，其中最常用的是Itertools。代码清单6-92是Itertools包中实现的Positions适配器示例。</p>
<p>代码清单<strong>6-92</strong>：<strong>Itertools</strong>包中实现的<strong>Positions</strong>迭代器适配器</p>
<pre class="line-numbers language-rust"><code class="language-rust">#<span class="token punctuation">[</span>must_use <span class="token operator">=</span> <span class="token string">"iterator adaptors are lazy and do nothing unless consumed"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Positions<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span> <span class="token punctuation">{</span>
    iter<span class="token punctuation">:</span> I<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> F<span class="token punctuation">,</span>
    count<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> positions<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span><span class="token punctuation">(</span>iter<span class="token punctuation">:</span> I<span class="token punctuation">,</span> f<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> Positions<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span>
    <span class="token keyword">where</span> I<span class="token punctuation">:</span> Iterator<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        Positions <span class="token punctuation">{</span>
            iter<span class="token punctuation">:</span> iter<span class="token punctuation">,</span>
            f<span class="token punctuation">:</span> f<span class="token punctuation">,</span>
            count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span> Iterator <span class="token keyword">for</span> Positions<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span>
    <span class="token keyword">where</span> I<span class="token punctuation">:</span> Iterator<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">type</span> Item <span class="token operator">=</span> usize<span class="token punctuation">;</span>
        <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
                <span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            None
        <span class="token punctuation">}</span>
        <span class="token keyword">fn</span> <span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>usize<span class="token punctuation">,</span> Option<span class="token operator">&lt;</span>usize<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">size_hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span> DoubleEndedIterator <span class="token keyword">for</span> Positions<span class="token operator">&lt;</span>I<span class="token punctuation">,</span> F<span class="token operator">></span>
    <span class="token keyword">where</span> I<span class="token punctuation">:</span> DoubleEndedIterator <span class="token operator">+</span> ExactSizeIterator<span class="token punctuation">,</span>
    F<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">fn</span> <span class="token function">next_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">next_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>iter<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            None
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> Itertools<span class="token punctuation">:</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> positions<span class="token operator">&lt;</span>P<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> predicate<span class="token punctuation">:</span> P<span class="token punctuation">)</span> <span class="token punctuation">-></span> Positions<span class="token operator">&lt;</span>Self<span class="token punctuation">,</span> P<span class="token operator">></span>
    <span class="token keyword">where</span> Self<span class="token punctuation">:</span> Sized<span class="token punctuation">,</span>
    P<span class="token punctuation">:</span> <span class="token function">FnMut</span><span class="token punctuation">(</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token function">positions</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> predicate<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> Itertools <span class="token keyword">for</span> T <span class="token keyword">where</span> T<span class="token punctuation">:</span> Iterator <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">positions</span><span class="token punctuation">(</span><span class="token operator">|</span>v<span class="token operator">|</span> v <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rev_r <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">positions</span><span class="token punctuation">(</span><span class="token operator">|</span>v<span class="token operator">|</span> v <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rev</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> r <span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// OUTPUT: 2 3 5 7</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> rev_r <span class="token punctuation">{</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// OUTPUT: 7 5 3 2</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单6-92是从Itertools包中摘选出来的Positions迭代器适配器的完整实现，从main函数中可以看出，其功能是输出满足闭包内指定条件元素的索引（位置）。 </p>
<p>第3行到第7行定义了Positions结构体，包含三个成员字段。其中iter用来存储迭代器，f用来存储闭包，count用来计数。 </p>
<p>第8行到第17行实现了positions方法，用来生成Positions迭代器实例。</p>
<p>第18行到第36行为Positions实现了Iterator中核心的next方法和size_hint方法。注意其中的next方法，在每次迭代时，会使用count来进行计数并执行闭包，如果满足闭包条件则返回相应的计数，就是所得索引值。</p>
<p>第37行到第49行为Positions实现了DoubleEndIterator和ExactSizeIterator，支持反向遍历和确定迭代器大小。 </p>
<p>第50行到第57行创建了Itertools，其继承自Iterator的子trait，作用是扩展Iterator。该trait实现了positions方法，迭代器就可以调用了。 </p>
<p>在main函数中，第61行和第62行分别使用了positions方法正确获得Positions迭代器，并在其后的两个for循环中获得预期的结果。 </p>
<p>除了Positions适配器，Itertools还提供了更多的适配器和其他扩展迭代器的方法。如有需要，可以在crates.io网站找到它。</p>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h2><p>本章从函数式编程范式的角度探讨了Rust中的函数和闭包。<strong>在Rust中，函数是一等公民，可以作为其他函数的参数或返回值。将函数作为参数或返回值的函数，叫高阶函数。在函数之间传递的是函数指针类型fn。</strong>虽然Rust也支持高阶函数，但是函数本身并不能捕获环境变量，无法完成某些情况下的需求，所以Rust也引入了闭包。 </p>
<p>闭包可以捕获其在被定义时环境中的变量。<strong>在Rust中，闭包实际上是一种trait语法糖。对应所有权系统，闭包有三个trait，分别是Fn、FnMut、FnOnce，它们由编译器自动生成。生成哪种类型的闭包，与捕获变量属于复制语义还是移动语义有关联。闭包也可以作为函数的参数 和返回值，这就极大地提高了Rust语言的抽象表达能力</strong>。但是因为闭包是trait语法糖，所以在返回闭包的时候，需要把闭包装箱用作 trait 对象。闭包装箱会带来性能问题，所以Rust官方团队在Rust 2018版本中引入了impl Trait功能，来支持直接返回闭包，而不再需要trait对象。顾名思义，impl Trait代表实现了指定Trait（比如闭包的Fn、FnMut、FnOnce）的类型，它类似返回值上的trait限定，属于静态分发。 </p>
<p>闭包最常见的应用就是迭代器，Rust迭代器的应用非常广泛。<strong>Rust基于trait和结构体非常漂亮地实现了迭代器模式，以及迭代器适配器模式</strong>，不仅在标准库中提供了很多迭代器相关的方法，而且开发者还可以非常方便地编写自己的迭代器适配器，来扩展Rust的迭代器。<strong>Rust迭代器是基于for循环的外部迭代器，for循环其实也是语法糖，它会自动调用next方法来遍历集合容器中的元素。</strong> </p>
<p>Rust的迭代器和迭代器适配器均是惰性的，也就是说，如果没有真正的消费数据的行为发生，它们是不会工作的。<strong>这种用于消费迭代器数据的工具叫消费器。Rust提供了有限的几种消费器，比如collect和fold。这些消费器实际上是一种内部迭代器。内部迭代器的好处是不支持return、break和continue，减少了相关的检查，可以方便编译器进行优化</strong>，在某些场景中提升性能。这些内部迭代器实际上是基于for循环实现的。std：：iter模块中还定义了很多迭代器相关的方法，读者可以自行探索和练习。</p>
<p>通过学习函数、闭包和迭代器，读者应该对Rust有了更深的认识， 也应该能更进一步地体会到Rust语言设计的一致性了。基于trait、结构体和所有权，完美地提供了函数式编程范式中的常用高级语言特性，也许这正是Rust语言的优雅性所在。</p>

            </div>
            <hr />
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform: scale(1.3);
        -webkit-transform: scale(1.3);
        -o-transform: scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">
                写作不易，客官能否打赏一杯奶茶？
            </h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
                    

                        <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

                            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第6章 函数、闭包与迭代器》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/03/15/the-tao-of-rust-programming-06/" property="cc:attributionName"
               rel="cc:attributionURL">
                bill
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '查教程获取',
        clientSecret: '查教程获取',
        repo: 'billbliu.github.io',
        owner: 'billbliu',
        admin: "billbliu",
        id: '2021/03/15/the-tao-of-rust-programming-06/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
            

                

                            

                                        

                                                    
                                                        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

                                                            

                                                                

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/03/16/the-tao-of-rust-programming-07/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="第7章 结构化编程">
                        
                        <span class="card-title">第7章 结构化编程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            形每万变，神唯守一。 
编程是一门技术，用它可以解决很多问题，创造很多新事物，甚至改变世界。编程更是一门艺术，在使用它解决问题或创造新事物的时候，本身就是一种精神实践活动，其中蕴含了开发者对于客观世界的认识和反映。在外行人的眼里，由 26 
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rust编程之道/" target="_blank">
                        <span class="chip bg-color">Rust编程之道</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/14/the-tao-of-rust-programming-05/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/26.jpg" class="responsive-img" alt="第5章 所有权系统">
                        
                        <span class="card-title">第5章 所有权系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            律者，所以定分止争也。 
《慎子》书中有一典故：“一兔走街，百人追之，分未定也；积兔满市，过而不顾，非不欲兔，分定不可争也。”大意是，一只兔子在大街上乱跑，看到的人都想据为己有，是因为这只兔子“名分未定”，而到了兔市，谁也不能随便拿，就连小
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rust编程之道/" target="_blank">
                        <span class="chip bg-color">Rust编程之道</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    <script>
        $('#articleContent').on('copy', function (e) {
            // IE8 or earlier browser is 'undefined'
            if (typeof window.getSelection === 'undefined') return;

            var selection = window.getSelection();
            // if the selection is short let's not annoy our users.
            if (('' + selection).length < Number.parseInt('120')) {
                return;
            }

            // create a div outside of the visible area and fill it with the selected text.
            var bodyElement = document.getElementsByTagName('body')[0];
            var newdiv = document.createElement('div');
            newdiv.style.position = 'absolute';
            newdiv.style.left = '-99999px';
            bodyElement.appendChild(newdiv);
            newdiv.appendChild(selection.getRangeAt(0).cloneContents());

            // we need a <pre> tag workaround.
            // otherwise the text inside "pre" loses all the line breaks!
            if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
                newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
            }

            var url = document.location.href;
            newdiv.innerHTML += '<br />'
                + '来源: bill的博客<br />'
                + '作者: bill<br />'
                + '链接: <a href="' + url + '">' + url + '</a><br />'
                + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

            selection.selectAllChildren(newdiv);
            window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
        });
    </script>

    <!--<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
    <script>
        const btw = new BTWPlugin();
        btw.init({
            id: 'artDetail',
            blogId: '20962-1585405055583-879',
            name: '算法码上来',
            qrcode: 'https://godweiyang.com/medias/gzh.jpg',
            keyword: 'VIP',
        });
    </script>
-->
    
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; Bill. 版权所有

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">
                    440.3k
                </span>
                

                    <br>
                    <span id="sitetime"></span>

                    
                        
        </div>
        <div class="col s12 m4 l4 social-link ">
            
    <a href="https://github.com/billbliu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:billliu201919@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=1321531943&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>

        </div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        // 50ms周期检测函数
        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>

</html>