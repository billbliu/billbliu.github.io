<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第13章 超越安全的边界, Golang Rus Bill 数据结构和算法 网络 设计模式">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="混沌涌现秩序，光明源自黑暗。 
现代人类依靠钢筋混凝土结构的现代建筑来挡风遮雨、袪暑避寒，舒服地享受生活；在大气层和地球磁场的保护下，削弱了一次又一次能够重创现代文明的强太阳高能电子流和其他宇宙射线的冲击；木星、土星等巨行星形成的屏障，大大">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第13章 超越安全的边界 | bill的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/medias/logo.png" class="circle logo-img" alt="LOGO">
                        
                            <span class="logo-span">
                                bill的博客
                            </span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">bill的博客</div>
        <div class="logo-desc">
            
            华东交通大学 | 区块链工程师 | golang rust
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/billbliu/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/billbliu/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
                
    </nav>

</header>
    



    <div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
        <div class="container">
            <div class="row">
                <div class="col s12 m12 l12">
                    <div class="brand">
                        <div class="description center-align post-title">
                            第13章 超越安全的边界
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Rust编程之道/" target="_blank">
                                    <span class="chip bg-color">
                                        Rust编程之道
                                    </span>
                                </a>
                                
                        </div>
                        
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                                
                        </div>
                        
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>
                    发布日期:&nbsp;&nbsp;
                        2021-03-22
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>
                    作者:&nbsp;&nbsp;
                        
                                    bill
                                        
                </div>

                
                    
                        <div class="info-break-policy">
                            <i class="fa fa-file-word-o fa-fw"></i>
                            文章字数:&nbsp;&nbsp;
                                37.8k
                        </div>
                        

                            
                                <div class="info-break-policy">
                                    <i class="fa fa-clock-o fa-fw"></i>
                                    阅读时长:&nbsp;&nbsp;
                                        148
                                            分
                                </div>
                                
                                    

                                        
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>混沌涌现秩序，光明源自黑暗。 </p>
<p>现代人类依靠钢筋混凝土结构的现代建筑来挡风遮雨、袪暑避寒，舒服地享受生活；在大气层和地球磁场的保护下，削弱了一次又一次能够重创现代文明的强太阳高能电子流和其他宇宙射线的冲击；木星、土星等巨行星形成的屏障，大大地降低了小天体撞击地球的概率。这是一个无奈的事实：不安全是这个世界的本质，绝对的安全并不存在。 </p>
<p>计算机世界中亦是如此。<strong>Rust语言通过一系列静态分析机制保障了内存安全。然而，作为系统级编程语言，Rust无可避免地需要直接与操作系统或裸机打交道。操作系统主要由C语言实现，包括UNIX、Linux、Windows内核。所以，Rust程序在和外部环境“打交道”的时候，无论Rust编译器有多么智能和强大，都很难检测到外部环境涉及的内存安全问题。</strong> </p>
<p>不妨打个比方。Rust就像是一艘遨游于太空的宇宙飞船，不管外太空多么危险，宇航员只要待在飞船内部，就是安全的。当宇航员需要去飞船外执行任务时，就必须穿好宇航服，经由减压舱到达飞船外部。宇航员一旦进入外太空，就必须自己保证安全，因为此时他已完全暴露于不安全的环境之下。 </p>
<p>严格地说，<strong>Rust语言可以分为Safe Rust和Unsafe Rust两部分。Safe Rust就是提供安全庇护的“宇宙飞船”，而Unsafe Rust就是“宇航服、减压舱，以及飞船外部与宇航员有一切关联的部分”。</strong> </p>
<p><strong>Safe Rust涵盖了前面章节中所介绍的内容，包括类型系统和所有权等静态分析机制。在使用Safe Rust的时候，开发者完全不必担心有内存不安全的问题出现。但是当需要和其他语言交互，甚至与底层操作系统或硬件设备交互的时候，就只能依靠另外一套“语言”：Unsafe Rust。</strong></p>
<h2 id="13-1-Unsafe-Rust介绍"><a href="#13-1-Unsafe-Rust介绍" class="headerlink" title="13.1 Unsafe Rust介绍"></a>13.1 Unsafe Rust介绍</h2><p><strong>Unsafe Rust是Safe Rust的一个超集。也就是说，在Unsafe Rust中，并不会禁用Safe Rust中的任何安全检查。</strong>如代码清单13-1所示。 </p>
<p>代码清单<strong>13-1</strong>：<strong>unsafe</strong>块中使用引用依旧会进行借用检查 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">mut</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
        <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-1中，在unsafe块中同时对变量a进行不可变借用和可变借用，这违反了借用规则，编译器会报错。所以，即使<strong>在Unsafe Rust下，如果依旧编写Safe Rust的代码，也完全可以保证某种程度的安全性</strong>。</p>
<p><strong>Unsafe Rust是指在进行以下五种操作的时候，并不会提供任何安全检查</strong>：</p>
<ul>
<li><strong>解引用裸指针</strong>。 </li>
<li><strong>调用unsafe的函数或方法</strong>。 </li>
<li><strong>访问或修改可变静态变量</strong>。 </li>
<li><strong>实现unsafe trait</strong>。 </li>
<li><strong>读写Union联合体中的字段</strong>。 </li>
</ul>
<p><strong>这五种操作基本上适用于Rust和外部环境“打交道”的所有场景。</strong>对于这些场景的操作来说，Rust的安全检查完全无用武之地，反而会是一种障碍。比如解引用裸指针的时候，也许会是一个空指针或悬垂指针，此时就会造成未定义行为，即便此时编译器会进行安全检查，代码也无法通过编译，从而也就完全无法和外部环境“打交道”了。所以，针对这五种操作，就完全不提供任何安全检查。 </p>
<p><strong>Unsafe Rust和Safe Rust的区分带来以下三方面结果</strong>：</p>
<ul>
<li><strong>Unsafe Rust由于不需要安全检查，意味着有一定的性能提升。</strong> </li>
<li><strong>Unsafe Rust内存安全完全交由开发者来保证，否则会出现未定义行为。</strong></li>
<li><strong>区分了编译器和开发者的职责，如果代码出现了问题，可以先排查Unsafe Rust的代码。</strong> </li>
</ul>
<p>这其中包含缺点，也有优点。值得注意的是，Unsafe Rust的存在并不与Safe Rust相矛盾，也不与Rust语言保证内存安全的目标相冲突。反而是Unsafe Rust的存在成就了Rust。 </p>
<h3 id="13-1-1-Unsafe语法"><a href="#13-1-1-Unsafe语法" class="headerlink" title="13.1.1 Unsafe语法"></a>13.1.1 Unsafe语法</h3><p><strong>通过unsafe关键字和unsafe块就可以使用Unsafe Rust，它们的作用如下：</strong></p>
<ul>
<li><strong>unsafe关键字，用于标记（或者说声明）函数、方法和trait。</strong> </li>
<li><strong>unsafe块，用于执行Unsafe Rust允许的五种操作。</strong> </li>
</ul>
<p><strong>(1) unsafe关键字</strong> </p>
<p>Rust标准库中包含了很多被unsafe关键字标记的函数、方法和trait。以String中实现的函数来说，如代码清单13-2所示。 </p>
<p>代码清单<strong>13-2</strong>：<strong>String</strong>中内置的<strong>unsafe</strong>函数示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">from_utf8_unchecked</span><span class="token punctuation">(</span>bytes<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>u8<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> String <span class="token punctuation">{</span>
    String <span class="token punctuation">{</span> vec<span class="token punctuation">:</span> bytes <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-2中展示了String内置的unsafe函数from_utf8_unchecked的源码实现。其函数签名包含了unsafe关键字，该函数接收一个Vec＜u8＞类型的字节数组，返回一个String类型。</p>
<p>乍一看，该函数中只是简单地返回一个String结构体实例而已，也没有进行Unsafe Rust允许的那五种操作中的任意一种，完全是正常的Safe Rust代码，而且也在编译器的安全检查之下。那么这里为什么用<strong>unsafe</strong>关键字来标记该函数呢？因为该函数并未对传入的参数bytes进行任何合法性验证，如果传入的是一个非法的UTF-8字节序列，则会出现内存不安全的问题。换句话说，就是使用该函数时有可能会发生违反“契约”的风险。 </p>
<p><em>函数 from_utf8_unchecked 的“契约”是指，传入的参数是有效的UTF-8字节序列。这就是unsafe关键字存在的意义。该函数被标记上unsafe之后，使用该函数的开发者就会主动去了解这一“契约”，看看当前的使用是否满足“契约”的要求。如果开发者没有做到满足“契约”的要求，将来出现了问题，也可以在unsafe标记的范围内排查问题。</em> </p>
<p>所以，<em>在使用 Rust 编写一个函数的时候，需要注意该函数在使用的时候是否存在违反“契约”的风险。如果存在风险，请使用unsafe关键字将其标记出来，在其他人使用该函数时，就可以多加注意。</em>这里最大的风险在于，如果一个函数存在违反“契约”的风险，而开发者并没有使用unsafe关键字将其标记，那该函数就很可能会成为Bug的“温床”。 </p>
<p><strong>除标记函数或方法外，unsafe也用于标记trait。</strong> </p>
<p><strong>标准库中包含的unsafe trait有Send和Sync</strong>。编译器依赖Rust内置的类型和内部严格的规则，为开发者自定义的类型自动实现这两个trait，这是Rust能保证并发安全的基石。使用unsafe对Send和Sync进行标记，就意味着开发者手动实现它会有安全风险。 </p>
<p><strong>标准库中另外一个unsafe trait就是std：：str：：pattern：：Searcher</strong>，在字符串章节中已介绍过它，它是字符串搜索模式的抽象，提供了一系列方法，行为像迭代器。如代码清单13-3所示。 </p>
<p>代码清单<strong>13-3</strong>：<strong>Searcher</strong>示意  </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">trait</span> Searcher<span class="token operator">&lt;</span>'a<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> SearchStep<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-3中展示了Searcher源码示意，它是一个unsafe trait。这里unsafe标记的为什么是trait而不是方法next呢？ </p>
<p>这是因为要实现 Searcher 里的 next 方法，必须要保证其返回的索引位于有效的UTF-8边界上，否则会出现内存不安全的问题。而依据Searcher的工作机制来看，next方法并不会引起任何内存不安全问题，只是它的返回结果在另外一个地方使用才会发生问题。而考虑到字符串检索的性能，Searcher也不想对结果进行检查。所以，这里只能给trait加上unsafe标记，以此来警告实现该trait的开发者在实现该trait时必须遵守这些条件。另外，在实现unsafe trait的时候，也必须相应地使用unsafe impl才可以。 </p>
<p><strong>(2) unsafe块</strong> </p>
<p><strong>被 unsafe 关键字标记的不安全函数或方法只能在 unsafe 块中被调用</strong>。如代码清单 13-4所示。 </p>
<p>代码清单<strong>13-4</strong>：<strong>unsafe</strong>块示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">104</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_utf8_unchecked</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-4中使用from_utf8_unchecked函数将字节数组转为字符串，这里必须使用unsafe块，否则会报如代码清单13-5所示的错误。 </p>
<p>代码清单<strong>13-5</strong>：未使用<strong>unsafe</strong>块调用<strong>unsafe</strong>函数会报错 </p>
<pre><code>error[E0133]: call to unsafe function requires unsafe function or block ---&gt; src/main.rs:
|    String::from_utf8_unchecked(hello);
|    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function</code></pre><p>从代码清单13-5中看得出来，在未使用unsafe块的情况下就调用unsafe函数，编译器会报错。强制使用unsafe块，意味着强制让开发者将unsafe函数的调用和安全代码隔离起来，便于排查错误。 </p>
<p>除调用不安全函数或方法外，unsafe块也可以进行其他操作。</p>
<h3 id="13-1-2-访问和修改可变静态变量"><a href="#13-1-2-访问和修改可变静态变量" class="headerlink" title="13.1.2 访问和修改可变静态变量"></a>13.1.2 访问和修改可变静态变量</h3><p>静态变量是全局可访问的。对于不可变静态变量来说，访问它不存在任何安全问题。Rust也允许定义可变的静态变量，但是试想一下，如果多个线程同时访问这个可变静态变量，会发生什么？答案是：会引起数据竞争。这是Rust安全检查绝对不允许发生的事情。</p>
<p>所以，<strong>如果一定要定义可变的静态变量，就必须在unsafe块中进行操作，以此来警示该操作属于不安全行为，开发者必须保证其安全。</strong>如代码清单13-6所示。 </p>
<p>代码清单<strong>13-6</strong>：访问和修改可变静态变量必须在<strong>unsafe</strong>块中 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">static</span> <span class="token keyword">mut</span> COUNTER<span class="token punctuation">:</span> u32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> inc <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        COUNTER <span class="token operator">+=</span> inc<span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"COUNTER： P{}"</span><span class="token punctuation">,</span> COUNTER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-6中定义了可变静态变量COUNTER，并在unsafe块中对其进行修改和访问。如果此时不使用unsafe块，编译器就会报错提示你应该使用unsafe块来操作可变静态变量。 </p>
<p>一般情况下，很少有人使用可变静态变量，但是要和其他语言交互（尤其是C语言）的时候，可变静态变量就会非常有用，在后面与C交互的内容会有更详细的介绍。 </p>
<h3 id="13-1-3-Union联合体"><a href="#13-1-3-Union联合体" class="headerlink" title="13.1.3 Union联合体"></a>13.1.3 Union联合体</h3><p><strong>Rust也提供了像C语言中那样的Union联合体。Union和Enum相似，Enum属于Tagged Union，优点在于其存储的 Tag 可以保证内存安全，缺点是 Tag 要占用多余的内存空间。而Union 并不需要多余的 Tag，如果想访问其中的字段，就必须靠程序逻辑来保证其安全性，如果访问错误，就会引发未定义行为。所以，它的优点是比Enum省内存空间，缺点是使用起来不安全。</strong> </p>
<p><strong>Union 的内存布局和 Enum 也是相似的，字段共用同一片内存空间，所以也被称为共用体。内存对齐方式也是按字段中内存占用最大的类型为主。Rust里引入Union的主要原因还是为了方便Rust和C语言“打交道”。</strong>如代码清单13-7所示。 </p>
<p>代码清单<strong>13-7</strong>：使用<strong>Union</strong>联合体和<strong>Struct</strong>模拟<strong>Enum</strong>类型</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[repr(C)]</span>
union U <span class="token punctuation">{</span>
    i<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> f32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[repr(C)]</span>
<span class="token keyword">struct</span> Value <span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> u8<span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> U<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[repr(C)]</span>
union MyZero <span class="token punctuation">{</span>
    i<span class="token punctuation">:</span> Value<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> Value<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> MyEnumZero <span class="token punctuation">{</span>
    <span class="token function">I</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">F</span><span class="token punctuation">(</span>f32<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> int_0 <span class="token operator">=</span> MyZero<span class="token punctuation">{</span>i<span class="token punctuation">:</span> Value<span class="token punctuation">{</span>tag<span class="token punctuation">:</span> <span class="token string">b'0'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> U<span class="token punctuation">{</span>i<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> float_0 <span class="token operator">=</span> MyZero<span class="token punctuation">{</span>i<span class="token punctuation">:</span> Value<span class="token punctuation">{</span>tag<span class="token punctuation">:</span> <span class="token string">b'1'</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> U<span class="token punctuation">{</span>f<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-7中使用Union和Struct来模拟一个Enum类型MyZero。该类型的特点是，可以同时存储整数0和浮点数0.0。 </p>
<p>代码第1～5行使用union关键字定义了Union联合体，包含两个字段i和f，用i32和f32类型分别代表整数和浮点数。<strong>当使用Union联合体时，配合使用了＃[repr（C）]属性是必需的，该属性会告诉Rust编译器，此联合体应该使用和C语言一样的内存布局。</strong>如果不加＃[repr（C）]属性，则有可能发生未定义行为。 </p>
<p>代码第6～10行定义了结构体Value，包含tag字段和value字段，是为了模拟Enum类型中的值。因为Enum类型中的每个值还包含一个tag。此处也必须为结构体Value使用＃[repr（C）]属性，因为value字段是联合体类型U。 </p>
<p>代码第11～15行定义了MyZero联合体，包含两个字段i和f，它们的类型均为Value。该联合体相当于代码第16～19行定义的一个Enum类型MyEnumZero。 </p>
<p>然后就可以在main函数中使用MyZero了，每次使用一个值。需要注意的是，代码清单13-7并不能正常编译运行。因为当前版本的Rust不支持<strong>Union</strong>联合体的字段为非<strong>Copy</strong>（Non-Copy）类型，联合体MyZero中的字段就是非Copy类型。如果使用<strong>＃！[feature（untagged_unions）]</strong>特性，该段代码就能正常编译，不久的将来该特性会稳定。 </p>
<p>接下来对代码清单13-7做一次重构，让它可以正常运行。如代码清单13-8所示。 </p>
<p>代码清单<strong>13-8</strong>：对代码清单<strong>13-7</strong>进行重构</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[repr(u32)]</span>
<span class="token keyword">enum</span> Tag <span class="token punctuation">{</span> I<span class="token punctuation">,</span> F<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[repr(C)]</span>
union U <span class="token punctuation">{</span>
    i<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> f32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[repr(C)]</span>
<span class="token keyword">struct</span> Value <span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> Tag<span class="token punctuation">,</span>
    u<span class="token punctuation">:</span> U<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">is_zero</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> Value<span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">match</span> v <span class="token punctuation">{</span>
            Value <span class="token punctuation">{</span>tag<span class="token punctuation">:</span> Tag<span class="token punctuation">:</span><span class="token punctuation">:</span>I<span class="token punctuation">,</span> u<span class="token punctuation">:</span> U<span class="token punctuation">{</span>i<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>
            Value <span class="token punctuation">{</span>tag<span class="token punctuation">:</span> Tag<span class="token punctuation">:</span><span class="token punctuation">:</span>F<span class="token punctuation">,</span> u<span class="token punctuation">:</span> U<span class="token punctuation">{</span>f<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>
            _ <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> int_0 <span class="token operator">=</span> Value<span class="token punctuation">{</span>tag<span class="token punctuation">:</span> Tag<span class="token punctuation">:</span><span class="token punctuation">:</span>I<span class="token punctuation">,</span> u<span class="token punctuation">:</span> U<span class="token punctuation">{</span>i<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> float_0 <span class="token operator">=</span> Value<span class="token punctuation">{</span>tag<span class="token punctuation">:</span> Tag<span class="token punctuation">:</span><span class="token punctuation">:</span>F<span class="token punctuation">,</span> u<span class="token punctuation">:</span> U<span class="token punctuation">{</span>f<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token function">is_zero</span><span class="token punctuation">(</span>int_0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token function">is_zero</span><span class="token punctuation">(</span>float_0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码第1、2行定义了Enum枚举体Tag，包含I和F两个值，分别代表整数和浮点数。注意，它<strong>使用了＃[repr（u32）]属性来指定布局，如果不使用该属性，则默认是Rust类型。因为该枚举体准备在联合体中使 用，所以必须指定好布局，否则可能会出现未定义行为。</strong> </p>
<p>代码第3～7行使用union关键字定义了联合体U，包含字段i和f，同代码清单13-7中一样。 </p>
<p>代码第8～12行定义了结构体Value，包含字段<strong>tag</strong>和u，分别是Tag和U类型。该结构体所指代的意义和代码清单13-7中一致。 </p>
<p>代码第13～21行定义了is_zero函数，该函数传入Value类型的参数，返回布尔值，目的是为了判断传入的Value是否为零。整数零和浮点数零均会返回true。注意，该函数中对Value可能的值进行了匹配，包含在unsafe块中。对联合体U的字段进行操作是不安全的行为，所以必须放到unsafe 块中。另外，代码第17行有浮点数字面量参与匹配，在编译时会发出警告，该问题暂时可以忽略，这里只作为教学示例，Rust官方也正在完善此问题。 </p>
<p>代码第22～28行的main函数中，声明了int_0和float_0两个Value的实例，调用is_zero函数均得到了预期的结果。代码第27行验证了联合体U的内存对齐是4字节，和预期的一致，并没有占空间的<strong>tag</strong>。 </p>
<p>联合体和枚举体一样，每次只能使用一个字段，因为联合体中的字段均共用内存空间。如果不小心使用了未初始化的字段，则可能发生未定义行为。如代码清单13-9所示。 </p>
<p>代码清单<strong>13-9</strong>：访问联合体中未初始化的字段</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[repr(C)]</span>
union U <span class="token punctuation">{</span>
    i<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    f<span class="token punctuation">:</span> f32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> u <span class="token operator">=</span> U<span class="token punctuation">{</span>i<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        u<span class="token punctuation">.</span>f
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 0.000000000000000000000000000000000000000000001</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// unsafe {</span>
    <span class="token comment" spellcheck="true">//        let i = &amp;mut u.i;</span>
    <span class="token comment" spellcheck="true">//         let f = &amp;mut u.f;</span>
    <span class="token comment" spellcheck="true">// };</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-9中定义了联合体U，在main函数中定义了U的实例。在代码第9行，本来应该访问字段i，但是这里错误地访问了字段f，导致第12行的输出为第11行注释中的浮点数。 </p>
<p>值得注意的是，代码第12 行的输出等价于f32：：from_bits（1）函数调用。在当前示例中，该输出属于正常的输出，不属于未定义行为。但是广义地看，这种用法是不安全的，在某些应用场合下很可能会造成不可预期的结果。 </p>
<p>代码第13～16行被注释的原因是它们会报错。对于一个联合体来说，不能同时使用两个字段，当然也不能同时出借两个字段的可变借用。虽然可以同时出借两个不可变借用，但这种用法依旧不安全，没有人会故意这样使用。 </p>
<h3 id="13-1-4-解引用原生指针"><a href="#13-1-4-解引用原生指针" class="headerlink" title="13.1.4 解引用原生指针"></a>13.1.4 解引用原生指针</h3><p><strong>Rust提供了<em>const T（不变）和</em>mut T（可变）两种指针类型</strong>。因为这两种指针和C语言中的指针十分相近，所以叫其原生指针（RawPointer）。原生指针具有以下特点： </p>
<ul>
<li>并不保证指向合法的内存。比如很可能是一个空指针。 </li>
<li>不能像智能指针那样自动清理内存。需要像C语言那样手动管理内存。</li>
<li>没有生命周期的概念。也就是说，编译器不会对其提供借用检查。</li>
<li>不能保证线程安全。 </li>
</ul>
<p>可见，<strong>原生指针并不受Safe Rust提供的那一层“安全外衣”保护，所以也被称为“裸指针”</strong>。所以，在对裸指针进行解引用操作的时候，属于不安全行为。如代码清单13-10所示。 </p>
<p>代码清单<strong>13-10</strong>：解引用裸指针是不安全行为 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> String<span class="token punctuation">;</span>
    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> String<span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> address <span class="token operator">=</span> <span class="token number">0x7fff1d72307d</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r3 <span class="token operator">=</span> address <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> String<span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"r1 is: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"r2 is: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 段错误</span>
        <span class="token comment" spellcheck="true">// assert_eq!(*r1, *r3)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-10中代码第2～4行，通过as操作符将变量s的不可变引用和可变引用分别转换成不可变裸指针<strong>*const String</strong>和可变裸指针<strong>*mut String</strong>。注意，这里同时出现了不可变和可变的指针，但它们不是引用，Rust借用检查会对它们“睁一只眼，闭一只眼”。创建裸指针本身并不会触发任何未定义行为，所以不需要放到unsafe块中操作。 </p>
<p>代码第5行验证裸指针r1和r2是否相同。事实上，它们是相同的。代码第6、7行通过随意指定一个地址address，以及as操作符重新创建了一个裸指针r3。 </p>
<p>代码第9、10行通过“*”操作符对r1和r2进行解引用，打印输出字符串s的内容。但这个操作是不安全的，必须在unsafe块下进行。</p>
<p>被注释的代码第12行解引用裸指针r3，会引发段错误（Segmentation Fault）。因为r3是随意定义的指针，开发者根本无法确定它指向的是否为合法内存。</p>
<h2 id="13-2-基于Unsafe进行安全抽象"><a href="#13-2-基于Unsafe进行安全抽象" class="headerlink" title="13.2 基于Unsafe进行安全抽象"></a>13.2 基于Unsafe进行安全抽象</h2><p><strong>通过unsafe关键字和unsafe块可以执行一些跳过安全检查的特定操作，但并不代表使用了unsafe就不安全。在日常开发中，往往需要在unsafe的基础上抽象安全的函数。使用unsafe块的函数需要满足基本的“契约”，才能保证整个函数的安全性。</strong>除此之外，还需要了解一些其他的概念，才能更安全地使用Unsafe Rust。</p>
<h3 id="13-2-1-原生指针"><a href="#13-2-1-原生指针" class="headerlink" title="13.2.1 原生指针"></a>13.2.1 原生指针</h3><p><strong>原生指针是Unsafe Rust中最常用的</strong>，它主要有以下两种用途： </p>
<ul>
<li><strong>在需要的时候跳过 Rust 安全检查</strong>。有些情况下，程序逻辑完全不会有任何内存安全问题，使用原生指针就可以避免那些不必要的安全检查，从而提升性能。 </li>
<li><strong>与C语言“打交道”，需要使用原生指针</strong>。 </li>
</ul>
<p>标准库为原生指针内建了很多方法和函数，为开发者利用指针进行各种操作提供了方便。在此主要介绍以下几个内建函数和方法： </p>
<ul>
<li>std：：ptr：：null函数和is_null方法 </li>
<li>offset方法 </li>
<li>read/write方法 </li>
<li>replace/swap方法 </li>
</ul>
<p>这几个是比较常用的函数和方法，在标准库原生指针模块中还有其他很多方法，可以通过相关文档查看更多。 </p>
<p><strong>(1) 创建空指针</strong> </p>
<p>创建空指针并判断是否为空指针的实现如代码清单13-11所示。 </p>
<p>代码清单<strong>13-11</strong>：创建空指针并判断是否为空指针</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> p<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> u8 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> u8 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u32 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">.</span>is_null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-11中的代码第2、3行，通过<strong>std</strong>：：<strong>ptr</strong>模块提供的null函数可以创建一个空指针，通过is_null方法可以判断其是否为空。 </p>
<p>代码第4～6行，通过&amp;str类型字符串s的as_ptr方法得到一个不可变原生指针，该指针指向合法的堆内存，所以它不是一个空指针。注意，第5行指针ptr的类型为<strong>*const u8</strong>，这是因为字符串是以字节为单位存储的。</p>
<p>代码第7～9行，通过数组s的as_mut_ptr方法得到类型为<strong>*mut u32</strong>的可变原生指针，因为数组中的元素为数字类型。同样，它也不是空指针。</p>
<p>在创建空指针的时候，并不会引起任何未定义行为，所以这里并没有使用unsafe块。 </p>
<p><strong>(2) 使用offset方法</strong> </p>
<p>顾名思义，<strong>offset</strong> 就是指偏移量，通过该方法可以指定相对于指针地址的偏移字节数，从而得到相应地址的内容。如代码清单13-12所示。</p>
<p>代码清单<strong>13-12</strong>：使用<strong>offset</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">"Rust"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> u8 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// u</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// t</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">as</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// y</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-12中，代码第2、3行得到一个<strong>*const u8</strong>类型的不可变指针ptr，该指针指向字符串s的起始字符。然后通过offset方法获取字符串s中的其他字符。 </p>
<p>代码第 4～8 行，因为 offset 方法是 unsafe 方法，所以要在 unsafe块中调用。其中“<strong>*ptr.offset（1） as char</strong>”等价于“<strong>*（ptr.offset（1））as char</strong>”。上面之所以可以省略括号，是因为解引用操作优先级低于方法调用，但高于<strong>as</strong>操作符。通过给offset方法指定偏移量（以字节为单位），就可以得到相应的字符。代码第5、6行分别得到字符u和t。 </p>
<p>因为 offset 方法并不能保证传入的偏移量是合法的，如果超出了字符串的边界，就可能会产生未定义行为，所以该方法被标记为unsafe方法。如代码第7行所示，打印出的字符完全是不可预料的。 </p>
<p><strong>(3) 使用read/write方法</strong> </p>
<p>通过read和write方法可以读取或写入指针相应内存中的内容。注意，这两个方法也是unsafe方法。代码清单13-13展示了read方法的使用。</p>
<p>代码清单<strong>13-13</strong>：使用<strong>read/write</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> u8 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> char<span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">[</span>u32<span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> x <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token operator">&amp;</span>str<span class="token punctuation">;</span>
    <span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        y<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-13中第2行定义了String类型字符串x，代码第3行通过调用x的<strong>as_ptr</strong>方法得到其指向堆内存的原生指针，因为String类型本质是一个字节序列数组，所以该指针类型是<strong>*const u8</strong>，指向第一个字节序列。第4～6行在unsafe块中调用指针y的read方法，获取到字符串的第一个字符，并将其转换为字符类型，与预期的字符进行比较。 </p>
<p>注意，read方法是unsafe方法，这是因为read方法通过指针来读取当前指针指向的内存，但不会转移所有权。也就是说，在该指针读取完内存之后，该内存有可能会被其他内容覆盖。 </p>
<p>代码第7～11行定义了固定长度数组x，并通过调用as_ptr方法得到类型为<strong>*const [u32</strong>；<strong>4]</strong>的原生指针y。通过调用y的read方法，可以读取到数组的内容。注意，这里的原生指针类型是带长度的，如果将类型改为<strong>*const [u32；3]</strong>，则通过read方法只能读取到前三个元素的值。 </p>
<p>代码第12～16行定义了一个动态数组x，但这次并没有用as_ptr获取指向堆内存的原生指针，而是直接将x的引用通过as操作符转换为原生指针。这次调用该指针的read方法读出来的并不是该动态数组的第一个元素，而是全部元素。 </p>
<p>要注意通过as_ptr获取和由引用转换为原生指针的区别。通过as_ptr得到的指针是字符串或数组内部的指向存放数据堆（或栈）内存的指针，而引用则是对字符串或数组本身的引用。 </p>
<p>对应于read方法，代码第17～23行展示了write方法的使用。write方法会覆盖掉指定位置上内存的内容。同理，write方法也属于unsafe方法。</p>
<p><strong>(4) 使用replace/swap方法</strong> </p>
<p>利用replace或swap方法，可以快速替换指定位置的内存数据。如代码清单13-14所示。 </p>
<p>代码清单<strong>13-14</strong>：使用<strong>replace/swap</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> v_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> i32 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> old_v <span class="token operator">=</span> v_ptr<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> old_v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> v_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> Vec<span class="token operator">&lt;</span>i32<span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> old_v <span class="token operator">=</span> v_ptr<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_v<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>u32<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token punctuation">[</span>u32<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        x<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-14中，第2、3行通过as_mut_ptr得到动态数组v中指向堆内存的可变原生指针，所以该指针指向动态数组的第一个元素。第4～8行，在unsafe块中使用<strong>replace</strong>方法将v的第一个元素替换为5。该方法会返回旧的值，所以old_v的值是1，而动态数组v就变成了[5，2]。 </p>
<p>第9～15行同样是动态数组v，但只是将v的可变引用转换为了可变原生指针，该指针指向数组的全部元素。所以在unsafe块中使用replace方法，传入的参数是整个Vec＜i32＞类型的动态数组，而非单个元素。 </p>
<p>代码第16～24行展示了<strong>swap</strong>方法的使用，该方法接收两个可变原生指针作为参数，并将其指向内存位置上的数据进行互换。 </p>
<p>代码第16～18行定义了固定长度数组array，并使用as_mut_ptr得到两个可变原生指针x和y，类型均为<strong>*mut [u32；2]</strong>。 </p>
<p>代码第19～24行通过read方法可以得到x和y的数据，分别为[0，1]和[1，2]。然后调用x的swap方法与y互换数据，最终得到结果[1，0，1，3]。交互过程如图13-1所示。 </p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210522174511518.png" alt="image-20210522174511518"></p>
<p>从图 13-1 可以看出，swap 方法因为传入的可变原生指针都来自同一个数组，操作的内存区域有重叠的地方，这种操作很有可能引起内部数据混乱，从而引发未定义行为，所以swap也是unsafe方法。 </p>
<p>在<strong>std</strong>：：<strong>mem</strong>模块中提供了一个安全的<strong>swap</strong>方法，其函数签名为<strong>fn swap</strong>＜<strong>T</strong>＞（<strong>x</strong>：<strong>&amp;mut T</strong>，<strong>y</strong>：<strong>&amp;mut T</strong>），注意其参数为可变引用。 </p>
<p>因为可变引用是独占的，不可能对同一个变量进行两次可变借用，所以就保证了该方法不可能出现内存重叠的情况。同样，std：：mem模块中也提供了安全的<strong>replace</strong>方法。 </p>
<p><strong>（5）使用原生指针进行安全抽象</strong> </p>
<p>在标准库中有很多方法是基于Unsafe Rust实现的安全抽象。比如，Vec＜T＞动态数组的insert方法。假设使用Safe Rust来实现insert方法，可以想象得到，将无法避免要使用多次&amp;mut Vec＜T＞，这是完全无法做到的。Safe Rust的借用检查不允许对同一个变量进行多次可变借用。 </p>
<p>在这种情况下，使用原生指针是唯一的办法。 </p>
<p>代码清单13-15展示了Vec＜T＞中insert方法的源码。代码清单<strong>13-15</strong>：<strong>Vec</strong>＜<strong>T</strong>＞的<strong>insert</strong>方法源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> index<span class="token punctuation">:</span> usize<span class="token punctuation">,</span> element<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> len <span class="token operator">==</span> <span class="token keyword">self</span><span class="token punctuation">.</span>buf<span class="token punctuation">.</span><span class="token function">cap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span>index <span class="token keyword">as</span> isize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">copy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">set_len</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-15中，insert方法传入了三个参数：&amp;mut self、index和element，分别表示Vec＜T＞的实例可变借用、要插入位置的索引和要插入的元素。 </p>
<p>代码第2、3行通过断言保证了index的值不能超过数组长度len，从而保证了该函数的基本“契约”：插入的索引不能越界。 </p>
<p>代码第4～6行，判断数组的长度是否达到了数组的容量上限，如果达到，则通过reserve方法来扩容。传给reserve的参数1代表每次扩展一个类型大小的字节数。 </p>
<p>从代码第7行开始，在unsafe块下进行操作。 </p>
<p>代码第8～12行，将这三行代码放到一个单独块中是因为它们表示一个完整的插入逻辑。代码第9行通过as_mut_ptr方法获取到实例的原生可变指针，再进一步通过offset方法和index的值，得到要插入位置的指针p。代码第10行通过ptr：：copy方法将当前位置的内容右移一位，这样才能给当前位置留下空位来便于插入新的元素。代码第11行使用ptr：：write向该位置写入新的元素。 </p>
<p>代码第13行将数组的长度加一。至此，整个insert方法才算完整。综合来说，insert 方法内部使用了 unsafe 块直接操作原生指针，通过断言判断指定插入的<strong>index</strong>无法越界操作，以及通过判断长度是否达到容量极限来决定是否进行扩容。如果没有这两个判断条件，insert方法就无法保证安全，它就不是一个安全抽象，就必须在方法签名前面加unsafe标签。 </p>
<h3 id="13-2-2-子类型与型变"><a href="#13-2-2-子类型与型变" class="headerlink" title="13.2.2 子类型与型变"></a>13.2.2 子类型与型变</h3><p><strong>子类型（subtype）在计算机科学中是相对于另外一种有替代关系的数据类型（父类型，supertype）而言的。一般来说，可以用在父类型的地方，也可以用子类型来替代。在类型理论中，子类型关系一般写为A＜：B，这意味着A是B的子类型。</strong> </p>
<p>在面向对象语言中，子类型也被称为子类型多态（subtype polymorphism），通过多态消除了类型之间的耦合性，实现统一接口。比如，在需要圆形工作的环境，也可以使用其他任何圆形几何体（比如圆环），它们的关系可表示为<strong>Ring</strong>＜：<strong>Circle</strong>。在面向对象语言中，一般用<strong>里氏替换原则（Liskov Substitution Principle，LSP）来描述这种关系：所有引用基类（父类）的地方必须能透明地使用其子类的对象。通俗地说，就是允许子类可以方便扩展父类的功能，但不能改变父类原有的功能。LSP是接口设计和继承复用的基石，遵循该原则可以让代码有更好的维护性和复用性。</strong> </p>
<p><strong>(1) 型变的基本概念</strong> </p>
<p>在原始类型的基础上通过类型构造器构造更复杂的类型时，原始类型的子类型关系在复杂类型之上如何变化，也是支持子类型编程语言需要考虑的问题。计算机科学中把这种根据原始类型子类型关系确定复杂类型子类型关系的规则称为型变（variance）。比如，如果 Cat是Animal的子类型，Cat类型可以出现在任何需要Animal类型表达式的地方。那么List＜Cat＞是否可以出现在List＜Animal＞的地方？下面看看型变的三种形式就知道答案了。 </p>
<p>型变一般可以分为三种形式： </p>
<ul>
<li>协变（covariant）。可以继续保持子类型关系。Cat是Animal的子类型，那么List＜Cat＞也是List＜Animal＞的子类型。</li>
<li>逆变（contravariant）。逆转子类型关系。Cat是Animal的子类型，那么List＜Animal＞是List＜Cat＞的子类型。 </li>
<li>不变（invariant）。既不保持，也不逆转子类型关系。也就是说，Cat是Animal的子类型，但List＜Animal＞和List＜Cat＞是没有关系的。 </li>
</ul>
<p><strong>Rust语言中只有生命周期具有子类型关系。如果有生命周期满足“＇long：＇short”这样的关系，那么可以说＇long是＇short的子类型。这个关系代表生命周期＇long存活的时间比＇short要长，也可以说，长生命周期是短生命周期的子类型。比如，&amp;＇static str是&amp;＇a str的子类型。</strong> </p>
<p>了解由生命周期组成的复合类型，具体什么样的型变规则很重要。因为在编写 Unsafe代码的时候，很可能会因为没有合理使用型变而造成 未定义行为。 </p>
<p>未合理使用型变将会引起未定义行为 </p>
<p>代码清单13-16展示了自定义的内部可变类型。 </p>
<p>代码清单<strong>13-16</strong>：自定义内部可变类型<strong>MyCell＜T＞</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> T<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Copy<span class="token operator">></span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        MyCell<span class="token punctuation">{</span> value<span class="token punctuation">:</span> x<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">;</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> _ <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-16中第1～3行定义了泛型结构体MyCell＜T＞，包含一个字段value。 </p>
<p>代码第4～17行为MyCell＜T＞实现了new、get和set三个方法。其中，new和get方法没什么特别，重点是set方法。 </p>
<p>代码第11～16行在set方法中使用了unsafe块。通过ptr：：write方法将当前值覆盖为新传入的值。其中ptr：：write的第一个参数是由&amp;self.value先转为不可变原生指针，再由不可变原生指针转为可变原生指针，因为<strong>Rust</strong>不允许直接将不可变借用转为可变原生指针。 </p>
<p>MyCell＜T＞看上去暂时没什么问题，接下来实现两个函数来使用它，如代码清单 13-17所示。 </p>
<p>代码清单<strong>13-17</strong>：使用<strong>MyCell＜T＞</strong>示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> step1<span class="token operator">&lt;</span><span class="token string">'a>(r_c1: &amp;MyCell&lt;&amp;'</span>a i32<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> val<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
    <span class="token function">step2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>valm<span class="token punctuation">,</span> r_c1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"step1 value: {}"</span><span class="token punctuation">,</span> r_c1<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> step2<span class="token operator">&lt;</span><span class="token string">'b>(r_val: &amp;'</span>b i32<span class="token punctuation">,</span> r_c2<span class="token punctuation">:</span> <span class="token operator">&amp;</span>MyCell<span class="token operator">&lt;</span><span class="token operator">&amp;</span>'b i32<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r_c2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>r_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> X<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cell <span class="token operator">=</span> MyCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">step1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cell<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">" end value: {}"</span><span class="token punctuation">,</span> cell<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-17中第1～5行定义了函数step1，只接收一个参数r_c1，为&amp;MyCell＜&amp;＇a i32＞类型。函数体里定义了局部变量val，并将其引用&amp;val传给了stpe2函数。 </p>
<p>代码第6～8行定义了step2函数，接收两个类型分别为&amp;＇b i32和&amp;MyCell＜&amp;＇a i32＞的参数。 </p>
<p>代码第9行定义了一个静态变量X。 </p>
<p>在main函数中，代码第11行使用静态变量的引用&amp;X声明了MyCell实例cell。代码第12行将&amp;cell传入step1函数中。最后打印cell.value的值。</p>
<p>代码清单 13-17 可以正常编译运行。但是这里存在未定义行为的风险。注意看代码第 3行，step1函数中调用step2，并传入了局部变量val的不可变引用&amp;val。然后在step2函数中使用set函数将传入&amp;val的值设置为新值。整个过程都是通过传递引用&amp;val来实现的。试想一下：当step2函数执行完再返回到step1会发生什么？当step1调用执行完，整个调用栈就会被清理，局部变量val将不复存在，那么&amp;val也会成为悬垂指针，这意味着cell.value也会成为无法预期的值。 </p>
<p>这里Rust的借用检查为什么没有起作用呢？ </p>
<p>原因在于现在定义的MyCell＜T＞是一个协变类型。Rust中大部分结构都是协变的，像这种自定义的结构体默认也是协变的。代码清单13-17中，静态变量X的引用&amp;X的生命周期是＇static的，所以在main函数中传入step1的是&amp;MyCell＜&amp;＇static i32＞类型，而step1函数定义中要求是&amp;MyCell＜&amp;＇a i32＞类型。正因为MyCell＜T＞是协变，&amp;＇static i32是&amp;＇a i32的子类型，所以&amp;MyCell＜&amp;＇static i32＞是&amp;MyCell＜&amp;＇a i32＞的子类型。按照子类型的规则，&amp;MyCell＜&amp;＇static i32＞可以代替&amp;MyCell＜&amp;＇a i32＞。</p>
<p>实际上，Rust允许这种协变是以“忘记原始生命周期”为代价的。所以在代码第3行中，step1函数第一个参数&amp;val的生命周期本来应该是＇a，因为允许协变而成为＇static，所以借用检查就正常通过了。 </p>
<p>可见，如果没有合理利用协变，将会产生未定义行为的风险。那么如何修复它呢？既然知道了问题的原因，解决方案就简单了：把<strong>MyCell＜T＞</strong>的协变性质改成逆变或不变就可以。 </p>
<p><strong>(2) 使用PhantomData＜T＞</strong> </p>
<p>之前的章节介绍过，<strong>PhantomData</strong>＜<strong>T</strong>＞是一个零大小类型的标记结构体，也叫作“幻影类型”，在需要指定一个并不使用的类型时，就可以使用它。除此之外，PhantomData＜T＞还扮演以下三种其他角色： </p>
<ul>
<li>型变。可以产生协变、逆变和不变三种情况。 </li>
<li>标记拥有关系。和drop检查有关。 </li>
<li>自动trait实现。比如Send和Sync。</li>
</ul>
<p>所以，利用PhantomData＜T＞的型变特性，就可以修复代码清单13-17的问题，如代码清单13-18所示。 </p>
<p>代码清单<strong>13-18</strong>：利用<strong>PhantomData＜T＞</strong>修改<strong>MyCell＜T＞</strong>为不变</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>marker<span class="token punctuation">:</span><span class="token punctuation">:</span>PhantomData<span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> T<span class="token punctuation">,</span>
    mark<span class="token punctuation">:</span> PhantomData<span class="token operator">&lt;</span><span class="token keyword">fn</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Copy<span class="token operator">></span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyCell<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        MyCell<span class="token punctuation">{</span> value<span class="token punctuation">:</span> x<span class="token punctuation">,</span> mark<span class="token punctuation">:</span> PhantomData <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">;</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> _ <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 13-18 重构了 MyCell＜T＞的定义，重点是在之前的基础上增加了一个类型为<strong>PhantomData＜fn（T）＞</strong>的mark字段。PhantomData＜fn（T）＞类型属于逆变，因为<strong>fn（T）</strong>指针类型在Rust中是逆变，未来的Rust版本中可能会修改为不变。 </p>
<p>修改完MyCell＜T＞之后再次执行代码清单13-17中的代码，编译器会报以下错误：</p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210522194745021.png" alt="image-20210522194745021"></p>
<p>看得出来，Rust借用检查开始正常工作，代码变得更加安全。</p>
<p><strong>(3) 协变、逆变与不变类型列表</strong> </p>
<p>以下罗列了<strong>Rust中几个重要的型变类型</strong>： </p>
<ul>
<li><strong>&amp;＇a T在＇a和T上是协变，对应的*const T也是协变。</strong> </li>
<li><strong>&amp;＇a mut T在＇a上是协变，但是在T上是不变。</strong> </li>
<li><strong>Fn（T）-＞U在T上是不变，在U上是协变。</strong> </li>
<li><strong>Box＜T＞、Vec＜T＞，以及其他集合对于它们包含的类型来说都是协变。</strong> </li>
<li><strong>UnsafeCell＜T＞、Cell＜T＞、RefCell＜T＞、Mutex＜T＞，以及其他内部可变类型在T上都是不变，对应的*mut T也是不变。</strong> </li>
</ul>
<p>比如，<strong>&amp;mut&amp;＇static str</strong>和<strong>&amp;mut&amp;＇a str</strong>不存在子类型关系，所以它们是不变。如果允许它们协变，将会有产生未定义行为的可能，正如代码清单 13-16 展示的那样。所以， <strong>UnsafeCell＜T＞</strong>等内部可变性（包括可变原生指针<strong>*mut T</strong>）都是不变。 </p>
<p>对结构体来说，如果包含的字段全部是协变，则结构体是协变，否则为不变。所以，对<strong>Phantomdata</strong>＜<strong>T</strong>＞类型来说，则有以下规则： </p>
<ul>
<li><p>PhantomData＜T＞，在T上是协变。 </p>
</li>
<li><p>PhantomData＜&amp;＇a T＞，在＇a 和T上是协变。 </p>
</li>
<li><p>PhantomData＜&amp;＇a mut T＞，在＇a上是协变，在T上是不变。 </p>
</li>
<li><p>PhantomData＜*const T＞，在T上是协变。 </p>
</li>
<li><p>PhantomData＜*mut T＞，在T上是不变。 </p>
</li>
<li><p>PhantomData＜fn（T）＞，在T上是逆变，如果以后修改语法，会成为不变。· PhantomData＜fn（）-＞T＞，在T上是协变。 </p>
</li>
<li><p>PhantomData＜fn（T）-＞T＞，在T上是不变。 </p>
</li>
<li><p>PhantomData＜Cell＜&amp;＇a （）＞＞，在＇a上是不变。 </p>
</li>
</ul>
<p>Rust中仅存在函数指针<strong>fn（T）</strong>的逆变情况，如代码清单13-19所示。</p>
<p>代码清单<strong>13-19</strong>：<strong>fn（T）</strong>的逆变示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">trait</span> A <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> B<span class="token punctuation">;</span>
<span class="token keyword">impl</span> A <span class="token keyword">for</span> B <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> B <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    B<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// let s = "hello".to_string();</span>
    <span class="token comment" spellcheck="true">// B.foo2(&amp;s)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-19中，第1～3行定义了traitA。该trait包含foo函数签名，接收一个&amp;＇static str类型的参数。 </p>
<p>代码第4～9行定义了结构体B，并为其实现A。注意，此时foo函数的签名已经改变为接收一个&amp;str类型的参数。 </p>
<p>代码第10～14行为结构体B单独实现另外一个函数foo2，接收类型为&amp;＇static str的参数。 </p>
<p>在代码第15～19行的main函数中，直接调用结构体实例B的foo方法，传入一个字符串字面量，可以正常编译运行。注意，字符串字面量为&amp;＇static str类型。代码第17、18行编译会出错，所以将其注释。 </p>
<p>从该示例中可以得出以下结论： </p>
<ul>
<li>fn（T）在实现<strong>trait</strong>方法时，是逆变。因为&amp;＇static str＜：&amp;＇a str，而现在fn（&amp;＇a str）可以替代需要fn（&amp;＇static str）的情况，所以得出 fn（&amp;＇a str）＜：fn（&amp;＇static str），逆转了原有类型的子类 型关系。</li>
<li>普通的函数调用，参数是不变。当参数需要&amp;＇static str类型时，不能用&amp;str代替它。但是函数的返回值是协变，当返回值是&amp;str的时候，可以返回&amp;＇static str类型的值作为替代。 </li>
</ul>
<p>代码清单13-20是另一个逆变的示例。 </p>
<p>代码清单<strong>13-20</strong>：另一个<strong>fn（T）</strong>逆变示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">bar</span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token keyword">fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token string">'static str), v: &amp;'</span><span class="token keyword">static</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-20中，在bar函数签名中，参数f为<strong>fn（&amp;＇static str</strong>）类型。在main函数中，代码第 9 行将函数指针 foo 传给了 bar 函数，代码正常编译运行。函数指针foo的类型为<strong>fn（&amp;str）</strong>，所以满足<strong>fn（&amp;str）＜：fn（&amp;＇static str）</strong>，此处为逆变。 </p>
<p>在不久的将来，<strong>Rust</strong>官方有可能取消逆变。 </p>
<p>总之，了解型变对写Unsafe代码很有帮助。当协变不会引起未定义行为的时候，可以用协变，否则就保证该类型为不变或逆变。 </p>
<h3 id="13-2-3-未绑定生命周期"><a href="#13-2-3-未绑定生命周期" class="headerlink" title="13.2.3 未绑定生命周期"></a>13.2.3 未绑定生命周期</h3><p>Unsafe代码很容易产生未绑定生命周期（Unbound Lifetime），即可以被随意推断的生命周期。主要注意下面两种情况： </p>
<ul>
<li>当从原生指针得到引用时，比如<strong>&amp;*raw_ptr</strong>。 </li>
<li>使用 std：：mem：：transmute 方法但没有显式给定生命周期，比如 transmute：：＜&amp;T，&amp;U＞（foo）。 </li>
</ul>
<p>代码清单13-21展示了从原生指针得到引用的情况。 </p>
<p>代码清单<strong>13-21</strong>：从原生指针得到引用 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> foo<span class="token operator">&lt;</span><span class="token string">'a>(input: *const u32) -> &amp;'</span>a u32 <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>'input
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
        x <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"hello: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-21中定义了函数foo，其参数input为原生指针*const u32类型，然后通过解引用原生指针和引用符号将其转为引用，其中“&amp;*input”相当于“&amp;（*input）”。 </p>
<p>在main函数中，代码第8～11行使用了作用域块，其中调用了函数foo，并将借用&amp;y传入。在第12行打印x的值。如果按Safe Rust的规则，由于foo函数返回的是一个引用，此处是对y的引用，但是在离开作用域之后，y已经被丢弃，所以此处x就是一个悬垂指针。Rust 编译器应该阻止该程序编译。但实际情况是，该程序可以正常编译。这是因为经过<strong>foo</strong>函数产生了一个未绑定生命周期的借用，所以就跳过了<strong>Rust</strong>的借用检查。</p>
<p>在Debug模式下编译运行会输出正常的结果“hello：42”，但是在Release模式下编译运行，则会输出超出预期的结果，比如“hello：1151157120”，产生了未定义行为。 </p>
<p>代码清单13-22展示了另外一种产生未绑定生命周期的情形。 </p>
<p>代码清单<strong>13-22</strong>：使用<strong>transmute</strong>函数得到引用</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>transmute<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token operator">&amp;</span>i32<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> i32<span class="token punctuation">;</span>
        x <span class="token operator">=</span> <span class="token keyword">unsafe</span><span class="token punctuation">{</span>transmute<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">const</span> i32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i32<span class="token operator">></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"hello {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-22中，使用了std：：mem：：transmute＜T，U＞函数，该函数可以将类型T转为类型U。这是一个unsafe函数，使用不当将会产生未定义行为。 </p>
<p>在main函数中，将原生指针ptr通过transmute函数转为&amp;i32类型，此时会产生未绑定生命周期。在离开作用域块之后，x将会产生悬垂指针。跟代码清单13-21类似，在Release模式下编译将会产生无法预期的值，比如“hello：-697728128”。 </p>
<p>所以，从原生指针得到引用的时候，需要避免以上两种情况，从而避免未定义行为的发生。 </p>
<h3 id="13-2-4-Drop检查"><a href="#13-2-4-Drop检查" class="headerlink" title="13.2.4 Drop检查"></a>13.2.4 Drop检查</h3><p><strong>Drop检查（dropck）是借用检查器的附属程序，它是为了让析构函数可以更安全合理地被调用而存在。</strong> </p>
<p>一般来说，析构函数的调用顺序与变量的声明顺序相反。也就是说，如果存在明确的声明顺序，则编译器可以推断析构函数的调用顺序。但是对于同时声明的情况，比如声明一个元组时，其内部元素的生命周期是相同的，编译器无法推断到底该先调用谁的析构函数。当出现这种情况的时候，就容易产生悬垂指针。在<strong>Safe Rust</strong>中由<strong>dropck</strong>引起的问题在Safe Rust中出现这种情况时，Rust编译器会报错，如代码清单13-23所示。</p>
<p>代码清单<strong>13-23</strong>：声明元组变量测试<strong>dropck</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>fmt<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[derive(Copy, Clone, Debug)]</span>
<span class="token keyword">enum</span> State <span class="token punctuation">{</span> InValid<span class="token punctuation">,</span> Valid <span class="token punctuation">}</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> Hello<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span> T<span class="token punctuation">,</span> State<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token operator">></span> Hello<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'<span class="token keyword">static</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>
        <span class="token function">Hello</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> t<span class="token punctuation">,</span> State<span class="token punctuation">:</span><span class="token punctuation">:</span>Valid<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token operator">></span> Drop <span class="token keyword">for</span> Hello<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"drop Hello({}, {:?}, {:?})"</span><span class="token punctuation">,</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">,</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">2</span> <span class="token operator">=</span> State<span class="token punctuation">:</span><span class="token punctuation">:</span>InValid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> WrapBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    v<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> WrapBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>
        WrapBox<span class="token punctuation">{</span>v<span class="token punctuation">:</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
<span class="token keyword">fn</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// let x; let y;</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> WrapBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-23中第2、3行定义了枚举类型<strong>State</strong>，目的是为了在析构函数中输出变量的状态。 </p>
<p>代码第4～19行定义了一个泛型结构体Hello＜T＞，并为其实现new方法和析构函数。该析构函数会在Hello被释放的时候调用，并输出预期的结果。 </p>
<p>代码第 20～27 行定义了新的结构体 WrapBox＜T＞，是对 Box＜T＞的包装，并为WrapBox＜T＞实现了new方法。 </p>
<p>代码第28～33行实现了函数f1。在第30行通过元组形式声明了变量，这是故意为之，目的是让编译器无法推断x和y的析构顺序。注意，在代码第32行中，WrapBox＜T＞的实例包含了x的引用。 </p>
<p>所以整个代码编译执行以后，会抛出代码清单13-24所示的错误。 </p>
<p>代码清单<strong>13-24</strong>：代码清单<strong>13-23</strong>编译产生的错误信息 </p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210522201408356.png" alt="image-20210522201408356"></p>
<p>代码清单13-24显示变量x存活时间不够久。这正是由于编译器无法准确推断x和y的析构顺序导致的。如果x先于y被释放，则&amp;x就成为悬垂指针，这是Safe Rust不允许出现的事情。 </p>
<p>解决这个问题也很简单，只需要修改x和y的声明顺序即可，如代码清单13-23中第29行所示。只要按该行指定的顺序声明变量x和y，整个代码就可以正常编译运行，因为此时编译器可以准确推断x和y的析构顺序。正常输出的结果如代码清单13-25所示。 </p>
<p>代码清单<strong>13-25</strong>：代码清单<strong>13-23</strong>经过修改后正常输出结果 </p>
<pre class="line-numbers language-rust"><code class="language-rust">drop <span class="token function">Hello</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> Valid<span class="token punctuation">)</span><span class="token punctuation">.</span> Valid<span class="token punctuation">)</span>
drop <span class="token function">Hello</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> Valid<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>代码清单13-25清楚地显示出，先调用y的析构函数，然后调用x的析构函数，并且两个变量在调用析构函数的时候都是Valid状态，表示一切安全，并未出现悬垂指针。 </p>
<p>在Safe Rust中，WrapBox＜T＞包装了Box＜T＞，会被Rust编译器识别为WrapBox＜T＞通过Box＜T＞间接拥有T。虽然WrapBox＜T＞没有显式实现Drop，但因为这一层拥有关系，Rust也会在WrapBox＜T＞被释放之后逐个自动地调用T上的析构函数。 </p>
<p><strong>＃[may_dangle]属性与dropck</strong> </p>
<p>接下来尝试在修正后的代码清单13-23的基础上新增一个自定义的结构体<strong>MyBox</strong>＜<strong>T</strong>＞，该结构体利用原生指针来替代Box＜T＞。这就需要手动在堆上分配内存，所以需要在Nightly Rust版本之下使用＃！ </p>
<p><strong>[feature</strong>（<strong>allocator_api]</strong>特性，如代码清单13-26所示。 </p>
<p>代码清单<strong>13-26</strong>：使用原生指针的结构体</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(allocator_api)]</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>alloc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>GlobalAlloc<span class="token punctuation">,</span> System<span class="token punctuation">,</span> Layout<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">;</span><span class="token punctuation">:</span>mem<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 此处省略State、Hello、impl Hello 等定义</span>
<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    v<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> T<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> p <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> T<span class="token punctuation">;</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            MyBox<span class="token punctuation">{</span>v<span class="token punctuation">:</span> p<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Drop <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>v <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">dealloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>
                Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>align_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        x1 <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x1"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        y1 <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        x2 <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x2"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        y2 <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// f1();</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-26中为了展示而省略了代码清单13-23中关于State、Hello，以及为Hello实现new和drop的代码，但实际上它们还会被用到。 </p>
<p>代码第1、2行使用＃！[feature（allocator_api）]特性，以及引入std：：alloc模块中的GlobalAlloc、System和Layout都是为了在堆中分配内存。注意，本章使用的feature在未来的Rust Nightly版本中会有所变化，请以本书的随书源码为准。代码第3、4行引入<strong>std：：ptr</strong>和<strong>std：：mem</strong>模块，要用到其中的函数。</p>
<p>代码第6～8行定义了新的结构体MyBox＜T＞，其字段v是*const T类型的原生指针。 </p>
<p>代码第9～18行为MyBox＜T＞实现了new方法，在new方法中使用<strong>System.alloc</strong>方法分配堆内存，其参数<strong>Layout：：array：：＜T＞（1）</strong>按照<strong>T</strong>类型来指定布局。在分配好内存之后，再通过得到的指针写入数据。最后将指针存入MyBox＜T＞结构体实例中。 </p>
<p>代码第19～27行为MyBox＜T＞实现<strong>Drop</strong>，在drop方法中使用ptr：：read读取指针v对应的数据 T，然后通过 <strong>System.dealloc</strong> 方法将 T的内存释放，其参数<strong>Layout：：array：：＜T＞（mem：：align_of：：＜T＞（））</strong>表示按<strong>T</strong>的内存对齐方式获取相应的内存布局。</p>
<p>代码第28～39行实现了f2函数。最后在main函数中调用f2函数。注意，f1函数已被注释。 </p>
<p>代码清单13-26编译会报如代码清单13-27所示的错误。 </p>
<p>代码清单<strong>13-27</strong>：代码清单<strong>13-26</strong>编译错误信息</p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210522202355839.png" alt="image-20210522202355839"></p>
<p>代码清单<strong>13-27</strong>的错误依旧是因为编译器无法推断变量的析构顺序而引起的。编译器担心开发者会在 drop 方法中调用 T 的数据，避免出 </p>
<p>现悬垂指针。但现在代码清单 13-26 中MyBox＜T＞的drop方法是开发 </p>
<p>人员自己实现的，并且没有使用到T的数据，不会出现悬垂指针。那么 </p>
<p>有什么办法让代码通过编译呢？答案是使用＃<strong>[may_dangle]</strong>属性。 </p>
<p>利用＃<strong>[may_dangle]</strong>属性来修改drop方法，如代码清单13-28所示。 </p>
<p>代码清单<strong>13-28</strong>：修改<strong>drop</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#![feature(allocator_api, dropck_eyepatch)]</span>
<span class="token comment" spellcheck="true">// 其他同上</span>
<span class="token keyword">unsafe</span> <span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token attribute attr-name">#[may_dangle]</span> T<span class="token operator">></span>Drop <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"mybox drop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>v <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">dealloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>
                Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>align_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-28中第1行引入了＃！[feature（allocator_api，dropck_eyepatch）]特性。 </p>
<p>代码第 3 行变为<strong>“unsafe impl＜＃[may_dangle] T＞ Drop for MyBox＜T＞”</strong>。其中，<strong>“＜＃[may_dangle] T＞”</strong>代表在drop方法实现中，将不会用到T，否则可能会出现悬垂指针（many_dangle就是may dangle pointer的意思）。因为这是需要开发人员去保证的，所以要用unsafe关键字来标记impl。 </p>
<p>经过这样的修改之后，代码即可正常编译运行。但是这样就可以了吗？答案是否定的。如果在drop方法中使用了T，则会发生悬垂指针，如代码清单13-29所示。 </p>
<p>代码清单<strong>13-29</strong>：修改<strong>drop</strong>方法和<strong>f2</strong>函数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 其他代码同上</span>
<span class="token keyword">unsafe</span> <span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token attribute attr-name">#[may_dangle]</span> T<span class="token operator">></span> Drop <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处新增</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>v <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">dealloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>
                Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>align_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        x1 <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x1"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        y1 <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>y2<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处改变</span>
        x2 <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x2"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        y2 <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-29修改了两处，分别是代码第5行和第19行。 </p>
<p>代码第5行新增了ptr：：read函数读取T的内容。此行代码表示MyBox＜T＞的drop方法中用到了T。 </p>
<p>代码第19行故意将之前x2和y2的声明顺序换了位置。于是代码编译之后，输出结果如代码清单13-30所示。 </p>
<p>代码清单<strong>13-30</strong>：打印结果 </p>
<pre><code>drop Hello(y1, Hello(&quot;x1&quot;, 13, Valid), Valid)
drop Hello(x1, 13, Valid)
drop Hello(x2, 13, Valid)
drop Hello(y2, Hello(&quot;x2&quot;, 13, InValid), Valid)</code></pre><p>从代码清单13-30中可以看出，x1和y1是正常的释放顺序，但是x2和y2就出现了问题。最后一行显示内层Hello实例的状态是<strong>InValid</strong>，说明此处产生了悬垂指针，因为访问到已经执行了析构函数的T的值。 </p>
<p>这样的结果有违Rust的安全理念，有什么办法可以让Rust执行更严格的drop检查呢？ </p>
<p>使用<strong>PhantomData</strong>＜<strong>T</strong>＞得到更严格的<strong>drop</strong>检查 </p>
<p>因为MyBox＜T＞用了原生指针，而原生指针没有所有权语义。也就是说，Rust编译器不会认为MyBox＜T＞拥有T。这就意味着，在进行drop检查时，不会严格要求T的生命周期必须长于MyBox＜T＞。所以在MyBox＜T＞的drop方法中使用T的时候，编译器完全忽视了T很可能被提前释放的可能。前面提到PhantomData＜T＞的功能之一就是标记拥有关系，正好可以解决这个问题。 </p>
<p>在代码清单13-29的基础上，再重新创建MyBox2＜T＞结构体，如代码清单13-31所示。代码清单<strong>13-31</strong>：新增<strong>MyBox2＜T＞</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 其余代码同上</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>marker<span class="token punctuation">:</span><span class="token punctuation">:</span>PhantomData<span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyBox2<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    v<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> T<span class="token punctuation">,</span>
    _pd<span class="token punctuation">:</span> PhantomData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox2<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> p <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> T<span class="token punctuation">;</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            MyBox2 <span class="token punctuation">{</span>v<span class="token punctuation">:</span> p<span class="token punctuation">,</span> _pd<span class="token punctuation">:</span> Default<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">unsafe</span> <span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token attribute attr-name">#[may_dangle]</span> T<span class="token operator">></span> Drop <span class="token keyword">for</span> MyBox2<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>v <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> _<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">dealloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>
                Layout<span class="token punctuation">:</span><span class="token punctuation">:</span>array<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>align_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// let (y, x);</span>
    <span class="token comment" spellcheck="true">// let (x, y);</span>
    <span class="token keyword">let</span> x<span class="token punctuation">;</span> <span class="token keyword">let</span> y<span class="token punctuation">;</span>
    x <span class="token operator">=</span> Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> MyBox2<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Hello<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// f1();</span>
    <span class="token comment" spellcheck="true">// f2();</span>
    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 13-31 中，新增了 MyBox2＜T＞，与 MyBox＜T＞唯一的不同就是多了一个PhantomData＜T＞字段_pd，该字段的作用就是告诉Rust编译器一个事实：<strong>MyBox2</strong>＜<strong>T</strong>＞拥有<strong>T</strong>。这就意味着，在执行MyBox2＜T＞的析构函数时，不管有没有使用＃<strong>[may_dangle]</strong>属性，都必须要求T的生命周期长于MyBox2＜T＞。 </p>
<p>代码第17～26行为MyBox2＜T＞实现了Drop，并且使用了＃[may_dangle]属性。 </p>
<p>代码第27～33行定义了函数f3。在该函数中必须强制指定x和y的声明顺序，以便编译器推断变量的 drop 顺序。对于代码第 28 行和第 29行所注释的两种写法，编译器无法推断drop顺序，不予通过编译。</p>
<p>所以在处理<strong>drop</strong>检查的时候，可以通过以下两个维度来处理代码避免出现未定义行为： </p>
<ul>
<li><strong>＃[may_dangle]</strong>属性，该属性使用unsafe对impl Drop进行标记，以此来警示开发者不要在析构函数中使用其拥有的数据。 </li>
<li><strong>PhantomData＜T＞</strong>，用于标记复合类型拥有其包含的数据。这意味着，该复合类型将会遵循严格的drop检查，包含数据的生命周期必须长于复合类型的生命周期。 </li>
</ul>
<p>来自标准库中的用法 </p>
<p>在Rust标准库中经常结合两者使用。代码清单13-32展示了Vec＜T＞和LinkedList＜T＞的相关代码。 </p>
<p>代码清单<strong>13-32</strong>：标准库中<strong>Vec＜T＞</strong>和<strong>LinkedList＜T＞</strong>相关实现</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> Vec<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    buf<span class="token punctuation">:</span> RawVec<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>
    len<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> RawVec<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> A<span class="token punctuation">:</span> Alloc <span class="token operator">=</span> Global<span class="token operator">></span> <span class="token punctuation">{</span>
    ptr<span class="token punctuation">:</span> Uniqe<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>
    cap<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
    a<span class="token punctuation">:</span> A<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Unique<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>
    pointer<span class="token punctuation">:</span> NonZero<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">const</span> T<span class="token operator">></span><span class="token punctuation">,</span>
    _marker<span class="token punctuation">:</span> PhantomData<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">unsafe</span> implM<span class="token operator">&lt;</span><span class="token attribute attr-name">#[may_dangle]</span> T<span class="token operator">></span> Drop <span class="token keyword">for</span> Vec<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drop_in_place</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    head<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>NonNull<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">,</span>
    tail<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>NonNull<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">,</span>
    len<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>
    marker<span class="token punctuation">:</span> PhantomData<span class="token operator">&lt;</span>Box<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">unsafe</span> <span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token attribute attr-name">#[may_dangle]</span> T<span class="token operator">></span> Drop <span class="token keyword">for</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">pop_front_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-32中，Vec＜T＞通过RawVec＜T＞间接拥有T，而RawVec＜T＞靠Unique＜T＞间接拥有T。在Unique＜T＞中使用<strong>PhantomData</strong>＜<strong>T</strong>＞来保证拥有关系，这样drop检查就会严格要求开发者保证析构顺序。 </p>
<p>Vec＜T＞的析构函数使用了＃<strong>[may_dangle]</strong>属性，这将警示编写该析构函数的开发者注意不要去使用拥有的数据。 </p>
<p>同理，LinkedList＜T＞也使用了PhantomData＜T＞和＃[may_dangle]属性达到与Vec＜T＞相同的目的。 </p>
<p>使用<strong>std：：mem：：forget</strong>阻止析构函数调用 </p>
<p>Rust中的析构函数默认是会被调用的，但在有些场合不希望调用析构函数。比如，通过FFI和C语言交互，在Rust中创建的数据需要在C中被调用，如果在Rust中被释放，则C中调用的时候会出问题。所以Rust提供了一个函数<strong>std：：mem：：forget</strong>来处理这种情况。 </p>
<p>如代码清单13-33所示。 </p>
<p>代码清单<strong>13-33</strong>：转移结构体中字段所有权示例 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> A<span class="token punctuation">;</span>
<span class="token keyword">struct</span> B<span class="token punctuation">;</span>
<span class="token keyword">struct</span> Foo <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> A<span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> B
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Foo <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-33中定义了结构体Foo，其字段a和b的类型分别是结构体A和B。为Foo结构体实现了take方法，该方法返回由Foo字段值组成的（A，B）类型的元组。 </p>
<p>这里的重点是，take方法会将Foo结构体字段a和b的所有权转移。 这是Rust允许的，该段代码是可以正常编译通过的。但是，如果给 <strong>Foo</strong>结构体实现了 <strong>Drop</strong>，情况就会发生变化，如代码清单13-34所示。 </p>
<p>代码清单<strong>13-34</strong>：为结构体<strong>Foo</strong>实现<strong>Drop</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 其余代码同上</span>
<span class="token keyword">impl</span> Drop <span class="token keyword">for</span> Foo <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 做一些事</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-34中为Foo结构体实现了Drop，再次编译代码会出现代码清单13-35所示的错误。 </p>
<p>代码清单<strong>13-35</strong>：代码清单<strong>13-34</strong>的错误信息 </p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210522205158985.png" alt="image-20210522205158985"></p>
<p>代码清单13-35中错误信息显示，Rust编译器不允许移动Foo结构体的两个字段，原因是Foo结构体实现了Drop。在Foo的析构函数中，有可能会用到其字段，所以不能把所有权转移走。 </p>
<p>如果在这种情况下必须转移Foo字段所有权，则可以使用<strong>std：：mem：：forget</strong>函数。如代码清单13-36所示。 </p>
<p>代码清单<strong>13-36</strong>：重新为<strong>Foo</strong>实现<strong>take</strong>方法</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 其余代码同上</span>
<span class="token keyword">impl</span> Foo <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> a <span class="token operator">=</span> mem<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">replace</span><span class="token punctuation">(</span>
            <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> mem<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">uninitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> b <span class="token operator">=</span> mem<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">replace</span><span class="token punctuation">(</span>
            <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> mem<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">uninitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">forget</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-36中，将Foo结构体的take方法重新实现了一遍，代码将正常编译通过。该代码中主要用到两个重要的函数：<strong>mem：：uninitialized</strong>和<strong>mem：：forget</strong>。 </p>
<p>其中，mem：：uninitialized是一个unsafe函数，在take方法中，将a和b的值都通过该函数修改为“伪装的初始化值”，用于跳过 <strong>Rust</strong> 的内存初始化检查。但这样做是危险的，如果此时对a和b进行读取或写入，都会引起未定义行为。该函数一般用于FFI和C语言交互。 </p>
<p>另外，<strong>mem：：forget</strong>函数会将当前的Foo实例“忘掉”，这样Foo实例就不会被释放，析构函数也不会被调用。但forget函数不是unsafe函数，因为使用该函数引起的后果是内存泄漏，对Rust来说，属于安全范畴。而对开发者来说，需要在适合的地方手动调用drop方法来运行析构函数。</p>
<p>在析构函数中手动指定析构顺序 </p>
<p>在std：：mem模块中还提供了另外一个联合体ManuallyDrop，通过它可以实现在析构函数中手动指定析构顺序。 </p>
<p>如代码清单13-37所示。 </p>
<p>代码清单<strong>13-37</strong>：<strong>ManuallyDrop</strong>使用示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>ManuallyDrop<span class="token punctuation">;</span>
<span class="token keyword">struct</span> Peach<span class="token punctuation">;</span>
<span class="token keyword">struct</span> Banana<span class="token punctuation">;</span>
<span class="token keyword">struct</span> Melon<span class="token punctuation">;</span>
<span class="token keyword">struct</span> FruitBox <span class="token punctuation">{</span>
    peach<span class="token punctuation">:</span> ManuallyDrop<span class="token operator">&lt;</span>Peach<span class="token operator">></span><span class="token punctuation">,</span>
    melon<span class="token punctuation">:</span> Melon<span class="token punctuation">,</span>
    banana<span class="token punctuation">:</span> ManuallyDrop<span class="token operator">&lt;</span>Banana<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Drop <span class="token keyword">for</span> FruitBox <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            ManuallyDrop<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>peach<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ManuallyDrop<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>banana<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 13-37 中，FruitBox 结构体中，peach 和 banana 两个字段的类型均为ManuallyDrop＜T＞类型。所以在其析构函数中，通过ManuallyDrop：：drop函数显式指定peach和banana的析构顺序。 </p>
<p>那么，ManuallyDrop是如何做到这一点的？Rust代码中析构函数不是自动调用的吗？它有什么神奇之处呢？代码清单13-38展示了ManuallyDrop的源码。 </p>
<p>代码清单<strong>13-38</strong>：<strong>ManuallyDrop＜T＞</strong>源码示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[allow(unions_with_drop_fields)]</span>
<span class="token attribute attr-name">#[derive(Copy)]</span>
<span class="token keyword">pub</span> union ManuallyDrop<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> T<span class="token punctuation">}</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> ManuallyDrop<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">const</span> <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> ManuallyDrop<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        ManuallyDrop <span class="token punctuation">{</span>value<span class="token punctuation">:</span> value<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span>slot<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> ManuallyDrop<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drop_in_place</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> slot<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-38展示了ManuallyDrop＜T＞的主要实现。 </p>
<p>ManuallyDrop＜T＞是一个联合体，Rust不会为联合体自动实现Drop。因为联合体是所有的字段共用内存，不能随便被析构，否则会引起未定义行为。 </p>
<p>所以，只要通过 ManuallyDrop：：new 方法创建一个 ManuallyDrop＜T＞实例，就只能通过ManuallyDrop：：drop函数手动调用析构函数。实际上，std：：mem：：forget＜T＞函数的实现就是用了 ManuallyDrop：：new方法，如代码清单13-39所示。 </p>
<p>代码清单<strong>13-39</strong>：<strong>forget＜T＞</strong>函数源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> forget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ManuallyDrop<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-39展示了std：：mem：：forget＜T＞函数的源码实现，看上去十分简单。 </p>
<h3 id="13-2-5-NonNull＜T＞指针"><a href="#13-2-5-NonNull＜T＞指针" class="headerlink" title="13.2.5 NonNull＜T＞指针"></a>13.2.5 NonNull＜T＞指针</h3><p>NonNull＜T＞指针实际上是一种特殊的<strong>*mut T</strong> 原生指针，它的特殊之处有两点：协变（covariant）和非零（non-zero）。 </p>
<p><strong>NonNull＜T＞</strong>旨在成为<strong>Unsafe Rust</strong>默认的原生指针，而非<strong>*const</strong> <strong>T</strong>和<strong>*mut T</strong>。因为<strong>*const T</strong>和<strong>*mut T</strong>基本上是等价的，它们可以相互转换。但不能从*const T直接得到&amp;mut T。 </p>
<p>在 NonNull 被引入之前，Unsafe 代码中最常见的模式就是使用*const T，结合PhantomData＜T＞得到协变结构体，并且在需要的时候会将*const T 转换为*mut T。使用<strong>NonNull＜T＞</strong>就不需要进行转换了， </p>
<p>因为它本身就等价于一个协变版本的<strong>*mut T</strong>，但是还需要PhantomData＜T＞在必要时提供不变或加强<strong>drop</strong>检查。 </p>
<p><strong>NonNull</strong>＜<strong>T</strong>＞的本质 </p>
<p>代码清单13-40展示了NonNull＜T＞的源码。 </p>
<p>代码清单<strong>13-40</strong>：<strong>NonNull＜T＞</strong>和<strong>NonZero</strong>源码示意 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> NonNull<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>
    pointer<span class="token punctuation">:</span> NonZero<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">const</span> T<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
#<span class="token punctuation">[</span>lang <span class="token operator">=</span> <span class="token string">"non_zero"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> NonZero<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Zeroable<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-40展示了NonNull＜T＞实际上是对NonZero＜*const T＞的包装。因为*const T是协变类型，所以NonZero＜*const T＞是协变，NonNull＜T＞也是协变。NonNull＜T＞和代码清单13-32中展示的Unique＜T＞非常相似，不同点在于NonNull＜T＞少了一个PhantomData＜T＞类型的字段。所以NonNull＜T＞和T没有严格的拥有关系。 </p>
<p>代码第4～6行展示了<strong>NonZero＜T＞</strong> 的定义，它属于Rust 核心库（core）的类型。其定义中的<strong>Zeroable</strong>限定用于判断T是否为零（Null或零值）。NonZero＜T＞的作用就是两个：协变和非零，并且加上了<strong>＃[lang=＂non_zero＂]</strong>属性让其成为语言项，方便编译器识别。  ssssssss</p>
<p>NonNull＜T＞也提供了一些方法，允许开发者可以更安全地使用原生指针，如代码清单13-41所示。 </p>
<p>代码清单<strong>13-41</strong>：<strong>NonNull</strong>＜<strong>T</strong>＞内置方法示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>null<span class="token punctuation">,</span> NonNull<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ptr<span class="token punctuation">:</span> NonNull<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> NonNull<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">dangling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x4</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>NonNull<span class="token operator">&lt;</span>i32<span class="token operator">>></span> <span class="token operator">=</span> NonNull<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Some(0x7fff73406a78)</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_otr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x7fff73406a78</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token keyword">unsafe</span><span class="token punctuation">{</span>ptr<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> NonNull<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0x7fff73406a7c</span>
    <span class="token keyword">let</span> null_p<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> i32 <span class="token operator">=</span> <span class="token function">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> NonNull<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>null_p <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> i32<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// None</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-41中第3、4行使用了<strong>NonNull</strong>：：<strong>dangling</strong>函数来创建一个新的悬垂NonNull指针，但它的内存是对齐的。它在一些场景里用于类型初始化，比如使用Vec：：new创建一个空的动态数组，需要初始化一个指针。它是安全的。 </p>
<p>代码第5～7行可以通过<strong>NonNull</strong>：：<strong>new</strong>函数将已知的可变原生指针生成Option＜NonNull＜T＞＞类型。 </p>
<p>代码第8、9行可以通过as_ptr和as_mut方法分别得到NonNull＜T＞类型对应的*mut T指针和&amp;mut T引用。注意，这里的as_mut方法得到的引用是有正常生命周期的引用，而非未绑定生命周期的引用。 </p>
<p>代码第10～12行可以通过<strong>NonNull</strong>：：<strong>from</strong>函数将一个可变引用转为NonNull＜T＞类型。 </p>
<p>代码第13～15行通过<strong>null</strong>函数创建了一个空指针，然后传给NonNull：：new函数，将生成None值。 </p>
<p>空指针优化 </p>
<p>因为NonNull的非零特性，所以可以帮助编译器进行优化，如代码清单13-42所示。</p>
<p>代码清单<strong>13-42</strong>：空指针优化展示 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ptr<span class="token punctuation">:</span><span class="token punctuation">:</span>NonNull<span class="token punctuation">;</span>
<span class="token keyword">struct</span> Foo <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> FooUsingNonNull <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> NonNull<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"*mut u64：{} bytes"</span><span class="token punctuation">,</span> mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"NonNull&lt;*mut u64>：{} bytes"</span><span class="token punctuation">,</span> 
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>NonNull<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Option&lt;*mut u64>：{} bytes"</span><span class="token punctuation">,</span>
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Option<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Option&lt;NonNull&lt;*mut u64>>：{} bytes"</span><span class="token punctuation">,</span>
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Option<span class="token operator">&lt;</span>NonNull<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token keyword">mut</span> u64<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Option&lt;Foo>：{} bytes"</span><span class="token punctuation">,</span>
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Option<span class="token operator">&lt;</span>Foo<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Option&lt;FooUsingNonNull>：{} bytes"</span><span class="token punctuation">,</span>
        mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>Option<span class="token operator">&lt;</span>FooUsingNonNull<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-42中定义了两个结构体Foo和FooUsingNonNull，前者只用了原生指针，后者的字段中包含了NonNull＜*mut u64＞指针。 </p>
<p>在main函数中，通过mem：：size_of函数比较它们的内存大小，代码清单13-43展示了输出结果。 </p>
<p>代码清单<strong>13-43</strong>：空指针优化输出结果</p>
<pre><code>*mut u64: 8 bytes
NonNull&lt;*mut u64&gt;: 8 bytes
Option&lt;*mut u64&gt;: 16 bytes
Option&lt;NonNull&lt;*mut u64&gt;&gt;: 8 bytes
Option&lt;Foo&gt;: 24 bytes
Option&lt;FooUsingNonNull&gt;: 16 bytes</code></pre><p>从代码清单 13-43 中可以看出，*mut u64 的大小和 NonNull＜*mut u64＞相等，NonNull＜*mut u64＞和Option＜NonNull＜*mut u64＞＞大小相等，但是Option＜*mut u64＞的大小却不等于*mut u64。 </p>
<p>这是因为Rust 对包含了NonNull＜T＞指针的 Option＜T＞类型进行了优化行为，这种优化叫作“空指针优化”。因为NonNull＜T＞本身是不可能为空的，所以Option＜T＞就不需要多余的判别式（tag）来判断是不是None，这样在内存布局上就不需要占用多余的内存。而对*mut T指针来说，无法保证它一定不是空指针，所以Option＜*mut u64＞还需要保留判别式，内存布局还需要按正常的枚举体来进行对齐，所以会多占用一倍内存。 </p>
<p>空指针优化固然可以省内存，但在使用FFI和C语言“打交道”的时候要慎用</p>
<h3 id="13-2-6-Unsafe与恐慌安全"><a href="#13-2-6-Unsafe与恐慌安全" class="headerlink" title="13.2.6 Unsafe与恐慌安全"></a>13.2.6 Unsafe与恐慌安全</h3><p>在Unsafe Rust中就需要小心恐慌安全，这里是Rust编译器鞭长莫及的地方，如代码清单13-44所示。 </p>
<p>代码清单<strong>13-44</strong>：<strong>Unsafe Rust</strong>中需要注意恐慌安全问题</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Clone<span class="token operator">></span> Vec<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">push_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> to_push<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>to_push<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">set_len</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> to_push<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token keyword">in</span> to_push<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span>i <span class="token keyword">as</span> isize<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-44为Vec＜T＞实现了一个push_all方法，在第3行使用reserve预留了传入数组大小的内存容量。然后使用了unsafe代码块，因为要使用write方法来直接覆盖内存的数据，属于unsafe操作。 </p>
<p>整个函数唯一有可能发生恐慌的地方就是 <strong>clone</strong> 方法，因为其他方法都是简单的函数，并不会发生恐慌，但是clone方法的实现是未知的，存在发生恐慌的可能。所以整个push_all函数就不是恐慌安全的函数，它也不保证内存安全。假如 clone 方法发生了恐慌，那么后续的元素将无法继续写入内存，但是之前已经使用 reserve 方法预分配了内存，并通过 set_len方法为数组重置了长度，如果后续的元素无法写入内存，那么就会出现未初始化的内存，最终导致内存不安全。但是出于Rust的设计，这些未初始化的内存并不会被暴露出来。所以，总的来说，相比于其他语言，比如C++，Rust程序员几乎不会担心恐慌安全的问题。</p>
<p>Rust 也提供了 <strong>catch_unwind</strong> 方法来让开发者捕获恐慌，恢复当前线程。但是，对于代码清单13-44中展示的非恐慌安全的push_all函数来说，如果想捕捉clone方法可能引发的恐慌，则需要小心。数组的长度已经确定，但是还有未初始化的内存，整个数据结构的不变性被破坏了。所以，Rust编译器也不会允许开发者在push_all函数中使用catch_unwind。</p>
<h3 id="13-2-7-堆内存分配"><a href="#13-2-7-堆内存分配" class="headerlink" title="13.2.7 堆内存分配"></a>13.2.7 堆内存分配</h3><p>在<strong>编写Unsafe Rust的过程中，也需要手动进行堆内存分配，所以Rust标准库std：：alloc模块中也提供了堆内存分配的相关API</strong>。 </p>
<p>Rust在Rust <strong>1.28</strong>之前默认都是使用<strong>jemalloc</strong>作为默认内存分配器，虽然jemalloc很强大，但它也带来不少问题，所以在Rust 1.28中将jemalloc分配器从标准库中剥离了出来，作为一个可选的第三方库而存在，标准库默认分配器就是System分配器。 </p>
<p>在std：：alloc模块中有一个<strong>GlobalAlloc trait</strong>，其源码如代码清单13-45所示。 </p>
<p>代码清单<strong>13-45</strong>：<strong>GlobalAlloc trait</strong>源码示意</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">trait</span> GlobalAlloc <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> layout<span class="token punctuation">:</span> Layout<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">*</span><span class="token keyword">mut</span> u8<span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">dealloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u8<span class="token punctuation">,</span> layout<span class="token punctuation">:</span> Layout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 其他方法省略</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单13-45中展示了<strong>GlobalAlloc中最重要的两个方法签名：alloc和dealloc，分别表示内存的分配和释放</strong>。 </p>
<p>注意，GlobalAlloc和其定义方法都用unsafe做了标记。要实现该trait，必须注意遵守以下约定： </p>
<ul>
<li>如果全局分配器发生了恐慌，则会产生未定义行为。 </li>
<li>布局（Layout）的查询和计算必须正确。 </li>
</ul>
<p>这就意味着，开发者可以通过实现该trait而指定自己的全局分配器。如代码清单13-46所示。 </p>
<p>代码清单<strong>13-46</strong>：自定义全局分配器示例</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>alloc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>GlobalAlloc<span class="token punctuation">,</span> System<span class="token punctuation">,</span> Layout<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyAllocator<span class="token punctuation">;</span>
<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> GlobalAlloc <span class="token keyword">for</span> MyAllocator <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> layout<span class="token punctuation">:</span> Layout<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">*</span><span class="token keyword">mut</span> u8 <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>layout<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function">dealloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> u8<span class="token punctuation">,</span> layout<span class="token punctuation">:</span> Layout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span><span class="token function">dealloc</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> layout<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[global_allocatro]</span>
<span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> MyAllocator <span class="token operator">=</span> MyAllocator<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 此处Vec的内存会由GLOBAL全局分配器来分配</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> Vec<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-46中定义了结构体MyAllocator，然后为其实现GlobalAlloc trait，如代码第2～10行所示。具体的实现中使用了<strong>System.alloc</strong>和<strong>System.dealloc</strong>是标准库默认的分配器。 </p>
<p>代码第 11、12 行使用<strong>＃[global_allocator]属性就可以将静态变量 GLOBAL 指派的MyAllocator声明为全局分配器</strong>。在main函数中，Vec＜T＞数组的内存分配器就会默认使用自定义的MyAllocator分配器。 </p>
<p>当然，<strong>也可以通过＃[global_allocator]属性指定全局分配器为jemalloc</strong>。如代码清单13-47所示。 </p>
<p>代码清单<strong>13-47</strong>：声明<strong>jemalloc</strong>为全局内存分配器</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> jemallocator<span class="token punctuation">;</span>
<span class="token keyword">use</span> jemallacator<span class="token punctuation">:</span><span class="token punctuation">:</span>Jemalloc<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[global_allocator]</span>
<span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> Jemalloc <span class="token operator">=</span> Jemalloc<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-47展示了如何将jemalloc设置为全局内存分配器。在Rust 1.28中，jemalloc分配器已经被独立为第三方包，叫作jemallocator。这也是需要通过 extern crate 命令导入jemallocator的原因。 </p>
<p>然后同样<strong>使用＃[global_allocator]属性就可以将静态变量GLOBAL指派的Jemalloc作为全局分配器。注意，该属性只能用于静态变量</strong>。 </p>
<p>同理，将来也可以使用其他的内存分配器，比如Redox操作系统中用纯Rust实现的<strong>ralloc</strong>内存分配器。 </p>
<h3 id="13-2-8-混合代码内存安全架构三大原则"><a href="#13-2-8-混合代码内存安全架构三大原则" class="headerlink" title="13.2.8 混合代码内存安全架构三大原则"></a>13.2.8 混合代码内存安全架构三大原则</h3><p>除了前面介绍的编写Unsafe代码需要注意的事项，还有来自<strong>Rust社区的指导Safe和Unsafe Rust代码混合编程中保证内存安全三大原则</strong>： </p>
<ul>
<li>不安全的组件不应该削弱其安全性，特别是公共的API和数据结构。</li>
<li>不安全的组件应该尽可能小，并与安全组件分离（隔离和模块化）。</li>
<li>不安全的组件应该明确标记并轻松升级。 </li>
</ul>
<p>在开发中遵循上述原则进行架构设计，可以在一定程度上获得更好的安全保证。</p>
<h2 id="13-3-和其他语言交互"><a href="#13-3-和其他语言交互" class="headerlink" title="13.3 和其他语言交互"></a>13.3 和其他语言交互</h2><p>在日常开发中，难免要和其他语言进行交互。其中，最显而易见的就是和C语言进行交互，比如Rust程序要进行系统调用，或者通过Rust来提升动态语言的性能瓶颈。这也是几乎所有编程语言都要面对的问题。</p>
<p>Common Lisp语言规范中首次提出了<strong>术语“外部函数接口（Foreign Function Interface，FFI）”，用于规范语言间调用的语言特征</strong>。后来，该术语也逐渐被引入到Haskell和Python等大多数语言中。也有个别语言使用其他术语，比如 Ada 语言使用“语言绑定（Language Bindings）”， </p>
<p>Java语言则将FFI称为<strong>JNI</strong>（Java Native Interface）。 </p>
<p>所以，<strong>现在编程语言之间都是通过FFI技术来进行交互的</strong>。</p>
<h3 id="13-3-1-外部函数接口"><a href="#13-3-1-外部函数接口" class="headerlink" title="13.3.1 外部函数接口"></a>13.3.1 外部函数接口</h3><p><strong>FFI 技术的主要功能就是将一种编程语言的语义和调用约定与另一种编程语言的语义和调用约定相匹配</strong>。如何匹配呢？ </p>
<p><em>不管哪种编程语言，无论是编译执行还是解释执行，最终都会到达处理器指令这个环节。在这个环节所处的层面上，编程语言之间的语法、数据类型等语义差异均以消除，只需要匹配调用约定，这就给编程语言之间的相互调用带来了可能。</em> </p>
<p><strong>(1) 应用程序二进制接口</strong> </p>
<p><strong>调用约定如何匹配，与应用程序二进制接口（ABI）高度相关。什么是ABI？ABI是一个规范</strong>，主要涵盖以下内容： </p>
<ul>
<li><strong>调用约定。</strong>一个函数的调用过程本质就是参数、函数、返回值如何传递。编译器按照调用规则去编译，把数据放到相应的堆栈中，函数的调用方和被调用方（函数本身）都需要遵循这个统一的约定。 </li>
<li><strong>内存布局。</strong>规定了大小和对齐方式。 </li>
<li><strong>处理器指令集。</strong>不同平台的处理器指令集不同。 </li>
<li><strong>目标文件和库的二进制格式</strong>。</li>
</ul>
<p>ABI规范由编译器、操作平台、硬件厂商等共同制定。<strong>ABI是二进制层面程序兼容的契约，只有拥有相同的ABI，来自不同编译器之间的库才可以相互链接和调用，否则将无法链接，或者即使可以链接，也无法正确运行。</strong> </p>
<p>不同的体系结构、操作系统、编程语言、每种编程语言的不同编译器实现基本都有自己规定或者遵循的ABI和调用规范。目前只能通过FFI技术遵循C语言ABI才可以做到编程语言的相互调用。也就是说，C语言ABI是唯一通用的稳定的标准ABI。这是由历史原因决定的，C语言伴随着操作系统一路发展而来，导致其成为事实上的“标准ABI”。 </p>
<p>Rust语言也提供了ABI，但因为Rust语言目前处于上升期，语言还在不断地完善和改进，导致ABI还不能够稳定下来，<strong>在不久的未来，Rust ABI应该是可以稳定的。Rust提供了FFI技术，允许开发者通过稳定的C-ABI和其他语言进行交互。</strong> </p>
<p>图13-2展示了Rust FFI和C语言相互调用的原理。 </p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210523094319380.png" alt="image-20210523094319380"></p>
<p><strong>在Rust中使用FFI非常简单，只需要通过extern关键字和ertern块对FFI接口进行标注即可。在编译时会由LLVM默认生成C-ABI。</strong> </p>
<p><strong>（2）链接与Crate Type</strong> </p>
<p><strong>有了统一的ABI之后，还需要经过链接才能实现最终的相互调用</strong>。 </p>
<p><strong>链接是将编译单元产生的目标文件按照特定的约定组合在一起，最终生成可执行文件、静态库或动态库。链接产生于程序开发的模块化。这里的模块是指编译层面的模块。</strong>比如C或C++语言中每个文件都是一个编译单元，所以也可以说是一个编译模块，编译之后就能产生一个目标文件。<strong>Rust 和 C/C++不同，它以包（crate）为编译单元。在一个 Rust包中通过extern crate声明来引入其他包之后，编译器支持各种方法可以将包链接在一起，生成指定的可执行文件、动态库或静态库。</strong> </p>
<p>在一个编译模块中，通常包含了函数和全局数据的定义。<strong>函数和数据由符号来标识，一般有全局和静态之分。全局符号可以在模块间引用，而静态符号只能在当前模块引用。编译各个模块的时候，编译器的一项重要工作就是建立符号表。符号表中包含了模块的哪些符号是全局符号，哪些是静态符号，每个符号都会关联一个地址。在链接过程中，链接器会扫描各个编译模块的符号表，建立全局符号表，由此决定，符号在哪里被定义，以及在哪里被调用。这个过程叫作符号解析。</strong>除此之外，因为可执行文件和库的内存地址空间使用的差异，还需要进行存储空间的分配。地址重新分配之后，相应符号的引用也需要重新被调整，这个过程叫作重定位。经过符号解析、存储空间分配和重定位之后，链接过程就完成了，最终生成可执行文件或库。 </p>
<p>从概念上看，库可以分为两种：静态库和动态库。 </p>
<ul>
<li><strong>静态库是这样一种库：在功能上，可以在链接时将引用的代码和数据复制到引用该库的程序中；在格式上，它只是普通目标文件的集合，只是一种简单的拼接。</strong>静态库使用简单，原理上容易理解，但是它容易浪费空间。</li>
<li>动态库和静态库差异比较大。<strong>动态库可以把链接这个过程延迟到运行时进行，比如重定位发生在运行时而非编译时。动态库相对来说比较省空间。</strong> </li>
</ul>
<p>除可执行文件外，Rust一共支持四种库，如图13-3所示。 </p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210523113357383.png" alt="image-20210523113357383"></p>
<p>可以<strong>通过设置命令行参数Flag或者crate_type属性指定生成的库类型</strong>：</p>
<ul>
<li><strong>–crate-type=bin或＃[crate_type=＂bin＂]，表示将生成一个可执行文件。要求程序中必须包含一个main函数。</strong></li>
<li><strong>–crate-type=lib或＃[crate_type=＂lib＂]，表示将生成一个Rust库。</strong>这里lib是对Rust库的统称，具体生成什么库，由编译器自行决定。一般情况下，默认会产生<strong>rlib</strong>静态库。 </li>
<li><strong>–crate-type=rlib或＃[crate_type=＂rlib＂]，可以理解为静态Rust库，由Rust编译器来使用。</strong> </li>
<li><strong>–crate-type=dylib或＃[crate_type=＂dylib＂]，可以理解为动态Rust库，同样由Rust编译器来使用。</strong>该类型在Linux上会创建<strong>*.so</strong>文件，在MacOSX上会创建<strong>*.dylib</strong>文件，在Windows上会创建<strong>*.dll</strong>文件。 </li>
<li><strong>–crate-type=staticlib或＃[crate_type=＂staticlib＂]，将生成静态系统库。Rust编译器永远不会链接该类型库，主要用于和C语言进行链接，达成和其他语言交互的目的。</strong>静态系统库在Linux和MacOSX上会创建<strong>*.a</strong>文件，在Windows上会创建<strong>*.lib</strong>文件。</li>
<li><strong>–crate-type=cdylib或＃[crate_type=＂cdylib＂]，将生成动态系统库。同样用于生成C接口，和其他语言交互。</strong>该类型在Linux上会创建<strong>*.so</strong>文件，在MacOSX上会创建<strong>*.dylib</strong>文件，在Windows上会创建<strong>*.dll</strong>文件。</li>
</ul>
<p>需要注意的是，<strong>crate_type可以指定多个。有时候会有这种情况出现：包A依赖包B，而包B需要生成一个staticlib静态系统库。这时，就需要为包B同时指定staticlib和rlib两种包类型。</strong> </p>
<p>只要ABI统一，两个库就可以相互链接。在链接之后，就可以实现相互调用。所以，Rust要和其他语言交互，可以通过导出为C-ABI接口的静态库或动态库，然后其他语言链接该库，就可以实现语言之间的相互调用。</p>
<p><strong>（3）交叉编译</strong> </p>
<p>以上说的是本地编译的情况，<strong>Rust也支持交叉编译，几乎做到了开箱即用。在本地平台上编译出需要放在其他平台运行的程序，就叫交叉编译。</strong>比如，在x86平台上编译可以在ARM嵌入式单片机上运行的程序。可以使用rustc进行交叉编译，只需要给rustc传递一个target 参数即可。如代码清单13-48所示。 </p>
<p>代码清单<strong>13-48</strong>：<strong>rustc</strong>交叉编译命令</p>
<pre><code>$ rustc --target=arm-unknown-linux-gnueabihf hello.rs</code></pre><p>这样就可以工作了。当然，如果是针对ARM嵌入式开发平台，你的hello.rs文件不能使用std标准库。如代码清单13-49所示。 </p>
<p>代码清单<strong>13-49</strong>：<strong>hello.rs</strong>需要配置好<strong>no_std</strong> </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// hello.rs</span>
#<span class="token operator">!</span><span class="token punctuation">[</span>crate_type<span class="token operator">=</span><span class="token string">"lib"</span><span class="token punctuation">]</span>
<span class="token attribute attr-name">#![no_std]</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello，world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为std不支持ARM单片机，所以这里使用了<strong>＃！[no_std]</strong>属性。当然，嵌入式推荐的做法应该是使用<strong>core</strong>。 </p>
<p><strong>除了rustc，也可以使用Cargo进行交叉编译。使用方法和rustc类似，给cargo build命令传递–target参数即可。默认情况下，cargo命令会使用cc作为交叉编译的链接器。也可以通过修改Cargo的配置文件来指定链接器。</strong>如代码清单13-50所示。 </p>
<p>代码清单<strong>13-50</strong>：使用<strong>cargo</strong>进行交叉编译示意 </p>
<pre><code># 通过配置文件指定链接器
$ cat ~/.cargo/config
[target.arm-unknown-linux-gnueabihf]
linker = &quot;arm-linux-gnueabihf-gcc-4.8&quot;
# 使用cargo交叉编译
$ cargo new --lib hello
$ cd hello
$ cargo build --target=arm-unknown-linux-gnueabihf</code></pre><p>上面的示例中，target参数后面类似于<strong>arm-unknown-linux-gnueabihf</strong>这样的格式，叫作<strong>target triple</strong>格式。Triple格式是交叉编译前必须要确认好的，格式含义如下：</p>
<pre><code>{arch}-{vendor}-{sys}-{abi}</code></pre><p>其中:</p>
<ul>
<li><strong>arch</strong>代表编译程序的主机系统，如果是嵌入式系统，就是arm。</li>
<li>第二个<strong>vendor</strong>是指供应商，如果是未知，就可以指定为unknow。</li>
<li>第三个<strong>sys</strong>代表操作系统，比如Linux。</li>
<li>最后的abi代表的是ABI接口，比如gnueabihf表示的是系统使用glibc作为C标准库（libc）的实现，并具有硬件加速浮点运算（FPU）功能。</li>
</ul>
<p>这样就得到了最终的arm-unknown-linux-gnueabihf目标triple格式。当然，有时候也可以省略最后的abi，比如x86_64-apple-darwin、wasm32-unknown-unknown等[2]。 </p>
<p>Rust社区还提供了第三方交叉编译工具<strong>xargo</strong>，使用该工具可以更方便地进行交叉编译，还允许开发者构建一个定制的std库。当前，Rust官方着手进行xargo和rustup工具的整合。 </p>
<p><strong>(4) extern语法</strong> </p>
<p><strong>Rust提供了extern语法使得FFI非常便于使用</strong>。 </p>
<ul>
<li><strong>extern关键字。通过extern关键字声明的函数，可以在Rust和C语言中自由使用。</strong> </li>
<li><strong>extern块。如果在Rust中调用C代码，则可以使用extern块，将外部的C函数进行逐个标记，以供Rust内部调用。</strong> </li>
</ul>
<p><strong>编译器会根据extern语法自动在Rust-ABI和C-ABI之间切换</strong>。有三个extern ABI字符串是跨平台的： </p>
<ul>
<li><strong>extern＂Rust＂，这是默认的ABI，任何普通的fn函数都将使用该ABI</strong>。</li>
<li><strong>extern＂C＂，这是指定使用C-ABI，等价于“extern fn foo（）”这样的函数声明</strong>。</li>
<li><strong>extern＂system＂，这和extern＂C＂是相似的，只是在Win32平台上等价于＂stdcall＂</strong>。 </li>
</ul>
<p>除此之外，Rust还支持其他extern ABI字符串，详情可以参见官方Reference页面。另外还有三个Rust编译器专用的ABI字符串： </p>
<ul>
<li>extern＂rust-intrinsic＂，代表Rust编译器内部函数的ABI。 </li>
<li>extern＂rust-call＂，Fn：：call的ABI。 </li>
<li>extern＂platform-intrinsic＂，特定平台内在函数的ABI。接下来，看看具体如何使用extern语法和其他语言进行交互。</li>
</ul>
<h3 id="13-3-2-与C-C-语言交互"><a href="#13-3-2-与C-C-语言交互" class="headerlink" title="13.3.2 与C/C++语言交互"></a>13.3.2 与C/C++语言交互</h3><p>C语言这种万能“胶水”语言赋予了Rust和其他语言通信的能力。</p>
<p><strong>Rust中可以方便无缝地调用C函数，所以对于现有的操作系统和一些C/C++实现的底层系统库，可以使用Rust进行安全无缝地绑定和扩展，达到从C/C++向Rust迁移的目的，甚至也可以让Rust和C/C++协同工作。</strong>比如，把系统中对安全要求高的部分迁移到Rust，其余部分继续用C/C++，保留原始的性能。 </p>
<p><strong>通过C-ABI，Rust也可以被其他语言调用。一般用于提升动态语言的性能</strong>，比如Ruby、Python、Node.js等。<strong>可以把系统中造成性能瓶颈的部分用Rust来重写，然后通过FFI在动态语言中调用。</strong> </p>
<p><strong>(1) 在Rust中调用C函数</strong> </p>
<p>代码清单13-51简单展示了在Rust中调用C标准库函数。 </p>
<p>代码清单<strong>13-51</strong>：<strong>Rust</strong>中调用<strong>C</strong>标准库函数 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">isalnum</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Is 3 a number ? the answer is :{} "</span><span class="token punctuation">,</span> <span class="token function">isalnum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// println!("Is 'a' a number ?", isalnum('a'));</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-51中，第1行在extern ＂C＂块内部定义了isalnum函数签名。然后在main函数中就可以直接调用操作系统C标准库内置的isalnum函数。这里也可以直接使用extern块，而省略掉ABI字符串＂C＂。因为默认的extern块就是按C-ABI处理的。 </p>
<p>注意，被注释的代码第7行给isalnum函数传入了字符＇a＇，但是编译会报错。这是因为在extern块内的函数签名要求参数必须是数字类型。可以看出，Rust的类型系统在这里相当有用。</p>
<p><strong>(2) 在Rust中调用C++函数</strong> </p>
<p>在Rust中也可以调用C++函数，前提是C++也需要使用C-ABI。 </p>
<p>现在使用cargo来创建一个新的bin项目rustcallcpp，如代码清单13-52所示。</p>
<p>代码清单<strong>13-52</strong>：创建新项目<strong>rustcallcapp</strong> </p>
<pre><code>$ cargo new --bin rustcallcap</code></pre><p>接下来修改项目rustcallcapp中的Cargo.toml文件，如代码清单13-53所示。</p>
<p>代码清单<strong>13-53</strong>：修改<strong>Cargo.toml</strong>文件 </p>
<pre><code>[package]
name = &quot;rustcallcpp&quot;
version = &quot;0.1.0&quot;
authors = [&quot;blackanger &lt;bill@gmail.com&gt;&quot;]
build = &quot;build.rs&quot;
edition = &quot;2018&quot;
[build-dependencies]
cc = &quot;1.0&quot;</code></pre><p>代码清单13-53中，添加了build.rs文件配置，以及build依赖库cc。Rust中想要调用C/C++，首先需要链接C/C++生成的静态/动态库。可以通过手动调用gcc或g++来编译C/C++文件，使用<strong>ar</strong>工具来生成静态库。但是，现在是制作Rust的crate，这些工作需要自动化。所以这里要利用<strong>build.rs</strong>文件，在Rust构建之前，将依赖的C/C++库打包好。构建依赖的库<strong>cc</strong>是对gcc等各大平台C/C++编译器的抽象。 </p>
<p>接下来在rustcallcpp项目中创建一个文件夹cpp_src，用于放置C++代码。在目录中创建sorting.cpp和sorting.h文件。整个项目的目录结构如代码清单13-54所示。 </p>
<p>代码清单<strong>13-54</strong>：当前<strong>rustcallcpp</strong>文件目录结构</p>
<pre><code>.
├─ Cargo.lock
├─ Cargo.toml
├─ build.rs
├─ cpp_src
│    ├─ sorting.cpp
│    └─ sorting.h
└─ src
    └─ main.rs</code></pre><p>该目录中的sorting.cpp文件正是Rust中调用的C++函数定义所在。如代码清单13-55所示。 </p>
<p>代码清单<strong>13-55</strong>：<strong>sorting.cpp</strong>代码</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include "sorting.h"
void interop_sort(int numbers[], size_t size)
{
    int* start = &numbers[0];
    int* end = &numbers[0] + size;
    std::sort(start, end, [](int x, int y) { return x > y;});
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sorting.cpp中定义了一个排序函数interop_sort，接收两个参数，分别是数组和数组长度。然后调用C++内置的sort函数对传入的数组进行排序。</p>
<p>在sorting.h头文件中，为其声明C接口。如代码清单13-56所示。 </p>
<p>代码清单<strong>13-56</strong>：<strong>sorting.h</strong>头文件代码</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> __SORTING_H__</span>
<span class="token macro property">#<span class="token directive keyword">define</span> __SORTING_H__ "sorting.h"</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token keyword">void</span> <span class="token function">interop_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sorting.h头文件中，使用extern ＂C＂将interop_sort函数导出为C接口，以便在Rust中调用。 </p>
<p>接下来，在src/main.rs中调用该函数，如代码清单13-57所示。 </p>
<p>代码清单<strong>13-57</strong>：<strong>src/main.rs</strong>代码</p>
<pre class="line-numbers language-rust"><code class="language-rust">#<span class="token punctuation">[</span><span class="token function">link</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"sorting"</span><span class="token punctuation">,</span> kind <span class="token operator">=</span> <span class="token string">"static"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">extern</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">interop_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">sort_from_cpp</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> u32<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">interop_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_arr<span class="token punctuation">:</span> <span class="token punctuation">[</span>i32<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Before sorting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?} \n"</span><span class="token punctuation">,</span> my_arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort_from_cpp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"After sorting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> my_arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-57中，代码第1行使用<strong>＃[link（name=＂sorting＂，kind=＂static＂）]属性，表示和Rust链接的是名为libsorting的静态库</strong>。该属性也可以省略，Rust会使用默认生成的名字。这个属性主要用于在需要的时候指定链接库的名字。 </p>
<p>代码第2～4行在extern块中声明了interop_sort的函数签名。注意输入的参数类型，第一个是数组的引用，因为C++中的数组实际上就是指针，这里要对应起来。 </p>
<p>在代码第5～9行定义了Rust的函数sort_from_cpp，是对C++中interop_sort函数的安全抽象。接下来在main函数中进行调用。</p>
<p>到目前为止，C++和Rust两头的代码都写完了，是不是可以直接编译运行了呢？其实还差一个步骤，那就是编写自动链接的代码。还记得build.rs文件吗？如代码清单13-58所示。 </p>
<p>代码清单<strong>13-58</strong>：<strong>build.rs</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> cc<span class="token punctuation">;</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cc<span class="token punctuation">:</span><span class="token punctuation">:</span>Build<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>cpp（<span class="token keyword">true</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">warnings</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flag</span><span class="token punctuation">(</span><span class="token string">"-Wall"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flag</span><span class="token punctuation">(</span><span class="token string">"-std=c++14"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flag</span><span class="token punctuation">(</span><span class="token string">"-c"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">file</span><span class="token punctuation">(</span><span class="token string">"cpp_src/sorting.cpp"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"sorting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单13-58中，使用了cc库。通过指定的参数，cc库会帮助开发者把cpp_src中的C++文件进行编译并自动生成静态库。整个过程相当于以下操作： </p>
<ul>
<li><strong>g++-Wall-std=c++14-c sorting.cpp</strong>，使用g++编译sorting.cpp文件。</li>
<li><strong>ar rc libsorting.a sorting.o</strong>，通过ar制作一份静态库libsorting.a。 </li>
</ul>
<p>现在就可以执行cargo run命令来运行代码了。输出结果如代码清单13-59所示。 </p>
<p>代码清单<strong>13-59</strong>：输出结果 </p>
<pre><code>Before sorting...
[10, 42, -9, 12, 8, 25, 7, 13, 55, -1]
After sorting...
[-9, -1, 7, 8, 10, 12, 13, 25, 42, 55]</code></pre><p>看得出来，C++中的排序函数输出了正确的结果。值得注意的是，如果main.rs中传入的数组长度小于10位，或者大于10位，均会引起Rust编译器报错。这也从侧面反映了从C++迁移到Rust有利于提升程序的健壮性。同时，如果查看target/debug/build文件夹，会看到生成的cpp_src/sorting.o和libsorting.a文件。 </p>
<p>如果不使用cc库，也可以在build.rs文件中使用Command：：new（＂g++＂）等命令来自动化编译C++文件的过程，但是不如cc库方便。当然，cc库也可以用于编写C绑定。</p>
<p><strong>(3) 在C中调用Rust函数</strong></p>
<p>在C中调用Rust函数中的思路同样也是通过静态库或动态库进行链接的。现在通过cargo命令创建callrust项目，如代码清单13-60所示。 </p>
<p>代码清单<strong>13-60</strong>：创建<strong>callrust</strong>项目 </p>
<pre><code>$ cargo new --lib callrust</code></pre><p>为了生成链接库，必须使用–lib参数创建库类型的项目。然后进入callrust项目中，创建需要的文件，目录结构如代码清单13-61所示。 </p>
<p>代码清单<strong>13-61</strong>：<strong>callrust</strong>目录结构 </p>
<pre><code>.
├─ Cargo.toml
├─ c_src
│    └─ main.c
├─ makefile
└─ src
    ├─ callrust.h
    └─ lib.rs</code></pre><p>注意代码清单13-61中，新增的文件夹和文件包括以下四个： </p>
<ul>
<li>c_src，用于存放C文件。 </li>
<li>c_src/main.c，用于编写C代码。 </li>
<li>src/callrust.h，用于编写Rust暴露的外部C接口。 </li>
<li>makefile，自动化编译链接过程。 </li>
</ul>
<p>接下来，修改Cargo.toml文件，如代码清单13-62所示。 </p>
<p>代码清单<strong>13-62</strong>：修改<strong>Cargo.toml</strong>文件 </p>
<pre><code>[dependencies]
libc = &quot;0.2&quot;
[lib]
name = &quot;callrust&quot;
crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;]</code></pre><p><strong>在Cargo.toml文件中增加libc依赖。libc库是对各大操作系统平台C标准库的Rust抽象，其中对C标准库接口函数做好了Rust绑定，可以直接拿来使用。</strong> </p>
<p>同时也设置了 Rust 链接库的名称为 <strong>callrust</strong>。指定了生成两种类型的链接库：<strong>staticlib</strong>和<strong>cdylib</strong>，分别代表兼容C-ABI的静态库和动态库。然后修改src/lib.rs文件，如代码清单13-63所示。 </p>
<p>代码清单<strong>13-63</strong>：修改<strong>src/lib.rs</strong>文件 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> libc<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">print_hello_from_rust</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello from Rust"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-63中引入了libc库。同时定义了print_hello_from_rust函数，<strong>pub extern</strong>关键字声明表明该函数为外部调用接口，extern默认是兼容C-ABI。 </p>
<p>其中，<strong>＃[no_mangle]属性是告诉Rust关闭函数名称修改功能。如果不加这个属性，Rust编译器就会修改函数名，这是现代编译器为了解决唯一名称解析引起的各种问题所引入的技术。</strong>如果函数名被修改了，那么在C代码中就无法按原名称调用，开发者也没办法知道修改后的函数名。</p>
<p>接下来打开src/callrust.h头文件，在其中声明print_hello_from_rust函数。该头文件将用于C和Rust库的链接。如代码清单13-64所示。 </p>
<p>代码清单<strong>13-64</strong>：修改<strong>src/callrust.h</strong>文件 </p>
<pre><code>void print_hello_from_rust();</code></pre><p>现在可以编写C代码了，打开c_src/main.c文件编写以下代码，如代码清单13-65所示。 </p>
<p>代码清单<strong>13-65</strong>：修改<strong>c_src/main.c</strong>文件</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"callrust.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pirnt_hello_from_rust</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-65中引入了<strong>callrust.h</strong>头文件，以及其他标准头文件。然后在main函数直接调用print_hello_from_rust函数。 </p>
<p>接下来还需要编写<strong>makefile</strong>文件，这样就可以把编译链接过程通过<strong>make</strong>命令进行自动化处理，如代码清单13-66所示。 </p>
<p>代码清单<strong>13-66</strong>：修改<strong>makefile</strong>文件 </p>
<pre><code>GCC_BIN ?= $(shell which gcc)
CARGO_BIN ?= $(shell which cargo)
run: clean build
     ./c_src/main
clean:
    $(CARGO_BIN) clean
    rm -r ./c_src/main
build:
    $(CARGO_BIN) build
    $(GCC_BIN) -o ./c_src/main ./c_src/main.c -Isrc -L ./target/debug -lcallrust</code></pre><p>代码清单13-66中定义了三个make命令：<strong>run</strong>、<strong>clean</strong>和<strong>build</strong>。其中build命令包含两步操作： </p>
<ul>
<li>通过<strong>cargo build</strong>命令构建Rust程序，生成已指定的C-ABI兼容的静态库和动态库。 </li>
<li>使用<strong>gcc</strong>命令编译C代码，链接Rust库，生成目标二进制可执行文件main。</li>
</ul>
<p>注意makefile文件中的缩进，必须是制表符（tab），而非空格。 </p>
<p>接下来就可以在项目根目录下执行make命令或make run命令，编译并运行程序，输出结果如代码清单13-67所示。</p>
<p>代码清单<strong>13-67</strong>：输出结果 </p>
<pre><code>/usr/bin/gcc -o ./c_src/main ./c_src/main.c -Isrc -L ./target/debug -lcallrust
./c_src/main
Hello from Rust</code></pre><p>代码清单13-67输出结果中包含了make执行的命令，以及最终print_hello_from_rust函数的执行结果。</p>
<p><strong>(4) 类型匹配与内存布局</strong> </p>
<p>前面的演示代码中，没有展示Rust和C相互传递参数的情况。实际上，在开发Rust和C相互调用的程序时，根本无法避免相互传递参数。 所以，在需要传递参数的情况下，必须保证参数的类型和内存布局可以满足调用约定。 </p>
<p>继续使用callrust项目作为演示。在Rust中实现一个检测字符串长度的函数，然后在C中调用。在callrust项目的src/lib.rs中添加代码，如代码清单13-68所示。 </p>
<p>代码清单<strong>13-68</strong>：在<strong>src/lib.rs</strong>中新增代码 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> libc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>c_char<span class="token punctuation">,</span> c_uint<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ffi<span class="token punctuation">:</span><span class="token punctuation">:</span>CStr<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">hm_chars</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> c_char<span class="token punctuation">)</span> <span class="token punctuation">-></span> c_uint <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c_str <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CStr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r_str <span class="token operator">=</span> c_str<span class="token punctuation">.</span><span class="token function">to_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r_str<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> c_uint
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-68中，定义了外部接口函数hm_chars，该函数主要用于统计传入的字符串长度。这时就应该考虑这样一个问题：该函数会在C代码中被调用，但是C语言中的字符串是一个以“<strong>\n</strong>”结尾的字符数组，实际上由一个<strong>char*str</strong>指针来定义。那么在Rust中定义该函数时，参数的类型应该是什么？如图13-4所示。</p>
<p><img src="/2021/03/22/the-tao-of-rust-programming-13/image-20210523145347407.png" alt="image-20210523145347407"></p>
<p>C中调用hm_chars函数时传入char*str指针，所以Rust中定义该函数时，也应该注意参数的类型与C语言的char*str指针相匹配。 </p>
<p>Rust的Char类型和C的Char类型完全不同，在Rust中Char类型是一个Unicode标量值，但是C中Char只是一个普通的整数。Rust标准库在std：：os：：raw模块中提供了与C语言中各种类型相匹配的映射类型。比如提供了 c_char 类型，其实就是 i8 类型的别名。所以，hm_chars函数的参数可以标注为std：：os_raw模块中的c_char类型。</p>
<p>但是在callrust项目中已经依赖了libc库，该库也提供了对C中基本数据类型的映射。在本示例中选择使用libc库中的c_char类型。通常情况下，使用std：：os：：raw模块或libc都没有什么区别，除非使用了libc特有的功能。但是需要知道一个事实，libc库不依赖std，所以请根据实际的使用情况进行选择。 </p>
<p>在Rust函数内部进行处理的时候，需要转换成Rust中的字符串类型。为了方便转换，Rust标准库std：：ffi模块中提供了<strong>CStr</strong> 类型，该类型会产生一个以“\n”字符数组的引用。所以在代码第5～8行先通过CStr：：from函数将c_char字符类型转成Rust可用的CStr类型。当然，要判断传入的字符串是否为空。 </p>
<p>在代码第9行，将CStr类型的字符串转换成&amp;strl类型，然后在第10行中通过调用chars方法转换成Rust的字符数组，通过调用数组的count方法进行字符串长度统计，最终返回统计数字。这里需要再次注意，该返回值在C代码中有可能被使用，所以返回类型应该是兼容C-ABI的类型。这里使用了libc库中定义的<strong>c_uint</strong>类型。 </p>
<p>接下来，在<strong>callrust.h</strong>头文件中添加hm_chars函数的声明，就可以保证其在链接之后在C代码中被调用。如代码清单13-69所示。 </p>
<p>代码清单<strong>13-69</strong>：在<strong>src/callrust.h</strong>头文件中新增代码 </p>
<pre><code>#include &lt;inttypes.h&gt;
uint32_t hm_chars(const char *str);</code></pre><p>代码清单13-69中新增了两行声明，其中hm_chars返回值在C语言中是<strong>uint32_t</strong>类型，该类型在<strong>inttypes.h</strong>头文件中被定义，所以这里需要引入该头文件。 </p>
<p>然后回到c_str/main.c文件中，在main函数中调用hm_chars函数。如代码清单13-70所示。 </p>
<p>代码清单<strong>13-70</strong>：在<strong>c_str/main.c</strong>文件的<strong>main</strong>函数中新增代码 </p>
<pre class="line-numbers language-c"><code class="language-c">uint32_t count <span class="token operator">=</span> <span class="token function">hm_chars</span><span class="token punctuation">(</span><span class="token string">"The tao of Rust"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>代码清单13-70展示的是在main函数中新增的两行代码。第1行调用hm_chars函数，传入字符串字面量，返回值赋值给count变量。第2行输出count的值。 </p>
<p>在命令行中，callrust项目根目录下执行make命令，代码正常编译运行。输出结果如代码清单13-71所示。 </p>
<p>代码清单<strong>13-71</strong>：执行<strong>make</strong>后的输出结果 </p>
<pre><code>//此处省略掉之前函数的输出
15</code></pre><p>看得出来，输出结果是正确的。 </p>
<p>接下来，在src/lib.rs中实现另外一个函数，如代码清单13-72所示。 </p>
<p>代码清单<strong>13-72</strong>：在<strong>src/lib.rs</strong>中实现新的函数</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ffi<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>CStr<span class="token punctuation">,</span> CString<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>iter<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">batman_song</span><span class="token punctuation">(</span>length<span class="token punctuation">:</span> c_uint<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">*</span><span class="token keyword">mut</span> c_char <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> song <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"boom "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    song<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>iter<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"nana "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span>length <span class="token keyword">as</span> usize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    song<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"Batman! boom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c_str_song <span class="token operator">=</span> CString<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>song<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c_str_song<span class="token punctuation">.</span><span class="token function">into_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-72中定义了新的函数batman_song，它的目的是输出一个字符串“boom nana nana nana Batman！boom”，可以称其为“蝙蝠侠之歌”。该字符串中的“nana”可以重复，重复次数是由batman_song函数的参数来指定。 </p>
<p>该函数在C代码中被调用，传入C语言的一个数字类型，然后创建Rust的一个String字符串，只有String字符串才可以动态扩展。接着通过std：：ffi模块中的<strong>CString</strong>类型将String转换成C-ABI兼容的字符串。这里和<strong>CStr</strong>的区别是，因为String是拥有所有权的数据类型，所以需要使用CString。如代码第8行和第9行所示，先由String创建CString类型的数据，然后通过into_raw方法转换为C兼容字符串。 </p>
<p>因为CString是拥有所有权的结构，现在将其返回为<strong>*mut c_char</strong>类型，供C代码使用。所有权的概念只存在于Rust，在C代码中使用完毕，该字符串的内存不会被自动清理。所以还必须再实现一个释放字符串内存的方法供C代码调用，如代码清单13-73所示。 </p>
<p>代码清单<strong>13-73</strong>：在<strong>src/lib.rs</strong>中增加新的函数<strong>free_song</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">free_song</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> c_char<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> s<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>
        CString<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_raw</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单 13-73 中，新增了函数 free_song，主要是将<strong>*mut c_char</strong>指针类型通过CString：：from函数转换为CString类型的字符串，然后就可以交给Rust编译器按所有权机制自动释放内存。 </p>
<p>接下来需要在src/callrust.h头文件中声明上面两个函数，以便在C中可以被调用，如代码清单13-74所示。 </p>
<p>代码清单<strong>13-74</strong>：在<strong>src/callrust.h</strong>头文件中增加新的函数声明 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//省略其他函数声明</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">batman_song</span><span class="token punctuation">(</span>uint8_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">free_song</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后打开c_src/main.c文件，在main函数中调用，如代码清单13-75所示。</p>
<p>代码清单<strong>13-75</strong>：在<strong>c_src/main.c</strong>文件的<strong>main</strong>函数中调用</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他代码</span>
<span class="token keyword">char</span> <span class="token operator">*</span>song <span class="token operator">=</span> <span class="token function">batman_song</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> song<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free_song</span><span class="token punctuation">(</span>song<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-75中，调用完batman_song函数之后，还需要调用free_song函数释放生成的字符串对应的内存，否则会引起内存泄漏。总之，需要记住，由谁分配内存，就由谁来释放。本例中是由Rust分配了 堆内存（String字符串），所以依然需要由Rust来释放内存。 </p>
<p>在终端执行make命令之后，代码正常编译运行，输出结果如代码清单13-76所示。 </p>
<p>代码清单<strong>13-76</strong>：输出结果 </p>
<pre><code>//此处省略之前函数的输出
boom nana nana nana nana nana Batman! boom</code></pre><p>输出结果如预期显示，说明调用正常。 </p>
<p>Rust和C之间除了可以相互传递字符串，还可以传递更复杂的类型，比如切片、元组和结构体等。 </p>
<p>现在编写一个函数，用于计算整数数组中奇数元素之和，如代码清单13-77所示。</p>
<p>代码清单<strong>13-77</strong>：在<strong>src/lib.rs</strong>新增函数 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>slice<span class="token punctuation">;</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">sum_of_even</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> c_uint<span class="token punctuation">,</span> len<span class="token punctuation">:</span> c_uint<span class="token punctuation">)</span> <span class="token punctuation">-></span> c_uint
<span class="token punctuation">{</span>
    <span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        slice<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_raw_parts</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> len <span class="token keyword">as</span> usize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>v<span class="token operator">|</span> v <span class="token operator">%</span> s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">|</span>acc<span class="token punctuation">,</span> v<span class="token operator">|</span> acc <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token keyword">as</span> c_unit
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C函数中的数组就是指针加数组长度，对应于Rust中就是切片类型。所以代码清单13-77中新增的函数sum_of_even的参数就是<strong>*const c_uint</strong>类型的指针，以及c_uint类型的长度。 </p>
<p>在代码第5～8行，使用slice：：from_raw_parts函数将C语言对应的数组转为切片类型。然后在代码第9～11行中，通过迭代过滤掉偶数，并累计剩余奇数之和。最终将求和结果返回。 </p>
<p>修改src/callrust.h头文件，声明该函数，如代码清单13-78所示。 </p>
<p>代码清单<strong>13-78</strong>：在<strong>src/callrust.h</strong>头文件中新增函数声明 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他函数声明</span>
<span class="token macro property">#inclued &lt;stdio.h></span>
uint32_t <span class="token function">sum_of_even</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint32_t <span class="token operator">*</span>numbers<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在代码清单13-78中，需要引入<strong>stdio.h</strong>头文件，因为函数签名中用到了<strong>size_t</strong>类型。 </p>
<p>接下来在c_src/main.c文件的main函数中添加调用代码，如代码清单13-79所示。 </p>
<p>代码清单<strong>13-79</strong>：在<strong>c_src/main.c</strong>文件的<strong>main</strong>函数中调用</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他代码</span>
uint32_t numbers<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
uint32_t sum <span class="token operator">=</span> <span class="token function">sum_of_even</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行make命令，可以看到正确的输出结果。 </p>
<p>在C和Rust之间如何传递元组呢？C语言中虽然没有元组类型，但是有结构体，可以用结构体来模拟元组。C和Rust之间可以传递结构体，只需要满足调用约定即可，如代码清单13-80所示。 </p>
<p>代码清单<strong>13-80</strong>：在<strong>src/lib.rs</strong>中新增处理元组相关代码</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[repr(C)]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Tuple <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> c_uint<span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> c_unit<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> From<span class="token operator">&lt;</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token operator">></span> <span class="token keyword">for</span> Tuple <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">from</span><span class="token punctuation">(</span>tup<span class="token punctuation">:</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Tuple <span class="token punctuation">{</span>
        Tuple <span class="token punctuation">{</span>x<span class="token punctuation">:</span> tup<span class="token punctuation">.</span>0m y<span class="token punctuation">:</span> tup<span class="token number">.1</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> From<span class="token operator">&lt;</span>Tuple<span class="token operator">></span> <span class="token keyword">for</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">from</span><span class="token punctuation">(</span>tup<span class="token punctuation">:</span> Tuple<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span>tup<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tup<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">compute_tuple</span><span class="token punctuation">(</span>tup<span class="token punctuation">:</span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span>u32<span class="token punctuation">,</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token number">-1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">flip_things_around</span><span class="token punctuation">(</span>tup<span class="token punctuation">:</span> Tuple<span class="token punctuation">)</span> <span class="token punctuation">-></span> Tuple <span class="token punctuation">{</span>
    <span class="token function">compute_tuple</span><span class="token punctuation">(</span>tup<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-80中，第1～5行定义了结构体Tuple，它是用来模拟元组的。该结构体使用＃<strong>[repr</strong>（<strong>C</strong>）<strong>]</strong>属性，表明它的内存布局兼容C-ABI。在C和Rust之间传递元组，本质就是传递该结构体。 </p>
<p>代码第6～9行为Tuple结构体实现From＜（u32，u32）＞，这是为了方便将Rust的（u32，u32）元组类型转换为Tuple类型。同理，代码第10～15行为（u32，u32）实现了From＜Tuple＞，是为了将Tuple类型逆转为元组类型。 </p>
<p>代码第16～19行用于计算元组中的元素，并返回新的元组。 </p>
<p>代码第 20～23 行则定义了外部函数接口 flip_things_around，其函数内部调用了compute_tuple函数。注意，调用tup.into方法是将Tuple转换为元组类型，传到computer_tuple函数中进行计算，并在之后返回新的元组。然后再次调用into方法，则可以由元组转换为Tuple类型并返回。</p>
<p>接下来修改src/callrust.h头文件，如代码清单13-81所示。 </p>
<p>代码清单<strong>13-81</strong>：在<strong>src/callrust.h</strong>头文件中新增函数声明</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他代码</span>
tuple_t initial <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
tuple_t new <span class="token operator">=</span> <span class="token function">flip_things_around</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"(%d, %d)\n"</span><span class="token punctuation">,</span> new<span class="token punctuation">.</span>x<span class="token punctuation">,</span> new<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-82中，初始化了tuple_t类型的结构体实例，然后传入flip_things_around函数中，并分别打印结构体字段x和y的值。在执行make命令之后，输出结果按预期显示为“（21，9）”。 </p>
<p>如果 <strong>C</strong> 和 <strong>Rust</strong> 之间需要传递更加复杂的类型，可以使用 <strong>C</strong> 语言中的不透明数据类型（<strong>Opaque</strong>）和<strong>Rust</strong>中的<strong>Box</strong>＜<strong>T</strong>＞相对应。如代码清单13-83所示。 </p>
<p>代码清单<strong>13-83</strong>：在<strong>src/lib.rs</strong>中新增代码 </p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>collections<span class="token punctuation">:</span><span class="token punctuation">:</span>HashMap<span class="token punctuation">;</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Database <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> u32<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Database <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Database <span class="token punctuation">{</span>
        Database <span class="token punctuation">{</span>
            data<span class="token punctuation">:</span> HashMap<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">100000</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> zip <span class="token operator">=</span> <span class="token function">format!</span><span class="token punctuation">(</span><span class="token string">"{:0.5}"</span><span class="token punctuation">.</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>zip<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> zip<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>zip<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cloned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-83中定义了结构体Database，包含HashMap＜String，u32＞类型的字段，用于模拟一个数据库，并且定义了 new 函数，以及insert 和 get 方法。其中 new 函数用于创建Database实例。另外的insert方法则默认往结构体实例中插入1000000个形如“<strong>＂100086＂=＞100086</strong>”的键值对，其中字符串类型为键，数字类型为值。get方法则是根据传入的字符串，取出对应的值。 </p>
<p>注意，这里的 Database 结构体是需要传递给 C 代码使用的，但是为什么这里没有使用＃<strong>[repr</strong>（<strong>C</strong>）<strong>]</strong>来保证其内存布局是C-ABI兼容呢？因为在C代码中，要使用抽象的结构体类型与其相对应，并非一个具体的结构体类型。这种抽象的结构体类型叫作不透明数据类型。 </p>
<p>如何在C代码中使用该结构体及其方法呢？如代码清单13-84所示。 </p>
<p>代码清单<strong>13-84</strong>：继续在<strong>src/lib.rs</strong>中新增代码</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">database_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">*</span><span class="token keyword">mut</span> Database <span class="token punctuation">{</span>
    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">into_raw</span><span class="token punctuation">(</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Database<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">database_insert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> Database<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> database <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token operator">*</span>ptr
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    database<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">database_qurey</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> Database<span class="token punctuation">,</span>
    zip<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> c_char<span class="token punctuation">)</span> <span class="token punctuation">-></span> c_uint
<span class="token punctuation">{</span>
    <span class="token keyword">let</span> database <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span><span class="token operator">*</span>ptr
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> zip <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token operator">!</span>zip<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CStr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_ptr</span><span class="token punctuation">(</span>zip<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> zip_str <span class="token operator">=</span> zip<span class="token punctuation">.</span><span class="token function">to_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    database<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>zip_str<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token keyword">fn</span> <span class="token function">database_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> Database<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> ptr<span class="token punctuation">.</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">form_raw</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单 13-84 中定义了三个外部函数接口：database_new、database_insert 和database_query，分别对应Database结构体的new、insert和get。</p>
<p>代码第2～4行定义了database_new函数，返回值类型是*mut Database，代表Database结构体实例的原生可变指针。因为在C代码中使用的不透明数据类型实际上是一个指针。函数体内先使用Database：：new函数创建了结构体实例，然后使用Box：：new函数将其装箱，最后使用Box：：into_raw生成*mut Database类型原生指针返回。将Database的结构体实例放到堆内存，是为了拥有稳定的内存地址，因此传递给C使用是安全的。 </p>
<p>代码第5～27行分别定义了database_insert和database_query方法，主要是对结构体实例中的 HashMap＜String，u32＞进行插入和查询操作这里需要注意的是，第一个参数*mut Database指针需要转换为引用才可以调用Database的实例方法。 </p>
<p>代码第28～32行定义了database_free函数，因为堆内存是在Rust中分配的，所以必须由Rust来释放。在C代码中调用该函数就可以释放Box分配的堆内存。注意，释放内存的操作也很简单，只需要将原生指针转换为Box类型即可，因为Box拥有所有权，在该函数调用完毕会自动释放掉相应的堆内存。 </p>
<p>接下来，就可以在lib/callrust.h头文件中声明这些函数接口，如代码清单13-85所示。 </p>
<p>代码清单<strong>13-85</strong>：在<strong>src/callrust.h</strong>头文件中声明新的函数接口 </p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他函数声明</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> database_S database_t<span class="token punctuation">;</span>
database_t <span class="token operator">*</span> <span class="token function">database_new</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">database_free</span><span class="token punctuation">(</span>database_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">database_insert</span><span class="token punctuation">(</span>database_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uint32_t <span class="token function">database_query</span><span class="token punctuation">(</span><span class="token keyword">const</span> database_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>zip<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-85中第2行定义了抽象结构体database_S和database_t类型，也就是前面提到的不透明数据类型，它实际上是一个指针。 </p>
<p>然后在c_src/main.c文件的main函数中调用这些函数，如代码清单13-86所示。 </p>
<p>代码清单<strong>13-86</strong>：在<strong>c_src/main.c</strong>文件的<strong>main</strong>函数中新增调用代码</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 省略其他代码</span>
database_t <span class="token operator">*</span>database <span class="token operator">=</span> <span class="token function">database_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">database_insert</span><span class="token punctuation">(</span>database<span class="token punctuation">)</span><span class="token punctuation">;</span>
uint32_t pop1 <span class="token operator">=</span> <span class="token function">database_query</span><span class="token punctuation">(</span>database<span class="token punctuation">,</span> <span class="token string">"10186"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uint32_t pop2 <span class="token operator">=</span> <span class="token function">database_query</span><span class="token punctuation">(</span>database<span class="token punctuation">,</span> <span class="token string">"10852"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">database_free</span><span class="token punctuation">(</span>database<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span>m pop2 <span class="token operator">-</span> pop1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行make命令，代码正常编译运行，并输出预期结果为“666”。</p>
<p><strong>(5) 第三方工具介绍</strong> </p>
<p>在前面编写Rust中调用C函数的代码时，重复最多的工作就是在extern块中声明外部函数接口。而在写 C 中调用 Rust 的代码时，重复最多的工作就是在头文件中增加外部函数接口。 </p>
<p>于是社区中出现了一些工具可以帮助开发者自动完成以下这些工作：</p>
<ul>
<li><strong>rust-bindgen</strong>，该库可以根据头文件自动生成Rust FFI的C绑定，也支持部分C++功能。 </li>
<li><strong>cbindgen</strong>，该库可以根据Rust代码自动生成头文件。 </li>
<li><strong>ctest</strong>，该库可以为Rust FFI的C绑定自动生成测试文件。 </li>
</ul>
<p>使用这三个库，就可以提升FFI的开发效率。更多的使用细节可以参考它们的文档。 </p>
<p>另外，针对移动平台，也有两个库推荐： </p>
<ul>
<li><strong>cargo-lipo</strong>，提供cargo lipo命令，自动生成用于iOS的通用库。 </li>
<li><strong>jni</strong>，提供Rust的JNI绑定，用于和Android平台交互。 </li>
</ul>
<p>Rust用于iOS/Android平台时，涉及交叉编译，要注意设置相关的target格式。</p>
<h3 id="13-3-3-使用Rust提升动态语言性能"><a href="#13-3-3-使用Rust提升动态语言性能" class="headerlink" title="13.3.3 使用Rust提升动态语言性能"></a>13.3.3 使用Rust提升动态语言性能</h3><p><strong>使用Rust可以为Ruby、Python、Node.js等动态语言编写本地扩展</strong>。在Rust诞生之前，普遍使用C和C++为动态语言编写扩展，但是存在内存安全风险，甚至引起内存泄漏。<strong>使用Rust为动态语言编写扩展，既可以保证性能，还能提升内存安全。</strong> </p>
<p>动态语言都有自己的虚拟机，所以调用Rust代码不可能像C/C++那样可以直接链接Rust的链接库获取相关的函数调用信息。所以，<strong>动态语言提供的 FFI 基本都是基于 libffi 库来实现动态调用C函数的能力，兼容C-ABI的链接库都可以直接被动态调用。该libffi库是动态语言虚拟机和二进制的一道桥梁。</strong> </p>
<p><strong>(1) 为Ruby写扩展</strong> </p>
<p>在Ruby语言中，可以使用ffi gem来编写扩展。继续使用callrust项目的示例，在根目录下创建Ruby目录，并在其中创建database.rb文件，然后编写扩展代码。如代码清单13-87所示。 </p>
<p>代码清单<strong>13-87</strong>：在<strong>Ruby/database.rb</strong>中添加<strong>Ruby</strong>代码</p>
<pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'ffi'</span>
<span class="token keyword">class</span> <span class="token class-name">Database</span> <span class="token operator">&lt;</span> <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token symbol">:AutoPointer</span>
  <span class="token keyword">def</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
      <span class="token builtin">Binding</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
  <span class="token keyword">def</span> insert
      <span class="token builtin">Binding</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>
  <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>zip<span class="token punctuation">)</span>
      <span class="token builtin">Binding</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> zip<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
  <span class="token keyword">module</span> <span class="token builtin">Binding</span>
      extern <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token symbol">:Library</span>
      ffi_lib <span class="token string">"../target/debug/libcallrust.dylib"</span>
      attach_function <span class="token symbol">:new</span><span class="token punctuation">,</span> <span class="token symbol">:database_new</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">Database</span>
      attach_function <span class="token symbol">:free</span><span class="token punctuation">,</span> <span class="token symbol">:database_free</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">Database</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token symbol">:void</span>
      attach_function <span class="token symbol">:insert</span><span class="token punctuation">,</span> <span class="token symbol">:database_insert</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">Database</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token symbol">:void</span>
      attach_function <span class="token symbol">:query</span><span class="token punctuation">,</span> <span class="token symbol">:database_query</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">Database</span><span class="token punctuation">,</span> <span class="token symbol">:string</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token symbol">:unit32</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
database <span class="token operator">=</span> <span class="token constant">Databasea</span><span class="token punctuation">:</span><span class="token symbol">:Binding</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token class-name">database<span class="token punctuation">.</span>insert</span>
pop1 <span class="token operator">=</span> database<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"10186"</span><span class="token punctuation">)</span>
pop2 <span class="token operator">=</span> database<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"10852"</span><span class="token punctuation">)</span>
puts pop2 <span class="token operator">-</span> pop1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-87是在Ruby中调用Rust中定义的Database及其方法。为此，引入了ffi gem。 </p>
<p>代码第2～11行定义了继承于FFI：：AutoPointer的Database类。在FFI：：AutoPointer中定义了一个self.release方法，该方法会被Ruby的GC自动调用，以达到回收内存的目的。本着在Rust里分配内存就必须由Rust来释放的原则，Database类通过重载self.release方法，指定了一个Rust的回调方法来清理内存。同时也定义了insert和query实例方法，包装了Rust的函数调用。 </p>
<p>代码第 12～20 行定义了Binding模块。该模块通过extend方法混入（Mixin）FFI：：Library模块，就可以使用底层libffi的功能，动态调用Rust的链接库中的方法。其中代码第14行通过<strong>ffi_lib</strong>方法指定了Rust共享库[11]（此处用动态链接库）的位置。然后通过<strong>attach_function</strong>方法将Rust共享库中的函数绑定为Ruby中的方法。 </p>
<p>代码第22～26行在Ruby中调用这些方法。执行该Ruby文件，程序可正确运行。 </p>
<p>在Rust社区也提供了一些工具帮助开发者更方便地编写Ruby扩展，罗列如下： </p>
<ul>
<li><strong>Ruru</strong>和<strong>Rutie</strong>，均是Rust实现的Ruby虚拟机接口绑定，把Ruby中的各种内置数据类型、类定义等都进行了封装，方便编写Ruby扩展。 </li>
<li><strong>Helix</strong>，同样是对Ruby虚拟机接口的绑定，但是其实现了一个Ruby运行时，使用起来可以和Ruby进行无缝对接，更加方便。Helix还实现了helix-rails gem用于支持Rails框架，使用它可以方便地在Rails中引入 Helix写的Ruby扩展。 </li>
</ul>
<p>这三个工具虽然方便，但都存在一个问题：就是在Rust中创建的Ruby对象，如果放到堆内存中再传递给Ruby中调用，Ruby GC将无视该对象的存在，这样势必会引起内存泄漏。解决办法也比较简单，比如可以将这些 Ruby 对象用 Rust 中的固定长度数组包裹起来传给Ruby，因为固定长度数组是在栈上。 </p>
<p><strong>(2) 为Python写扩展</strong> </p>
<p>同样，也可以为Python写Rust扩展。以Python 3为例，只需要使用内置的CTypes模块就可以。基于底层libffi的能力，CTypes模块可以直接加载兼容C-ABI的共享库。 </p>
<p>在callrust项目根目录中创建Python文件夹和database.py文件，并编写代码，如代码清单13-88所示。 </p>
<p>代码清单<strong>13-88</strong>：在<strong>Python/database.py</strong>中添加<strong>Python</strong>代码</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>
<span class="token keyword">import</span> sys<span class="token punctuation">,</span> ctypes
<span class="token keyword">from</span> ctypes <span class="token keyword">import</span> c_char_p<span class="token punctuation">,</span> c_uint32<span class="token punctuation">,</span> Structure<span class="token punctuation">,</span> POINTER
prefix <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'win32'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>platform<span class="token punctuation">,</span> <span class="token string">'../target/debug/lib'</span><span class="token punctuation">)</span>
extension <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'darwin'</span><span class="token punctuation">:</span><span class="token string">'.dylib'</span><span class="token punctuation">,</span> <span class="token string">'win32'</span><span class="token punctuation">:</span> <span class="token string">'.dll'</span><span class="token punctuation">}</span> \
    <span class="token punctuation">.</span>get<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>platform<span class="token punctuation">,</span> <span class="token string">'.so'</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Database</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
lib <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>cdll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span>prefix <span class="token operator">+</span> <span class="token string">"callrust"</span> <span class="token operator">+</span> extension<span class="token punctuation">)</span>
lib<span class="token punctuation">.</span>database_new<span class="token punctuation">.</span>restype <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>DatabaseS<span class="token punctuation">)</span>
lib<span class="token punctuation">.</span>database_free<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">(</span>POINTER<span class="token punctuation">(</span>DatabaseS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>
lib<span class="token punctuation">.</span>database_insert<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">(</span>POINTER<span class="token punctuation">(</span>DatabaseS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>
lib<span class="token punctuation">.</span>database_query<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">(</span>POINTER<span class="token punctuation">(</span>DatabaseS<span class="token punctuation">)</span><span class="token punctuation">,</span> c_char_p<span class="token punctuation">)</span>
lib<span class="token punctuation">.</span>database_query<span class="token punctuation">.</span>restype <span class="token operator">=</span> c_unit32
<span class="token keyword">class</span> <span class="token class-name">Database</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>obj <span class="token operator">=</span> lib<span class="token punctuation">.</span>database_new<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__enter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">def</span> <span class="token function">__exit__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> exc_type<span class="token punctuation">,</span> exc_value<span class="token punctuation">,</span> tarceback<span class="token punctuation">)</span><span class="token punctuation">:</span>
        lib<span class="token punctuation">.</span>database_free<span class="token punctuation">(</span>self<span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        lib<span class="token punctuation">.</span>database_insert<span class="token punctuation">(</span>self<span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> zip<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> lib<span class="token punctuation">.</span>database_query<span class="token punctuation">(</span>self<span class="token punctuation">.</span>obj<span class="token punctuation">,</span> zip<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> Database<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> database<span class="token punctuation">:</span>
    database<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pop1 <span class="token operator">=</span> database<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">"10186"</span><span class="token punctuation">)</span>
    pop2 <span class="token operator">=</span> database<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">"10852"</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>pop2 <span class="token operator">-</span> pop1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-87中第2、3行导入了<strong>CTypes</strong>模块及需要的类型。</p>
<p>代码第4～6行定义了Rust共享库所在位置。注意，这里做了跨平台处理。代码第7～8行定义了空类DatabaseS，是为了在后面使用。 </p>
<p>代码第9～14行，使用CTypes模块中的方法动态加载共享库，并且为共享库中外部接口函数的参数和返回值指定了类型。利用CTypes模块的POINTER函数将空类DatabaseS转换为指针类型，如果不用DatabaseS作为参数，则POINTER会产生空指针。 </p>
<p>代码第15～25行定义了Database类。除默认的构造方法、insert和query外，还使用了<strong>enter</strong>和<strong>exit</strong>方法，这是为了让Database类的对象兼容<strong>with</strong>方法。with方法可以定义一个上下文管理器。当出现with语句的时候，对象的<strong>enter</strong>方法会被触发，其返回值会被赋值给as声明的变量。代码执行完之后，<strong>exit</strong>方法被触发进行最后的清理工作。</p>
<p>所以，在代码第26～30行中使用with语句调用共享库中绑定的函数。整个代码将正确执行，并且在执行完毕后，会触发<strong>exit</strong>方法调用Rust中的database_free方法来释放内存。</p>
<p>与Ruby类似，社区中也提供了一些第三方的工具支持更方便地为Python开发Rust扩展： </p>
<ul>
<li><strong>rust-cpython</strong>，是Python解释器的Rust绑定。支持Python 2.7和Python 3.3+。 </li>
<li><strong>PyO3</strong>，同样是 Python 解释器的 Rust 绑定，由 rust-cpython 分支演化而成，但比rust-cpython更好用。 </li>
</ul>
<p>两者有本质的不同，PyO3性能更快，并且更方便扩展。 </p>
<p><strong>(3) 为Node.js写扩展</strong> </p>
<p>众所周知，Node.js非常擅长处理I/O，但是如果业务中包含计算密集的操作会严重影响到性能，比如网络服务中URL解析，随着流量上升，CPU的占用就会越来越多。通常，Node.js支持使用C++编写原生模块来解决这个问题。但是既然现在有了更现代化的工具Rust，就可以用它花费比以前更少的成本来编写更有效、更安全的原生模块。 </p>
<p>Node.js在V8.0之前，一般使用<strong>NAN</strong>（Native Abstractions for Node.js）通用API来开发原生模块。但是在 V8.0版本中加入了全新的<strong>N-API</strong> 接口，相比 NAN，N-API 提供了兼容C-ABI的接口，消除了 </p>
<p>Node.js的版本差异，也消除了JavaScript引擎的差异。在callrust项目中创建Node.js/database.js文件并编写代码，如代码清单13-89所示。 </p>
<p>代码清单<strong>13-89</strong>：在<strong>Node.js/database.js</strong>中添加代码 </p>
<pre><code>const ffi = require(&#39;ffi-napi&#39;);
const lib = ffi.Library(&#39;../target/debug/libcallrust.dylib&#39;, {
    database_new： [&#39;pointer&#39;, []],
    database_free： [&#39;void&#39;, [&#39;pointer&#39;]],
    database_insert： [&#39;void&#39;, [&#39;pointer&#39;]],
    database_query： [&#39;uint32&#39;, [&#39;pointer&#39;, &#39;string&#39;]],
});
const Database = function() {
    this.ptr = lib.database_new();
};
Database.prototype.free = function() {
    lib.database_free(this.ptr);
};
Database.prototype.insert = function() {
    lib.database_insert(this.ptr);
};
Database.prototype.query = function(zip) {
    return lib.database_query(this.ptr, zip);
};
const database = new Database();
try {
    database.insert();
    const pop1 = database.query(&quot;10186&quot;)
    const pop2 = database.query(&quot;10852&quot;)
    console.log(pop2 - pop1)
} finally {
    database.free();
}</code></pre><p>代码清单13-89中，第1～7行使用了<strong>ffi-napi</strong>包加载Rust共享库，为其中的函数参数和返回值指定了Node.js中相应的类型。其中，ffi-napi包支持N-API接口。 </p>
<p>代码第8～10行定义了一个JavaScript类Database，并将指针lib.database_new返回的指针指定给了ptr属性。 </p>
<p>代码第11～19行通过prototype属性分别为Database添加free、insert和query方法，对应于Rust共享库中的database_free、database_insert和database_query。 </p>
<p>代码第20～28行创建Database实例，并且在try块中调用实例方法。 在finally块中调用database.free方法是为了保证Rust中定义的对象可以得到正确释放。然后执行此代码，得到预期结果。 </p>
<p>同样，社区中也提供第三方工具来提升Node.js写Rust扩展的效率，其中最常用的就是<strong>Neon</strong>。 </p>
<p>Neon由Rust实现的安全快速的本地Node.js模块绑定。它提供了JavaScript类型的包装，以及工程化的命令行工具，可以极大地提升开发者的效率。但要注意，目前 Neon 底层还是基于NAN接口，还未适配N-API。</p>
<p>为其他语言写扩展 </p>
<p>除Ruby、Python和Node.js外，另外一种构建于Erlang虚拟机BEAM的动态语言Elixir也支持使用Rust进行扩展。 </p>
<p>Elixir写原生扩展的能力是继承自Erlang语言的<strong>NIF</strong>（Native Implemented Function））功能。NIF允许Erlang动态加载C语言的动态库到进程空间中（和libffi功能差不多），可以拥有和C接近的性能。但是NIF编写的扩展安全性不高，如果产生了段错误（使用C/C++比较容易产生段错误），就会导致NIF崩溃，进而导致整个Erlang虚拟机崩溃。 </p>
<p>Erlang的虚拟机如果崩溃了，那么 Erlang 所带来的可靠、容错等特性都 将烟消云散。所以，使用 Rust 可以有效地解决编写NIF扩展安全性不高的问题。</p>
<p>Rust 社区提供了一个方便开发者编写安全NIF扩展的工具<strong>Rustler</strong>，使用它不会导致BEAM崩溃，并且同时适用于Erlang和Elixir。当然，优先适用于Elixir。更多的内容可以参考Rustler的文档和示例。 </p>
<p>通过FFI，Rust还可以和其他很多语言打交道，包括Java、Swfit、Lua、Haskell和OCmal等。社区中也存在如下方便的开发工具：</p>
<ul>
<li><p><strong>jni-rs</strong>，Rust的JNI绑定，用于和Java通信。 </p>
</li>
<li><p><strong>rlua</strong>，Rust的Lua绑定，用于和Lua通信。 </p>
</li>
<li><p><strong>rmal</strong>，Rust的OCmal绑定，用于和OCmal通信。 </p>
</li>
</ul>
<p>相信随着时间的推移，这些工具会越来越丰富。</p>
<h2 id="13-4-Rust与WebAssembly"><a href="#13-4-Rust与WebAssembly" class="headerlink" title="13.4 Rust与WebAssembly"></a>13.4 Rust与WebAssembly</h2><p><strong>WebAssembly是近两年兴起的一种新的字节码格式，它的缩写是“WASM”。这种格式背后的意义在于，在某种程度上，它将改变整个Web的生态。所以，Rust 2018的重点发展目标之一就是建立针对便于开发WebAssembly的生态工具。</strong> </p>
<p><strong>WebAssembly项目是Google、MicroSoft、Mozilla等多家公司联合发起的一个面向Web的通用二进制和文本格式项目。它的出现并不是为了让开发者手写代码，而是作为C/C++/Rust语言的一种编译目标</strong>，这样就产生了一个巨大的意义：<strong>在客户端提供了一种接近本地运行速度的多种语言编写代码的方式。在某种意义上，WebAssembly 相当于一种中间语言（IR）。</strong>其实WebAssembly的名字也由此而来，就像汇编（Assembly）语言那样是所有语言转换成机器码的通用底层语言，<strong>WebAssembly就是面向Web的汇编</strong>。 </p>
<p><strong>目前WebAssembly的重要应用领域是在浏览器中配合JavaScript API提升前端应用的性能，虽然 JavaScript 目前有很多优化的手段，效果也不错，但是它的计算性能还是很慢，对于一些计算密集型场景，就可以使用WebAssembly来替代。比如游戏的渲染引擎、物理引擎，图像音频/视频的处理和编辑、加密算法等</strong>。 </p>
<p><strong>WebAssembly比JavaScript更快的原因</strong>主要体现在以下几方面： </p>
<ul>
<li><strong>WebAssembly体积更小，下载和解析更快。WebAssembly的二进制格式就是为了更适合解析而设计，其解析速度要比JavaScript快一个数量级。</strong></li>
<li><strong>WebAssembly不受JavaScript的约束，可以利用更多的CPU特性。</strong>比如64位整数、内存读写偏移量、非内存对齐读写和多种CPU指令等。 </li>
<li><strong>生成WebAssembly编译器工具链的优化和改进。</strong>比如在Rust中，可以使用wasm-gc工具来优化生成的wasm文件的大小。 </li>
<li><strong>WebAssembly不需要垃圾回收。</strong>内存操作是手动控制，但也没必要担心内存泄漏的问题，因为WebAssembly使用的整个内存空间是由JavaScript分配的，它实际上是一个JavaScript对象，最终会由JavaScript的GC去管理。 </li>
</ul>
<p>同时，<strong>WebAssembly还在不断地朝着执行效率更高的方向发展。目前WebAssembly还不支持DOM操作，但是已经有了解决方案，就是依赖Reference Types和Host Bindings技术在WebAssembly中直接操作 JavaScript+DOM 对象和调用其方法</strong>。 </p>
<p><strong>WebAssembly</strong> 名称里虽然包含了 Web，但其发展至今，已经不仅仅局限于 <strong>Web</strong>。为了将WebAssembly嵌入到不同的环境中，其规范是被拆分到了独立的文档中，并区分了层级： </p>
<ul>
<li>核心层。定义WebAssembly模块及其指令集的语义。 </li>
<li><strong>API</strong>层。定义应用程序接口，目前指定了两个API：<strong>JavaScript API</strong>和<strong>Web API</strong>。 </li>
</ul>
<p>由此可看出，<strong>WebAssembly是独立于Web的规范，Web只是其应用的特定环境。事实上，WebAssembly还应用于除Web之外的其他领域：桌面图形化程序、区块链智能合约和编写操作系统微内核</strong>。 </p>
<p>当然，也不仅仅局限于上面所列领域，还有更多的想象空间。随着该技术的发展，将会应用到更多领域。 </p>
<h3 id="13-4-1-WebAssembly要点介绍"><a href="#13-4-1-WebAssembly要点介绍" class="headerlink" title="13.4.1 WebAssembly要点介绍"></a>13.4.1 WebAssembly要点介绍</h3><p>为了理解WebAssembly的工作机制，需要了解如下关键概念： </p>
<ul>
<li><strong>模块。模块是WebAssembly的基本编译单位，一个.wasm文件就是一个模块。</strong>其中定义了各种函数，可以被JavaScript加载调用。 </li>
<li><strong>线性内存。用于和JavaScript通信，是一个可变大小的ArrayBuffer，由JavaScript分配。</strong>WebAssembly提供了对其进行操作的指令。</li>
<li><strong>表格。用于存放函数引用，支持动态调用函数</strong>。 </li>
<li><strong>实例。一个模块的实例包括其在运行时使用的所有状态，比如内存、表格和一系列的值。</strong>同一个模块的多个实例可以共享相同的内存和表格。</li>
<li><strong>栈式机器。WebAssembly指令的运行是基于栈式机器定义的，每种类型的指令都是在栈上进行出栈和入栈操作。</strong></li>
</ul>
<p><strong>（1）文本格式wast</strong> </p>
<p><strong>WebAssembly模块提供两种格式：二进制和文本格式</strong>。<strong>其中文本格式是基于S表达式，供人类读写，所以也称为wast</strong>。文本格式和二进制格式也可以通过工具相互转换。 </p>
<p>接下来通过手写几个示例来了解WebAssembly。本书使用webassembly.studio在线WebAssembly IDE来编写示例代码。打开<a href="webassembly.studio">webassembly.studio</a>网站，从弹出的窗口中选择Empty Wat Project，单击下方的create按钮，就可以创建一个WebAssembly项目模板。项目目录如代码清单13-90所示。 </p>
<p>代码清单<strong>13-90</strong>：<strong>Empty Wat Project</strong> 模板目录 </p>
<pre><code>.
├─ README.md
├─ build.ts
├─ package.json
└─ src
    ├─ main.html
    ├─ main.js
    └─ main.wat</code></pre><p>代码清单13-90中build.ts文件专门用于构建wasm文件，并输出到out目录下。在src目录中，main.wat是一个文本格式的WebAssembly文件，在构建之后，它生成一个main.wasm文件。然后在main.js中将生成的wasm文件导入，最终在main.html中使用。 </p>
<p>接下来看看main.wat文件中默认的代码，如代码清单13-91所示。 </p>
<p>代码清单<strong>13-91</strong>：<strong>main.wat</strong>代码展示 </p>
<pre><code>(module
    (func $add (param $lhs i32) (param $rhs i32) (result i32)
        get_local $lhs
        get_local $rhs
        i32.add)
    (export &quot;add&quot; (func $add))
)</code></pre><p>看得出来，代码清单13-91中模块被表示为一个多行的S表达式。其中每一对括号都代表一个节点。括号内第一个元素是代表节点的类型，后面由空格分隔的是属性或子节点列表。所以，在代码清单13-91中一共可以分成三大节点：<strong>module</strong>、<strong>func</strong>和<strong>export</strong>。其中，module显然表示模块，func代表的是函数，export是指将模块内定义的函数导出。 </p>
<p>在代码第2行func节点中，定义了函数签名<strong>$add</strong>，以美元符<strong>$</strong>开头可以为参数、函数名或局部变量等起一个名字。除了那些导入/导出的指令，模块中几乎所有的代码都被划分到函数中。由func定义的函数签名中包含的头两个param节点是表示函数的参数，均为i32类型。最后一个result节点代表函数的返回值，同为i32类型。 </p>
<p>代码第3～5行则定义了函数体。其中get_local指令是用于获取参数的值，最后调用i32.add操作，表示将两个i32类型的参数进行相加，该操作是WebAssembly内置的运算符[16]。wasm文件执行是以栈式机器定义的，<strong>get_local</strong>指令会将它读到的参数值压到栈上，然后i32.add从栈上取出两个i32类型的值进行求和，将计算结果压到栈顶。 </p>
<p>代码第6行中，export节点是一个导出声明。在export指令后面定义的“add”是指定给JavaScript用的函数名。 </p>
<p>这就是文本格式的WebAssembly代码，然后看看main.js中如何导入。如代码清单13-92所示。 </p>
<p>代码清单<strong>13-92</strong>：<strong>main.js</strong>代码展示 </p>
<pre><code>fetch(&#39;../out/main.wasm&#39;).then(response =&gt;
    response.arrayBUFFER()
).then(bytes =&gt; WebAssembly.instantiate(bytes))
.then(results =&gt; {
    instance = results.instance;
    document.getElementById(&quot;container&quot;).innerText = 
        instance.exports.add(1, 1);
}).catch(console.error);</code></pre><p>代码清单13-92中使用了<strong>fetch</strong>方法来异步加载编译好的out/main.wasm二进制文件，然后将其转换成<strong>ArrayBuffer</strong>。当然也可以使用XHR来加载wasm文件。 </p>
<p>接着使用<strong>WebAssembly.instantiate</strong>方法编译并实例化模块，在此过程中会导出一个add方法给JavaScript使用。最后通过<strong>instance.exports.add</strong>调用该方法。 </p>
<p>最终，通过单击webassembly.studio在线IDE提供的build&amp;run按钮，编译并运行该示例，会输出结果“<strong>2</strong>”。 </p>
<p>使用<strong>WebAssembly</strong>内存和<strong>JavaScript</strong>交互因为WebAssembly当前只支持<strong>i32</strong>、<strong>i64</strong>、<strong>f32</strong>和<strong>f64</strong>这四种可用的基本类型，所以，为了处理字符串以及其他复杂的类型，WebAssembly提供了内存。WebAssembly的内存实际上是一种可增长的线性字节数组，由JavaScript通过WebAssembly.Memory接口来创建。 </p>
<p>接下来重新编写main.wat，让其可以输出字符串“Hi WASM”，如代码清单13-93所示。 </p>
<p>代码清单<strong>13-93</strong>：重写<strong>main.wat</strong>以便打印字符串 </p>
<pre><code>(module
    (import &quot;console&quot; &quot;log&quot; (func $log (param i32 i32)))
    (import &quot;js&quot; &quot;mem&quot; (memory 1))
    (data (i32.const 0) &quot;Hi WASM,&quot;)
    (data (i32.const 8) &quot;I&#39;m Coming&quot;)
    (func (export &quot;writeHi&quot;)
    i32.const 0
    i32.const 18
    call $log)
)</code></pre><p>代码清单13-93定义的模块中，一共包含三种主要的节点：<strong>import</strong>、<strong>data</strong>和<strong>func</strong>。 </p>
<p>代码第2行和第3行的<strong>import</strong>节点是导入JavaScript的方法或对象供WebAssembly使用。其中第2行导入console.log方法，为其起名为<strong>$log</strong>。 </p>
<p>代码第3行导入由JavaScript创建的内存，并且指定了内存至少为<strong>1</strong>页（64KB）。导入的函数签名会被WebAssembly进行静态检查。</p>
<p>代码第4行使用<strong>data</strong>指令把数据写入到内存中。其中“（i32 const 0）”用于指定在线性内存中放置数据的偏移量，这里的数字0代表起始位置。代码第5行通过data指令把另一个字符串存入内存中，但是其偏移量为8，这是因为第一个字符串“Hi WASM，”的长度为8，而起始地址是0，只有偏移量设置为8或者是大于8的数字，才不会覆盖第一个字符串。</p>
<p>代码第6～9行导出writeHi函数给JavaScript来调用。其中call指令调用了由JavaScript导入的$log函数。 </p>
<p>接下来修改main.js，如代码清单13-94所示。 </p>
<p>代码清单<strong>13-94</strong>：重写<strong>main.js</strong> </p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebAssembly<span class="token punctuation">.</span>Memory</span><span class="token punctuation">(</span><span class="token punctuation">{</span>initial<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">consoleLogString</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vat bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>memory<span class="token punctuation">.</span>buffer<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextDecoder</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> importObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    consolo<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">:</span> consoleLogString
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    js<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        mem<span class="token punctuation">:</span> memory
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
WebAssembly<span class="token punctuation">.</span><span class="token function">instantiateStreaming</span><span class="token punctuation">(</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'../out/main.wasm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> importObject
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>obj <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function">writeHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-94中第1行使用<strong>WebAssembly.Memory</strong>方法为wasm分配指定的1页内存。 </p>
<p>代码第2～6行实现了consoleLogString函数，通过传入内存偏移地址offset和字符串长度length，调用<strong>Uint8Array</strong>和<strong>TextDecoder</strong>方法对wasm内存中的字符串进行解码，因为wasm中的字符串只是原始的字节，只有通过解码才能在JavaScript中使用。代码第7～14行定义了importObject，该JavaScript对象是用于导入到 wasm中使用的log方法和内存。与wat文本格式代码中的两个import节点相对应。</p>
<p>代码第15～19行，通过<strong>WebAssembly.instantiateStreaming</strong>方法直接从底层进行流式源码编译和实例化模块，这是加载wasm最有效、最优化的方法。 </p>
<p>现在单击webassembly.studio在线IDE提供的build&amp;run按钮，代码编译并正常运行，输出结果为预期的“<strong>Hi WASM，I＇m Coming</strong>”。 </p>
<p><strong>(2) 表格与动态链接</strong> </p>
<p>表格和内存类似，只不过表格是必须通过索引才能获取的可变大小的数组。在日常开发中，经常需要动态调用一些函数。而这些函数不能直接存储在内存中，因为内存会把存储的原始内容作为字节暴露出去。 </p>
<p>如果函数存储在内存中，wasm 就可以任意查看和修改原始函数地址，这是极度不安全的行为。所以，在表格中存储函数引用，然后返回表格的索引，通常为i32类型。通过<strong>call_indirect</strong>指令可以调用索引值，从而达到调用函数的目的。 </p>
<p>多个wasm可以实现动态链接，模块实例可以共享相同的内存和表格。通过内存和表格，就可以实现JavaScript和wasm的基本互操作。接下来使用webassembly.studio在线IDE重新创建一个空的 wat 项目。将默认的 src/main.wat 删除，重新创建 src/shared0.wat 和src/shared1.wat，然后修改build.ts代码，如代码清单13-95所示。 </p>
<p>代码清单<strong>13-95</strong>：修改<strong>build.ts</strong>中的代码</p>
<pre><code>gulp.task(&quot;build&quot;, async() =&gt; {
    const data0 = await Service.assembleWat(
        project.getFile(&quot;src/shared0.wat&quot;).getData()
    );
    const outWasm0 = project.newFile(
        &quot;out/shared0.wasm&quot;, &quot;wasm&quot;, true
    );
    outWasm0.setData(data0);
    const data1 = await Service.assembleWat(
        project.getFile(&quot;src/shared1.wat&quot;).getData()
    );
    const outWasm1 = project.newFile(&quot;out/shared1.wasm&quot;, &quot;wasm&quot;, true);
    outWasm1.setData(data1);
});</code></pre><p>将build.ts文件中的gulp.task任务代码修改为代码清单13-95所示。因为现在需要编译shared0.wat和shared1.wat这两个WebAssembly文件。 </p>
<p>打开shared0.wat文件编写代码，如代码清单13-96所示。 </p>
<p>代码清单<strong>13-96</strong>：为<strong>shared0.wat</strong>编写代码 </p>
<pre><code>(module
    (import &quot;js&quot; &quot;memory&quot; (momory 1))
    (import &quot;js&quot; &quot;table&quot; (table 1 anyfunc))
    (elem (i32.const 0) $shared0func)
    (func $shared0func (result i32)
        i32.const 0
        i32.load)
)</code></pre><p>代码清单13-96中，第2行和第3行导入了由JavaScript定义的内存和表格。其中定义的表中数字1代表初始大小，表示该表中将存储1个函数引用，而<strong>anyfunc</strong>代表“任意签名的函数”。 </p>
<p>代码第4行，使用<strong>elem</strong>指令表示将<strong>$shared0func</strong>函数存储到表格偏移量为0的位置上。该elem的用法和内存<strong>data</strong>操作类似。 </p>
<p>代码第 5～7 行定义了函数<strong>$shared0func</strong>，包含两个指令。首先创建一个常数 0，然后使用i32.load指令从内存中获取存储到常数0位置的值，获取回来的值会被放到栈顶，就是该函数的返回值。 </p>
<p>然后继续为shared1.wat编写代码，如代码清单13-97所示。 </p>
<p>代码清单<strong>13-97</strong>：为<strong>shared1.wat</strong>编写代码</p>
<pre><code>(module
    (import &quot;js&quot; &quot;memory&quot; (momory 1))
    (import &quot;js&quot; &quot;table&quot; (table 1 anyfunc))
    (type $void_to_i32 (func (result i32))
    (func (export &quot;doIt&quot;) (result i32)
        i32.const 0
        i32.const 42
        i32.store
        i32.const 0
        call_indirect (type $void_to_i32))     
)</code></pre><p>代码清单13-97中同样导入了由JavaScript端创建的内存和表格对象。然后代码第4行通过 type 指令创建了一个函数类型$void_to_i32，该类型用于在后续的表格函数引用调用时进行类型检查。 </p>
<p>代码第5～10行定义了导出给JavaScript用的函数doIt。其中代码第6～8行的指令等价于“（i32.store （i32.const 0） （i32.const 42））”，就是将常量42存储到索引为0的内存中。 </p>
<p>代码第9、10行等价于“（call_indirect（type$void_to_i32）（i32.const 0））”，是从表格中取索引为0的函数引用，该函数引用正是shared0.wat中所存储的$shared0func。 </p>
<p>最后，编写src/main.js文件，在其中创建wasm需要的内存和表格， 并加载由shared0.wat和shared1.wat生成的wasm二进制文件。如代码清单13-98所示。 </p>
<p>代码清单<strong>13-98</strong>：为<strong>main.js</strong>编写代码</p>
<pre><code>var importObj = {
    js: {
        memory: new WebAssembly.Memory({initial: 1}),
        table: new WebAssembly.Table({initial: 1, element: &quot;anyfunc&quot;})
    }
};
Promise.all([
    WebAssembly.instantiateStreaming(
        fetch(&#39;../out/shared1.wasm&#39;), importObj)
]).then(function(resuolts){
    console.log(result[1].instance.exports.doIt());
});</code></pre><p>代码清单13-98中创建了importObj对象，通过WebAssembly.Memory和<strong>WebAssembly.Table</strong>分别创建内存和表格。 </p>
<p>然后通过 Promise.all 方法异步加载 shared0.wasm 和 shared1.wasm，最后调用实例模块shared1中导出的函数doIt。 </p>
<p>现在单击webassembly.studio在线IDE提供的build&amp;run按钮，代码编 </p>
<p>译并正常运行，输出结果为预期的“<strong>42</strong>”。 </p>
<h3 id="13-4-2-使用Rust开发WebAssembly"><a href="#13-4-2-使用Rust开发WebAssembly" class="headerlink" title="13.4.2 使用Rust开发WebAssembly"></a>13.4.2 使用Rust开发WebAssembly</h3><p>固然可以手写wat文本格式开发wasm模块，但是效率显然不会很高。WebAssembly设计之初也是为了作为一种编译目标而存在的，它可以作为很多编程语言的编译目标： </p>
<ul>
<li><p><strong>C/C++</strong>，可以通过<strong>EmScripten</strong>工具来编译到wasm。EmScripten是一个LLVM后端工具，可以将LLVM中间码编译到asm.js。所以，C/C++的编译流程是通过任何一个LLVM前端工具（比如Clang）生成LLVM IR，然后通过EmScripten生成asm.js，最后通过一个WebAssembly编译工具链Binaryen将asm.js生成wasm二进制格式。其中 asm.js是JavaScript的一个子集，可以说它是WebAssembly的雏形。在一些不支持wasm的浏览器中，也可以使用asm.js来代替。 </p>
</li>
<li><p><strong>Rust</strong>，支持wasm的两种编译目标。 </p>
<p>➢<strong>wasm32-unknown-unknown</strong>，使用的是LLVM WebAssembly Backend和lld链接器。 </p>
<p>➢<strong>wasm32-unknown-emscripten</strong>，会继续使用EmScripten，和C/C++类似。 </p>
</li>
</ul>
<p>以wasm32-unknown-unknown目标为例，来看看Rust如何开发wasm。首先，需要搭建wasm的开发环境。使用rustup命令即可，如代码清单13-99所示。 </p>
<p>代码清单<strong>13-99</strong>：<strong>rustup</strong>命令 </p>
<pre><code>$ rustup toolchain install nightly
$ rustup target add wasm32-unknown-unknown --toolchain nightly</code></pre><p>清单 13-99 中使用 rustup 命令选择 Nightly 工具链，然后使用 rustup target add 添加wasm32-unknown-unknown目标，rustup会自动安装所需要的环境。</p>
<p>环境配置好以后，使用<strong>cargo new–lib</strong>命令创建新的项目hello_wasm。先在Cargo.toml文件中添加lib配置，如代码清单13-100所示。</p>
<p>代码清单<strong>13-100</strong>：修改<strong>Cargo.toml</strong> </p>
<pre><code>[lib]
path = &quot;src/lib.rs&quot;
crate-type = [&quot;cdylib&quot;]</code></pre><p>然后修改src/lib.rs文件，如代码清单13-101所示。 </p>
<p>代码清单<strong>13-101</strong>：修改<strong>src/lib.rs</strong></p>
<pre class="line-numbers language-rust"><code class="language-rust">#<span class="token punctuation">[</span><span class="token function">link</span><span class="token punctuation">(</span>wasm_import_module <span class="token operator">=</span> <span class="token string">"env"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">logit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> u8<span class="token punctuation">,</span> len<span class="token punctuation">:</span> u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">fn</span> <span class="token function">add_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token function">logit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> msg <span class="token operator">=</span> <span class="token function">format!</span><span class="token punctuation">(</span><span class="token string">"Hello world: {}"</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">hello</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在代码清单13-101中，第1～5行通过extern ＂C＂块导入JavaScript中定义的函数logit和hello函数。其中<strong>logit</strong>函数是打算调用JavaScript中的console.log方法，而<strong>hello</strong>函数是接收指针和长度作为参数，目的是打算将Rust中的字符串通过wasm传递到JavaScript中使用。注意，在第1行使用了<strong>＃[link（wasm_import_module=＂env＂）]</strong>属性来指定extern块的wasm模块名字为env，也可以改为其他名字，但如果不使用该属性，默认就是env。 </p>
<p>本质上，Rust还是通过导出兼容C-ABI的接口，经过<strong>LLVM WebAssembly Backend</strong>的编译和<strong>lld</strong>的链接，最终输出为wasm二进制。 所以这里使用extern块。 </p>
<p>在代码第6～12行，使用＃<strong>[no_mangle]</strong>和<strong>pub extern</strong>＂<strong>C</strong>＂定义函数<strong>add_one</strong>，该函数会接收一个 i32 整数类型，在函数中会对其进行指定的计算，最后输出一行字符串。该函数中调用了logit和hello函数。在 第9行定义了msg字符串变量，然后通过调用msg.as_ptr方法得到该字符串的原生指针传给hello函数。 </p>
<p>接下来在hello_wasm项目根目录下创建hello.html和hello.js文件，并修改hello.html文件，如代码清单13-102所示。 </p>
<p>代码清单<strong>13-102</strong>：修改<strong>hello.html</strong>文件</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello wasm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./hello.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-102是一个简单的HTML文件。注意，代码第6行引入了hello.js文件。然后开始修改hello.js文件，如代码清单13-103所示。 </p>
<p>代码清单<strong>13-103</strong>：修改<strong>hello.js</strong>文件 </p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> mod<span class="token punctuation">;</span>
<span class="token keyword">var</span> imports <span class="token operator">=</span> <span class="token punctuation">{</span>
    logit<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this was invoked by Rust, written in JS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    hello<span class="token punctuation">:</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Unit8Array</span><span class="token punctuation">(</span>
            mod<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>buffer<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> len
        <span class="token punctuation">)</span>
        <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextDecoder</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'out/small_hello.wasm'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>bytes <span class="token operator">=</span><span class="token operator">></span> WebAssembly<span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token punctuation">{</span>env<span class="token punctuation">:</span> imports<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        mod <span class="token operator">=</span> module<span class="token punctuation">;</span>
        module<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function">add_one</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码清单13-103中第1行声明了mod变量，代表加载的wasm模块实例，供后面使用。在代码第2～13行定义了imports对象，包含了logit和hello的函数定义。</p>
<p>值得注意的是，hello函数的<strong>ptr</strong>参数实际上只是一个数字，它代表WebAssembly.Memory内存中数据的索引。在该函数内部，通过Uint8Array和TextDecoder方法将ptr对应的内存中的值转换为JavaScript字符串。注意，Uint8Array的第一个参数<strong>mod.instance.exports.memory.buffer</strong>将得到ArrayBuffer对象以供操作。</p>
<p>最后，在第 14～20 行使用 fetch 方法加载 wasm 文件，并得到arrayBuffer，通过WebAssembly.instantiate将imports对象传给指定的模块env，对wasm模块进行编译和实例化。最后调用模块实例化对象中的方法add_one。 </p>
<p>接下来就可以将Rust代码编译为wasm，在<strong>hello_wasm</strong>目录下创建 <strong>output</strong>目录，以便存放生成的wasm文件。生成wasm需要三条命令，如代码清单13-104所示。 </p>
<p>代码清单<strong>13-104</strong>：生成<strong>wasm</strong>需要的三条命令 </p>
<pre><code>$ cargo build --target wasm32-unknown-unknown
$ cp target/wasm32-unknown-unknown/debug/hello_wasm.wasm output
$ wasm-gc output/hello_wasm.wasm output/small_hello.wasm</code></pre><p>代码清单13-104中第一条是cargo build指定了wasm32-unknown-unknown作为target，最终会在 taget/wasm32-unknown-unknown/debug 目录下生成 hello.wasm。然后将其复制到output 目录下。最后使用 <strong>wasm-gc</strong>工具将 output/hello_wasm.wasm的大小进行裁剪，得到output/small_hello.wasm文件。当然也可以使用make自动化处理这三条命令。</p>
<p>可以通过<strong>cargo install wasm-gc</strong>安装该工具。在网页中加载的wasm越小越好。不过随着lld链接器的进一步完善，增加了链接时优化（LTO）功能就不需要使用wasm-gc了。 </p>
<p>现在通过浏览器[19]打开hello_wasm/hello.html，会看到弹出窗口中显示“<strong>Hello world</strong>：<strong>42</strong>”，说明Rust代码编译的wasm已经可以正常使用。</p>
<h3 id="13-4-3-打造WebAssembly开发生态"><a href="#13-4-3-打造WebAssembly开发生态" class="headerlink" title="13.4.3 打造WebAssembly开发生态"></a>13.4.3 打造WebAssembly开发生态</h3><p>即便是使用Rust编写代码再编译为wasm，开发效率还是比较低。WebAssembly标准只定义了四种类型：两种数字和两种浮点数。在大多数情况下，这四种类型完全不够用。因此，Rust官方打造了以wasm-bindgen为首的一系列工具，旨在提升Rust开发wasm的体验。这一系列工具重点包括： </p>
<ul>
<li><strong>wasm-bindgen</strong>，核心是促进Javascript和Rust之间使用wasm进行通信。它允许开发者直接使用Rust的结构体、Javascript的类、字符串等类型，而不仅仅是wasm支持的整数或浮点数。开发者只需要专注于他的业务即可。 </li>
<li><strong>wasm-pack</strong>，一站式构建、发布Rust编译的wasm到npm平台。不需要安装npm、node.js等JavaScript环境，wasm-pack会编译并优化生成JavaScript绑定，然后发布到npm中。 </li>
<li><strong>cargo-generate</strong>，直接生成wasm-bindgen和wasm-pack项目模板，方便开发。 </li>
</ul>
<p>从这三个工具可以一瞥Rust官方对Rust和WebAssembly的愿景：希望可以更方便地使用Rust开发wasm，并且不需要改变现有开发流程。</p>
<p>wasm-bindgen 致力于为 JavaScript 生态和 Rust crate 生态系统建立共享的基础。wasm-bindgen 通过内置的 <strong>js-sys</strong> 包提供了对所有全局JavaScript API 的绑定，只需要通过wasm_bindgen：：js即可调用。同样，通过内置的<strong>web-sys</strong>包提供了对所有Web API的绑定，方便开发者调用。</p>
<p>可以使用 <strong>cargo install cargo-generate</strong> 命令安装 cargo-generate，安装好之后使用cargo-generate命令可以生成wasm-bindgen项目的模板，如代码清单13-105所示。 </p>
<p>代码清单<strong>13-105</strong>：<strong>cargo-generate</strong>命令生成模板项目 </p>
<pre><code>$ cargo-generate --git \
    https://github.com/ashleygwilliams/wasm-pack-template</code></pre><p>此命令生成的模板项目会默认在 Cargo.toml 文件中配置好 wasm-bindgen。要使用wasm-bindgen，目前必须在Nightly版本之下先安装wasm-bindgem-cli工具，如代码清单13-106所示。</p>
<p>代码清单<strong>13-106</strong>：安装<strong>wasm-bindgen-cli</strong> </p>
<pre><code>$ cargo +nightly install wasm-bindgen-cli</code></pre><p>安装好wasm-bindgen-cli工具就可以使用wasm-bindgen命令来开发wasm项目了。在开发完成之后使用wasm-pack工具，如清单13-107所示。</p>
<p>代码清单<strong>13-107</strong>：安装<strong>wasm-pack</strong>以及使用<strong>wasm-pack</strong>打包命令</p>
<pre><code>$ cargo install wasm-pack
$ wasm-pack build</code></pre><p>代码清单13-107中展示了两条命令。第一条是安装最新版的wasm-pack，第二条是wasm-pack build命令，在项目的根目录下执行该命令，就会自动生成JavaScript相关文件，方便打包wasm到npm平台。 </p>
<p>这就是Rust的一站式wasm开发体验。更多详细的内容可以参考wasm-bindgen的文档[20]和项目中的示例代码。 </p>
<p>除官方外，社区也在不断地对WebAssembly进行探索，比较有代表性的框架有： </p>
<ul>
<li><strong>stdweb</strong>，基于Rust和WebAssembly实现的Web客户端标准库。该库主要用于写Web客户端。未来可能会被web-sys替代。 </li>
<li><strong>cargo-web</strong>，方便编写Web客户端的Cargo子命令库。 </li>
<li><strong>yew</strong>，用于构建客户端Web应用的Rust框架，基于stdweb库，灵感来自Elm和React框架。 </li>
<li><strong>percy</strong>，实现了一个虚拟Dom，可以根据服务端的HTML字符串渲染到浏览器的Dom，完全同构，纯Rust和Wasm实现一个Web应用。 </li>
<li><strong>ruukh</strong>，一个实验性的Rust Web前端开发框架。受Vue.js和React.js的启发，基于Rust和WebAssembly。 </li>
</ul>
<p>看来，使用Rust进行全栈Web开发指日可待。</p>
<h2 id="13-5-小结"><a href="#13-5-小结" class="headerlink" title="13.5 小结"></a>13.5 小结</h2><p>只有彻底了解什么是不安全，才能对安全有更深的认知。学习Unsafe Rust的过程，才能对Safe Rust有更深的理解。从这个角度来说，本章算得上是全书的“点睛之笔”。 </p>
<p>可以说，<strong>Safe Rust是构建于Unsafe Rust之上的。使用Unsafe Rust意味着编译器将不能百分百地保证类型安全和内存安全，将会有产生未定义行为的风险。Unsafe Rust是将保证安全的职责交给了开发者。</strong>本章通过深入探讨Unsafe Rust编程中可能产生未定义行为的情况，阐述了如何对Unsafe代码进行安全抽象。标准库里也封装了很多Unsafe代码。事实上，Rust迄今为止曝光的安全漏洞基本和Unsafe代码有关。 </p>
<p>当然，目前Rust官方还在努力构建UnsafeRust的内存模型。在未来，也许可以由Rust编译器检查出Unsafe代码中的未定义行为。 </p>
<p><strong>为了和其他语言“打交道”，Rust也提供了FFI，允许开发者非常方便地生成兼容C-ABI的库</strong>。本章通过Rust和C、CPP、Ruby、Python、Node.js语言交互的示例，阐述了Rust如何编写FFI，以及深入理解FFI。 </p>
<p><strong>随着WebAssembly技术的兴起，Rust在2018年也开始以“打造WebAssembly最佳开发工具链”为目标发展。</strong>本章介绍了WebAssembly基础，以及如何使用Rust开发WebAssembly。此外，Rust官方还推出了wasm-bindgen和wasm-pack工具链，为WebAssembly的开发提供了极大的便利。</p>
<p>除了WebAssembly，Rust还应用于众多领域，比如Web、网络基础、分布式系统、游戏和区块链等。因篇幅有限，本书不能一一为读者展现。读者在学会Rust之后，可以自行探索感兴趣的领域。 </p>

            </div>
            <hr />
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform: scale(1.3);
        -webkit-transform: scale(1.3);
        -o-transform: scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">
                写作不易，客官能否打赏一杯奶茶？
            </h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
                    

                        <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

                            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第13章 超越安全的边界》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/03/22/the-tao-of-rust-programming-13/" property="cc:attributionName"
               rel="cc:attributionURL">
                bill
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '查教程获取',
        clientSecret: '查教程获取',
        repo: 'billbliu.github.io',
        owner: 'billbliu',
        admin: "billbliu",
        id: '2021/03/22/the-tao-of-rust-programming-13/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
            

                

                            

                                        

                                                    
                                                        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

                                                            

                                                                

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/04/16/sql-language/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="SQL四种语言：DDL,DML,DCL,TCL">
                        
                        <span class="card-title">SQL四种语言：DDL,DML,DCL,TCL</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、DDLDDL（Data Definition Language）数据库定义语言statements are used to define the database structure or schema.
DDL是SQL语言的四大功能之
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/数据库/" class="post-category" target="_blank">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SQL/" target="_blank">
                        <span class="chip bg-color">SQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/21/the-tao-of-rust-programming-12/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="第12章 元编程">
                        
                        <span class="card-title">第12章 元编程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            道生一，一生二，二生三，三生万物。 
元编程来源于 Meta-Programming 一词。Meta 表示“关于某事本身的某事”。比如Meta-Knowledge，代表“关于知识本身的知识”，称为元知识。再如Meta-Cognition，代
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/书籍专栏/" class="post-category" target="_blank">
                                    书籍专栏
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rust编程之道/" target="_blank">
                        <span class="chip bg-color">Rust编程之道</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    <script>
        $('#articleContent').on('copy', function (e) {
            // IE8 or earlier browser is 'undefined'
            if (typeof window.getSelection === 'undefined') return;

            var selection = window.getSelection();
            // if the selection is short let's not annoy our users.
            if (('' + selection).length < Number.parseInt('120')) {
                return;
            }

            // create a div outside of the visible area and fill it with the selected text.
            var bodyElement = document.getElementsByTagName('body')[0];
            var newdiv = document.createElement('div');
            newdiv.style.position = 'absolute';
            newdiv.style.left = '-99999px';
            bodyElement.appendChild(newdiv);
            newdiv.appendChild(selection.getRangeAt(0).cloneContents());

            // we need a <pre> tag workaround.
            // otherwise the text inside "pre" loses all the line breaks!
            if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
                newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
            }

            var url = document.location.href;
            newdiv.innerHTML += '<br />'
                + '来源: bill的博客<br />'
                + '作者: bill<br />'
                + '链接: <a href="' + url + '">' + url + '</a><br />'
                + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

            selection.selectAllChildren(newdiv);
            window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
        });
    </script>

    <!--<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
    <script>
        const btw = new BTWPlugin();
        btw.init({
            id: 'artDetail',
            blogId: '20962-1585405055583-879',
            name: '算法码上来',
            qrcode: 'https://godweiyang.com/medias/gzh.jpg',
            keyword: 'VIP',
        });
    </script>
-->
    
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; Bill. 版权所有

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">
                    445.9k
                </span>
                

                    <br>
                    <span id="sitetime"></span>

                    
                        
        </div>
        <div class="col s12 m4 l4 social-link ">
            
    <a href="https://github.com/billbliu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:billliu201919@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=1321531943&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>

        </div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        // 50ms周期检测函数
        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>

</html>